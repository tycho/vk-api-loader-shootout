From 4acf4fb0da25c54fc58f78a384c4a89caafbb139 Mon Sep 17 00:00:00 2001
From: Steven Noonan <steven@uplinklabs.net>
Date: Mon, 6 Jan 2025 03:40:47 -0800
Subject: [PATCH] use xxhash for function name lookups

Signed-off-by: Steven Noonan <steven@uplinklabs.net>
---
 loader/debug_utils.c                    |   17 +-
 loader/debug_utils.h                    |    2 +-
 loader/generated/vk_loader_extensions.c | 2294 +++----
 loader/generated/vk_loader_extensions.h |    7 +-
 loader/gpa_helper.c                     |  483 +-
 loader/loader.c                         |   38 +-
 loader/trampoline.c                     |   20 +-
 loader/wsi.c                            |  100 +-
 loader/wsi.h                            |    2 +-
 loader/xxhash.h                         | 7246 +++++++++++++++++++++++
 scripts/loader_extension_generator.py   |   27 +-
 11 files changed, 8749 insertions(+), 1487 deletions(-)
 create mode 100644 loader/xxhash.h

diff --git a/loader/debug_utils.c b/loader/debug_utils.c
index 1506dc530..6fbf375f8 100644
--- a/loader/debug_utils.c
+++ b/loader/debug_utils.c
@@ -622,32 +622,31 @@ void check_for_enabled_debug_extensions(struct loader_instance *ptr_instance, co
     }
 }
 
-bool debug_extensions_InstanceGpa(struct loader_instance *ptr_instance, const char *name, void **addr) {
+bool debug_extensions_InstanceGpa(struct loader_instance *ptr_instance, const char *name, uint64_t nameHash, void **addr) {
     bool ret_type = false;
 
     *addr = NULL;
 
-    if (!strcmp("vkCreateDebugReportCallbackEXT", name)) {
+    if (nameHash == 0xc6fc422cd58e5529 /* vkCreateDebugReportCallbackEXT */) {
         *addr =
             ptr_instance->enabled_known_extensions.ext_debug_report == 1 ? (void *)debug_utils_CreateDebugReportCallbackEXT : NULL;
         ret_type = true;
-    } else if (!strcmp("vkDestroyDebugReportCallbackEXT", name)) {
+    } else if (nameHash == 0x059fe1d29b964023 /* vkDestroyDebugReportCallbackEXT */) {
         *addr =
             ptr_instance->enabled_known_extensions.ext_debug_report == 1 ? (void *)debug_utils_DestroyDebugReportCallbackEXT : NULL;
         ret_type = true;
-    } else if (!strcmp("vkDebugReportMessageEXT", name)) {
+    } else if (nameHash == 0xf8caa79963b34129 /* vkDebugReportMessageEXT */) {
         *addr = ptr_instance->enabled_known_extensions.ext_debug_report == 1 ? (void *)debug_utils_DebugReportMessageEXT : NULL;
-        return true;
-    }
-    if (!strcmp("vkCreateDebugUtilsMessengerEXT", name)) {
+        ret_type = true;
+    } else if (nameHash == 0xac3d63a0aa914896 /* vkCreateDebugUtilsMessengerEXT */) {
         *addr =
             ptr_instance->enabled_known_extensions.ext_debug_utils == 1 ? (void *)debug_utils_CreateDebugUtilsMessengerEXT : NULL;
         ret_type = true;
-    } else if (!strcmp("vkDestroyDebugUtilsMessengerEXT", name)) {
+    } else if (nameHash == 0xe2b2bc73c22cab4e /* vkDestroyDebugUtilsMessengerEXT */) {
         *addr =
             ptr_instance->enabled_known_extensions.ext_debug_utils == 1 ? (void *)debug_utils_DestroyDebugUtilsMessengerEXT : NULL;
         ret_type = true;
-    } else if (!strcmp("vkSubmitDebugUtilsMessageEXT", name)) {
+    } else if (nameHash == 0x85676a060d008587 /* vkSubmitDebugUtilsMessageEXT */) {
         *addr = ptr_instance->enabled_known_extensions.ext_debug_utils == 1 ? (void *)debug_utils_SubmitDebugUtilsMessageEXT : NULL;
         ret_type = true;
     }
diff --git a/loader/debug_utils.h b/loader/debug_utils.h
index 9472ef947..cbefa1089 100644
--- a/loader/debug_utils.h
+++ b/loader/debug_utils.h
@@ -30,7 +30,7 @@
 
 VkResult add_debug_extensions_to_ext_list(const struct loader_instance *inst, struct loader_extension_list *ext_list);
 void check_for_enabled_debug_extensions(struct loader_instance *ptr_instance, const VkInstanceCreateInfo *pCreateInfo);
-bool debug_extensions_InstanceGpa(struct loader_instance *ptr_instance, const char *name, void **addr);
+bool debug_extensions_InstanceGpa(struct loader_instance *ptr_instance, const char *name, uint64_t nameHash, void **addr);
 bool debug_utils_ReportFlagsToAnnotFlags(VkDebugReportFlagsEXT dr_flags, bool default_flag_is_spec,
                                          VkDebugUtilsMessageSeverityFlagBitsEXT *da_severity,
                                          VkDebugUtilsMessageTypeFlagsEXT *da_type);
diff --git a/loader/generated/vk_loader_extensions.c b/loader/generated/vk_loader_extensions.c
index 542beef7e..bb040db89 100644
--- a/loader/generated/vk_loader_extensions.c
+++ b/loader/generated/vk_loader_extensions.c
@@ -34,6 +34,8 @@
 #include "wsi.h"
 #include "debug_utils.h"
 #include "extension_manual.h"
+#define XXH_INLINE_ALL
+#include <xxhash.h>
 
 // Device extension error function
 VKAPI_ATTR VkResult VKAPI_CALL vkDevExtError(VkDevice dev) {
@@ -1569,13 +1571,12 @@ VKAPI_ATTR VkResult VKAPI_CALL SetDebugUtilsObjectTagEXT(
     const VkDebugUtilsObjectTagInfoEXT*         pTagInfo);
 
 // Device command lookup function
-VKAPI_ATTR void* VKAPI_CALL loader_lookup_device_dispatch_table(const VkLayerDispatchTable *table, const char *name, bool* found_name) {
+VKAPI_ATTR void* VKAPI_CALL loader_lookup_device_dispatch_table(const VkLayerDispatchTable *table, const char *name, uint64_t nameHash, bool* found_name) {
     if (!name || name[0] != 'v' || name[1] != 'k') {
         *found_name = false;
         return NULL;
     }
 
-    name += 2;
     *found_name = true;
     struct loader_device* dev = (struct loader_device *)table;
     const struct loader_instance* inst = dev->phys_dev_term->this_icd_term->this_instance;
@@ -1583,1528 +1584,1528 @@ VKAPI_ATTR void* VKAPI_CALL loader_lookup_device_dispatch_table(const VkLayerDis
 
 
     // ---- Core Vulkan 1.0 commands
-    if (!strcmp(name, "GetDeviceProcAddr")) {
+    if (nameHash == 0x39595c56305c625a /* vkGetDeviceProcAddr */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->GetDeviceProcAddr;
     }
-    if (!strcmp(name, "DestroyDevice")) {
+    if (nameHash == 0x9ef6b4cec6a221f8 /* vkDestroyDevice */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyDevice;
     }
-    if (!strcmp(name, "GetDeviceQueue")) {
+    if (nameHash == 0x24683f73b0e5e597 /* vkGetDeviceQueue */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->GetDeviceQueue;
     }
-    if (!strcmp(name, "QueueSubmit")) {
+    if (nameHash == 0x0c3e489641018fd0 /* vkQueueSubmit */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->QueueSubmit;
     }
-    if (!strcmp(name, "QueueWaitIdle")) {
+    if (nameHash == 0x1fce1bdecaf06b52 /* vkQueueWaitIdle */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->QueueWaitIdle;
     }
-    if (!strcmp(name, "DeviceWaitIdle")) {
+    if (nameHash == 0x1de9fd31feb0f22f /* vkDeviceWaitIdle */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DeviceWaitIdle;
     }
-    if (!strcmp(name, "AllocateMemory")) {
+    if (nameHash == 0x3339f46d399c78c5 /* vkAllocateMemory */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->AllocateMemory;
     }
-    if (!strcmp(name, "FreeMemory")) {
+    if (nameHash == 0xf2c5ad0d9aa4acf3 /* vkFreeMemory */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->FreeMemory;
     }
-    if (!strcmp(name, "MapMemory")) {
+    if (nameHash == 0x808f7434b0596604 /* vkMapMemory */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->MapMemory;
     }
-    if (!strcmp(name, "UnmapMemory")) {
+    if (nameHash == 0xf51a3c7f77277e37 /* vkUnmapMemory */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->UnmapMemory;
     }
-    if (!strcmp(name, "FlushMappedMemoryRanges")) {
+    if (nameHash == 0xcdd7843304775055 /* vkFlushMappedMemoryRanges */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->FlushMappedMemoryRanges;
     }
-    if (!strcmp(name, "InvalidateMappedMemoryRanges")) {
+    if (nameHash == 0x3a0a07834723853e /* vkInvalidateMappedMemoryRanges */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->InvalidateMappedMemoryRanges;
     }
-    if (!strcmp(name, "GetDeviceMemoryCommitment")) {
+    if (nameHash == 0x40f65d68942eb094 /* vkGetDeviceMemoryCommitment */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->GetDeviceMemoryCommitment;
     }
-    if (!strcmp(name, "BindBufferMemory")) {
+    if (nameHash == 0x75dc79c2cde7708a /* vkBindBufferMemory */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->BindBufferMemory;
     }
-    if (!strcmp(name, "BindImageMemory")) {
+    if (nameHash == 0x3fab09299e5024e6 /* vkBindImageMemory */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->BindImageMemory;
     }
-    if (!strcmp(name, "GetBufferMemoryRequirements")) {
+    if (nameHash == 0xc18ca303430c5030 /* vkGetBufferMemoryRequirements */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->GetBufferMemoryRequirements;
     }
-    if (!strcmp(name, "GetImageMemoryRequirements")) {
+    if (nameHash == 0x31f122b7cfd4bda7 /* vkGetImageMemoryRequirements */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->GetImageMemoryRequirements;
     }
-    if (!strcmp(name, "GetImageSparseMemoryRequirements")) {
+    if (nameHash == 0x21e4a7d810574ab7 /* vkGetImageSparseMemoryRequirements */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->GetImageSparseMemoryRequirements;
     }
-    if (!strcmp(name, "QueueBindSparse")) {
+    if (nameHash == 0x814945b3834b2f13 /* vkQueueBindSparse */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->QueueBindSparse;
     }
-    if (!strcmp(name, "CreateFence")) {
+    if (nameHash == 0xb51bc46c54af21f6 /* vkCreateFence */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateFence;
     }
-    if (!strcmp(name, "DestroyFence")) {
+    if (nameHash == 0x865bc9e531e492a5 /* vkDestroyFence */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyFence;
     }
-    if (!strcmp(name, "ResetFences")) {
+    if (nameHash == 0x234a880591facce1 /* vkResetFences */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->ResetFences;
     }
-    if (!strcmp(name, "GetFenceStatus")) {
+    if (nameHash == 0xddc1b3a9e007be5a /* vkGetFenceStatus */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->GetFenceStatus;
     }
-    if (!strcmp(name, "WaitForFences")) {
+    if (nameHash == 0x7c1238295eaa98e9 /* vkWaitForFences */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->WaitForFences;
     }
-    if (!strcmp(name, "CreateSemaphore")) {
+    if (nameHash == 0xb23c3f52093e01ee /* vkCreateSemaphore */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateSemaphore;
     }
-    if (!strcmp(name, "DestroySemaphore")) {
+    if (nameHash == 0xa90d9c4553e96cbe /* vkDestroySemaphore */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroySemaphore;
     }
-    if (!strcmp(name, "CreateEvent")) {
+    if (nameHash == 0xfc42afaa1bbc54a8 /* vkCreateEvent */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateEvent;
     }
-    if (!strcmp(name, "DestroyEvent")) {
+    if (nameHash == 0x6400678c24bf7d34 /* vkDestroyEvent */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyEvent;
     }
-    if (!strcmp(name, "GetEventStatus")) {
+    if (nameHash == 0x4e9ad990677f931c /* vkGetEventStatus */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->GetEventStatus;
     }
-    if (!strcmp(name, "SetEvent")) {
+    if (nameHash == 0xd0df5f67ee24e975 /* vkSetEvent */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->SetEvent;
     }
-    if (!strcmp(name, "ResetEvent")) {
+    if (nameHash == 0x2e0b5702efb33535 /* vkResetEvent */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->ResetEvent;
     }
-    if (!strcmp(name, "CreateQueryPool")) {
+    if (nameHash == 0x509b9755d54a9a1e /* vkCreateQueryPool */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateQueryPool;
     }
-    if (!strcmp(name, "DestroyQueryPool")) {
+    if (nameHash == 0x352e0ca38b5e29c0 /* vkDestroyQueryPool */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyQueryPool;
     }
-    if (!strcmp(name, "GetQueryPoolResults")) {
+    if (nameHash == 0x6b902433192f7f5d /* vkGetQueryPoolResults */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->GetQueryPoolResults;
     }
-    if (!strcmp(name, "CreateBuffer")) {
+    if (nameHash == 0x47176b0b432286d1 /* vkCreateBuffer */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateBuffer;
     }
-    if (!strcmp(name, "DestroyBuffer")) {
+    if (nameHash == 0x8ffccda86549f286 /* vkDestroyBuffer */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyBuffer;
     }
-    if (!strcmp(name, "CreateBufferView")) {
+    if (nameHash == 0xf2fafc3e54bde6da /* vkCreateBufferView */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateBufferView;
     }
-    if (!strcmp(name, "DestroyBufferView")) {
+    if (nameHash == 0xf56a44bbdebd81c5 /* vkDestroyBufferView */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyBufferView;
     }
-    if (!strcmp(name, "CreateImage")) {
+    if (nameHash == 0x16a20753b1174318 /* vkCreateImage */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateImage;
     }
-    if (!strcmp(name, "DestroyImage")) {
+    if (nameHash == 0xc7d428e344b14ca8 /* vkDestroyImage */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyImage;
     }
-    if (!strcmp(name, "GetImageSubresourceLayout")) {
+    if (nameHash == 0x23d7885b70c5f681 /* vkGetImageSubresourceLayout */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->GetImageSubresourceLayout;
     }
-    if (!strcmp(name, "CreateImageView")) {
+    if (nameHash == 0xb2f2d8afec7a88a4 /* vkCreateImageView */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateImageView;
     }
-    if (!strcmp(name, "DestroyImageView")) {
+    if (nameHash == 0x76b72b76ccef2958 /* vkDestroyImageView */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyImageView;
     }
-    if (!strcmp(name, "CreateShaderModule")) {
+    if (nameHash == 0xa3fdcfe5e638f01f /* vkCreateShaderModule */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateShaderModule;
     }
-    if (!strcmp(name, "DestroyShaderModule")) {
+    if (nameHash == 0x7cb7f1711b397e5f /* vkDestroyShaderModule */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyShaderModule;
     }
-    if (!strcmp(name, "CreatePipelineCache")) {
+    if (nameHash == 0x6474b3f3a4539ee3 /* vkCreatePipelineCache */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreatePipelineCache;
     }
-    if (!strcmp(name, "DestroyPipelineCache")) {
+    if (nameHash == 0x1ae7324660591b8f /* vkDestroyPipelineCache */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyPipelineCache;
     }
-    if (!strcmp(name, "GetPipelineCacheData")) {
+    if (nameHash == 0x17bb294acabe6a88 /* vkGetPipelineCacheData */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->GetPipelineCacheData;
     }
-    if (!strcmp(name, "MergePipelineCaches")) {
+    if (nameHash == 0xcfbd6aad8345b609 /* vkMergePipelineCaches */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->MergePipelineCaches;
     }
-    if (!strcmp(name, "CreateGraphicsPipelines")) {
+    if (nameHash == 0x5a4a030363a95dd6 /* vkCreateGraphicsPipelines */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateGraphicsPipelines;
     }
-    if (!strcmp(name, "CreateComputePipelines")) {
+    if (nameHash == 0xa8ab2a7a72d37501 /* vkCreateComputePipelines */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateComputePipelines;
     }
-    if (!strcmp(name, "DestroyPipeline")) {
+    if (nameHash == 0xc6158137c93c542a /* vkDestroyPipeline */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyPipeline;
     }
-    if (!strcmp(name, "CreatePipelineLayout")) {
+    if (nameHash == 0x76e7d06d87565b38 /* vkCreatePipelineLayout */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreatePipelineLayout;
     }
-    if (!strcmp(name, "DestroyPipelineLayout")) {
+    if (nameHash == 0x9022d31d32c4a419 /* vkDestroyPipelineLayout */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyPipelineLayout;
     }
-    if (!strcmp(name, "CreateSampler")) {
+    if (nameHash == 0xcce224e583312a27 /* vkCreateSampler */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateSampler;
     }
-    if (!strcmp(name, "DestroySampler")) {
+    if (nameHash == 0x1c9c24ff8ad40bf7 /* vkDestroySampler */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroySampler;
     }
-    if (!strcmp(name, "CreateDescriptorSetLayout")) {
+    if (nameHash == 0xabbbfebcb5e50ddf /* vkCreateDescriptorSetLayout */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateDescriptorSetLayout;
     }
-    if (!strcmp(name, "DestroyDescriptorSetLayout")) {
+    if (nameHash == 0x44fcf619d29aa8fa /* vkDestroyDescriptorSetLayout */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyDescriptorSetLayout;
     }
-    if (!strcmp(name, "CreateDescriptorPool")) {
+    if (nameHash == 0xfa53afc7b202a4cc /* vkCreateDescriptorPool */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateDescriptorPool;
     }
-    if (!strcmp(name, "DestroyDescriptorPool")) {
+    if (nameHash == 0x928a039a45864345 /* vkDestroyDescriptorPool */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyDescriptorPool;
     }
-    if (!strcmp(name, "ResetDescriptorPool")) {
+    if (nameHash == 0xa6007e58158aed7d /* vkResetDescriptorPool */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->ResetDescriptorPool;
     }
-    if (!strcmp(name, "AllocateDescriptorSets")) {
+    if (nameHash == 0x6f91a0562614466e /* vkAllocateDescriptorSets */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->AllocateDescriptorSets;
     }
-    if (!strcmp(name, "FreeDescriptorSets")) {
+    if (nameHash == 0x80bb22834c81711a /* vkFreeDescriptorSets */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->FreeDescriptorSets;
     }
-    if (!strcmp(name, "UpdateDescriptorSets")) {
+    if (nameHash == 0xaac33dd01204ea6d /* vkUpdateDescriptorSets */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->UpdateDescriptorSets;
     }
-    if (!strcmp(name, "CreateFramebuffer")) {
+    if (nameHash == 0x38512bbacb368b24 /* vkCreateFramebuffer */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateFramebuffer;
     }
-    if (!strcmp(name, "DestroyFramebuffer")) {
+    if (nameHash == 0xc0faf7a0688b9961 /* vkDestroyFramebuffer */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyFramebuffer;
     }
-    if (!strcmp(name, "CreateRenderPass")) {
+    if (nameHash == 0x8b778f59be50c419 /* vkCreateRenderPass */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateRenderPass;
     }
-    if (!strcmp(name, "DestroyRenderPass")) {
+    if (nameHash == 0x87a7866d1df23f2b /* vkDestroyRenderPass */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyRenderPass;
     }
-    if (!strcmp(name, "GetRenderAreaGranularity")) {
+    if (nameHash == 0xcfd90dd84e50b6e2 /* vkGetRenderAreaGranularity */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->GetRenderAreaGranularity;
     }
-    if (!strcmp(name, "CreateCommandPool")) {
+    if (nameHash == 0xc7fb7a8e9fc178bf /* vkCreateCommandPool */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CreateCommandPool;
     }
-    if (!strcmp(name, "DestroyCommandPool")) {
+    if (nameHash == 0x8ddf999c6ee753db /* vkDestroyCommandPool */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->DestroyCommandPool;
     }
-    if (!strcmp(name, "ResetCommandPool")) {
+    if (nameHash == 0x1e931402fc057014 /* vkResetCommandPool */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->ResetCommandPool;
     }
-    if (!strcmp(name, "AllocateCommandBuffers")) {
+    if (nameHash == 0x03c070149bc4adcf /* vkAllocateCommandBuffers */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->AllocateCommandBuffers;
     }
-    if (!strcmp(name, "FreeCommandBuffers")) {
+    if (nameHash == 0x7ecb7451a7e045ed /* vkFreeCommandBuffers */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->FreeCommandBuffers;
     }
-    if (!strcmp(name, "BeginCommandBuffer")) {
+    if (nameHash == 0x47d826cf3a236677 /* vkBeginCommandBuffer */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->BeginCommandBuffer;
     }
-    if (!strcmp(name, "EndCommandBuffer")) {
+    if (nameHash == 0x3e52d6e9d1662eb2 /* vkEndCommandBuffer */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->EndCommandBuffer;
     }
-    if (!strcmp(name, "ResetCommandBuffer")) {
+    if (nameHash == 0xc6fee3fca12fb11e /* vkResetCommandBuffer */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->ResetCommandBuffer;
     }
-    if (!strcmp(name, "CmdBindPipeline")) {
+    if (nameHash == 0x093d8596adfdb576 /* vkCmdBindPipeline */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdBindPipeline;
     }
-    if (!strcmp(name, "CmdSetViewport")) {
+    if (nameHash == 0x33f6b7087e67dab4 /* vkCmdSetViewport */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdSetViewport;
     }
-    if (!strcmp(name, "CmdSetScissor")) {
+    if (nameHash == 0xc746d971c6158609 /* vkCmdSetScissor */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdSetScissor;
     }
-    if (!strcmp(name, "CmdSetLineWidth")) {
+    if (nameHash == 0xb7ddef653b0f7932 /* vkCmdSetLineWidth */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdSetLineWidth;
     }
-    if (!strcmp(name, "CmdSetDepthBias")) {
+    if (nameHash == 0x74655211ce6abb4b /* vkCmdSetDepthBias */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdSetDepthBias;
     }
-    if (!strcmp(name, "CmdSetBlendConstants")) {
+    if (nameHash == 0x9b6913d4f956684e /* vkCmdSetBlendConstants */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdSetBlendConstants;
     }
-    if (!strcmp(name, "CmdSetDepthBounds")) {
+    if (nameHash == 0x79cca6cf07ff9d67 /* vkCmdSetDepthBounds */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdSetDepthBounds;
     }
-    if (!strcmp(name, "CmdSetStencilCompareMask")) {
+    if (nameHash == 0x371cc0f681367e4d /* vkCmdSetStencilCompareMask */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdSetStencilCompareMask;
     }
-    if (!strcmp(name, "CmdSetStencilWriteMask")) {
+    if (nameHash == 0x7ce4de962da7bc16 /* vkCmdSetStencilWriteMask */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdSetStencilWriteMask;
     }
-    if (!strcmp(name, "CmdSetStencilReference")) {
+    if (nameHash == 0xf6a1a179eb200ea3 /* vkCmdSetStencilReference */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdSetStencilReference;
     }
-    if (!strcmp(name, "CmdBindDescriptorSets")) {
+    if (nameHash == 0xada92dcad41eaf98 /* vkCmdBindDescriptorSets */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdBindDescriptorSets;
     }
-    if (!strcmp(name, "CmdBindIndexBuffer")) {
+    if (nameHash == 0x668f24a3147926db /* vkCmdBindIndexBuffer */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdBindIndexBuffer;
     }
-    if (!strcmp(name, "CmdBindVertexBuffers")) {
+    if (nameHash == 0x9beb233b5b7ad768 /* vkCmdBindVertexBuffers */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdBindVertexBuffers;
     }
-    if (!strcmp(name, "CmdDraw")) {
+    if (nameHash == 0x6b0e217ae8f0f1ac /* vkCmdDraw */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdDraw;
     }
-    if (!strcmp(name, "CmdDrawIndexed")) {
+    if (nameHash == 0xf9b2570c3144fc75 /* vkCmdDrawIndexed */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdDrawIndexed;
     }
-    if (!strcmp(name, "CmdDrawIndirect")) {
+    if (nameHash == 0xf9cc9eb6cea6c9cb /* vkCmdDrawIndirect */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdDrawIndirect;
     }
-    if (!strcmp(name, "CmdDrawIndexedIndirect")) {
+    if (nameHash == 0x75ffe5f7fd486bdd /* vkCmdDrawIndexedIndirect */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdDrawIndexedIndirect;
     }
-    if (!strcmp(name, "CmdDispatch")) {
+    if (nameHash == 0x9303bbd56b6cd187 /* vkCmdDispatch */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdDispatch;
     }
-    if (!strcmp(name, "CmdDispatchIndirect")) {
+    if (nameHash == 0xdac55f445397e484 /* vkCmdDispatchIndirect */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdDispatchIndirect;
     }
-    if (!strcmp(name, "CmdCopyBuffer")) {
+    if (nameHash == 0x204df3e556149586 /* vkCmdCopyBuffer */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdCopyBuffer;
     }
-    if (!strcmp(name, "CmdCopyImage")) {
+    if (nameHash == 0x438e5b6a754df791 /* vkCmdCopyImage */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdCopyImage;
     }
-    if (!strcmp(name, "CmdBlitImage")) {
+    if (nameHash == 0x38f59a81a499abec /* vkCmdBlitImage */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdBlitImage;
     }
-    if (!strcmp(name, "CmdCopyBufferToImage")) {
+    if (nameHash == 0x4afe44fc10e34214 /* vkCmdCopyBufferToImage */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdCopyBufferToImage;
     }
-    if (!strcmp(name, "CmdCopyImageToBuffer")) {
+    if (nameHash == 0x88c098a6d45aa827 /* vkCmdCopyImageToBuffer */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdCopyImageToBuffer;
     }
-    if (!strcmp(name, "CmdUpdateBuffer")) {
+    if (nameHash == 0xa1e0bb08c1850958 /* vkCmdUpdateBuffer */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdUpdateBuffer;
     }
-    if (!strcmp(name, "CmdFillBuffer")) {
+    if (nameHash == 0x203c934aa0f948fc /* vkCmdFillBuffer */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdFillBuffer;
     }
-    if (!strcmp(name, "CmdClearColorImage")) {
+    if (nameHash == 0x900de63b0b6f0ca2 /* vkCmdClearColorImage */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdClearColorImage;
     }
-    if (!strcmp(name, "CmdClearDepthStencilImage")) {
+    if (nameHash == 0x387f685e13e513fa /* vkCmdClearDepthStencilImage */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdClearDepthStencilImage;
     }
-    if (!strcmp(name, "CmdClearAttachments")) {
+    if (nameHash == 0x484c4c652a1f9c0e /* vkCmdClearAttachments */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdClearAttachments;
     }
-    if (!strcmp(name, "CmdResolveImage")) {
+    if (nameHash == 0x22aa0793e66f037d /* vkCmdResolveImage */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdResolveImage;
     }
-    if (!strcmp(name, "CmdSetEvent")) {
+    if (nameHash == 0x5c738ec563b80923 /* vkCmdSetEvent */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdSetEvent;
     }
-    if (!strcmp(name, "CmdResetEvent")) {
+    if (nameHash == 0x6ac16d77f8579056 /* vkCmdResetEvent */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdResetEvent;
     }
-    if (!strcmp(name, "CmdWaitEvents")) {
+    if (nameHash == 0x1441dbc95c1af085 /* vkCmdWaitEvents */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdWaitEvents;
     }
-    if (!strcmp(name, "CmdPipelineBarrier")) {
+    if (nameHash == 0xb2063ddd597a6ad7 /* vkCmdPipelineBarrier */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdPipelineBarrier;
     }
-    if (!strcmp(name, "CmdBeginQuery")) {
+    if (nameHash == 0x997ea78db49c8c69 /* vkCmdBeginQuery */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdBeginQuery;
     }
-    if (!strcmp(name, "CmdEndQuery")) {
+    if (nameHash == 0x99d50d423e66f60a /* vkCmdEndQuery */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdEndQuery;
     }
-    if (!strcmp(name, "CmdResetQueryPool")) {
+    if (nameHash == 0x1965935ee47e88e6 /* vkCmdResetQueryPool */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdResetQueryPool;
     }
-    if (!strcmp(name, "CmdWriteTimestamp")) {
+    if (nameHash == 0xee397d978e3960d4 /* vkCmdWriteTimestamp */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdWriteTimestamp;
     }
-    if (!strcmp(name, "CmdCopyQueryPoolResults")) {
+    if (nameHash == 0xe133357d099609f5 /* vkCmdCopyQueryPoolResults */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdCopyQueryPoolResults;
     }
-    if (!strcmp(name, "CmdPushConstants")) {
+    if (nameHash == 0xf0bf149eb20282af /* vkCmdPushConstants */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdPushConstants;
     }
-    if (!strcmp(name, "CmdBeginRenderPass")) {
+    if (nameHash == 0xc8c90b647a8c1688 /* vkCmdBeginRenderPass */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdBeginRenderPass;
     }
-    if (!strcmp(name, "CmdNextSubpass")) {
+    if (nameHash == 0xf8a5e079575f045d /* vkCmdNextSubpass */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdNextSubpass;
     }
-    if (!strcmp(name, "CmdEndRenderPass")) {
+    if (nameHash == 0x03e8b953ae4cc537 /* vkCmdEndRenderPass */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdEndRenderPass;
     }
-    if (!strcmp(name, "CmdExecuteCommands")) {
+    if (nameHash == 0x1ce083dfe13eae46 /* vkCmdExecuteCommands */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_0) return NULL;
         return (void *)table->CmdExecuteCommands;
     }
 
     // ---- Core Vulkan 1.1 commands
-    if (!strcmp(name, "BindBufferMemory2")) {
+    if (nameHash == 0x1e001d1f829f257b /* vkBindBufferMemory2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->BindBufferMemory2;
     }
-    if (!strcmp(name, "BindImageMemory2")) {
+    if (nameHash == 0xfd4ef6a737d2546d /* vkBindImageMemory2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->BindImageMemory2;
     }
-    if (!strcmp(name, "GetDeviceGroupPeerMemoryFeatures")) {
+    if (nameHash == 0xaf494d1294356cc7 /* vkGetDeviceGroupPeerMemoryFeatures */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->GetDeviceGroupPeerMemoryFeatures;
     }
-    if (!strcmp(name, "CmdSetDeviceMask")) {
+    if (nameHash == 0x0b635494ffc80076 /* vkCmdSetDeviceMask */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->CmdSetDeviceMask;
     }
-    if (!strcmp(name, "CmdDispatchBase")) {
+    if (nameHash == 0xcff95583fb6ffa3f /* vkCmdDispatchBase */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->CmdDispatchBase;
     }
-    if (!strcmp(name, "GetImageMemoryRequirements2")) {
+    if (nameHash == 0xb69a959653538c19 /* vkGetImageMemoryRequirements2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->GetImageMemoryRequirements2;
     }
-    if (!strcmp(name, "GetBufferMemoryRequirements2")) {
+    if (nameHash == 0x146940f88e38657b /* vkGetBufferMemoryRequirements2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->GetBufferMemoryRequirements2;
     }
-    if (!strcmp(name, "GetImageSparseMemoryRequirements2")) {
+    if (nameHash == 0xa43291af959e4044 /* vkGetImageSparseMemoryRequirements2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->GetImageSparseMemoryRequirements2;
     }
-    if (!strcmp(name, "TrimCommandPool")) {
+    if (nameHash == 0x620e4a899bc7e882 /* vkTrimCommandPool */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->TrimCommandPool;
     }
-    if (!strcmp(name, "GetDeviceQueue2")) {
+    if (nameHash == 0x37cec3d3b8dc3838 /* vkGetDeviceQueue2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->GetDeviceQueue2;
     }
-    if (!strcmp(name, "CreateSamplerYcbcrConversion")) {
+    if (nameHash == 0xa1ba141ce2a9627b /* vkCreateSamplerYcbcrConversion */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->CreateSamplerYcbcrConversion;
     }
-    if (!strcmp(name, "DestroySamplerYcbcrConversion")) {
+    if (nameHash == 0x2c685c0a5e9fbef2 /* vkDestroySamplerYcbcrConversion */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->DestroySamplerYcbcrConversion;
     }
-    if (!strcmp(name, "CreateDescriptorUpdateTemplate")) {
+    if (nameHash == 0xe77fae71b009ad05 /* vkCreateDescriptorUpdateTemplate */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->CreateDescriptorUpdateTemplate;
     }
-    if (!strcmp(name, "DestroyDescriptorUpdateTemplate")) {
+    if (nameHash == 0x410043fbd97c4c0d /* vkDestroyDescriptorUpdateTemplate */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->DestroyDescriptorUpdateTemplate;
     }
-    if (!strcmp(name, "UpdateDescriptorSetWithTemplate")) {
+    if (nameHash == 0x1ebd0c97c69da82b /* vkUpdateDescriptorSetWithTemplate */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->UpdateDescriptorSetWithTemplate;
     }
-    if (!strcmp(name, "GetDescriptorSetLayoutSupport")) {
+    if (nameHash == 0x25f6d470c53abf71 /* vkGetDescriptorSetLayoutSupport */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_1) return NULL;
         return (void *)table->GetDescriptorSetLayoutSupport;
     }
 
     // ---- Core Vulkan 1.2 commands
-    if (!strcmp(name, "CmdDrawIndirectCount")) {
+    if (nameHash == 0x1b435983eb84abaa /* vkCmdDrawIndirectCount */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_2) return NULL;
         return (void *)table->CmdDrawIndirectCount;
     }
-    if (!strcmp(name, "CmdDrawIndexedIndirectCount")) {
+    if (nameHash == 0x1d4114fa0cce1718 /* vkCmdDrawIndexedIndirectCount */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_2) return NULL;
         return (void *)table->CmdDrawIndexedIndirectCount;
     }
-    if (!strcmp(name, "CreateRenderPass2")) {
+    if (nameHash == 0xfd2a746603a13f60 /* vkCreateRenderPass2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_2) return NULL;
         return (void *)table->CreateRenderPass2;
     }
-    if (!strcmp(name, "CmdBeginRenderPass2")) {
+    if (nameHash == 0xf763fd5a051145b3 /* vkCmdBeginRenderPass2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_2) return NULL;
         return (void *)table->CmdBeginRenderPass2;
     }
-    if (!strcmp(name, "CmdNextSubpass2")) {
+    if (nameHash == 0x09d5feddc371e187 /* vkCmdNextSubpass2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_2) return NULL;
         return (void *)table->CmdNextSubpass2;
     }
-    if (!strcmp(name, "CmdEndRenderPass2")) {
+    if (nameHash == 0xd271ad249d3a5d1d /* vkCmdEndRenderPass2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_2) return NULL;
         return (void *)table->CmdEndRenderPass2;
     }
-    if (!strcmp(name, "ResetQueryPool")) {
+    if (nameHash == 0xd34524d6520a5733 /* vkResetQueryPool */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_2) return NULL;
         return (void *)table->ResetQueryPool;
     }
-    if (!strcmp(name, "GetSemaphoreCounterValue")) {
+    if (nameHash == 0xd60ca89f1c84b347 /* vkGetSemaphoreCounterValue */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_2) return NULL;
         return (void *)table->GetSemaphoreCounterValue;
     }
-    if (!strcmp(name, "WaitSemaphores")) {
+    if (nameHash == 0x464cdf5591d873eb /* vkWaitSemaphores */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_2) return NULL;
         return (void *)table->WaitSemaphores;
     }
-    if (!strcmp(name, "SignalSemaphore")) {
+    if (nameHash == 0x6a0ad52ae1fd239d /* vkSignalSemaphore */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_2) return NULL;
         return (void *)table->SignalSemaphore;
     }
-    if (!strcmp(name, "GetBufferDeviceAddress")) {
+    if (nameHash == 0x44fbf4ea4b060b61 /* vkGetBufferDeviceAddress */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_2) return NULL;
         return (void *)table->GetBufferDeviceAddress;
     }
-    if (!strcmp(name, "GetBufferOpaqueCaptureAddress")) {
+    if (nameHash == 0x5639c874fc9132f4 /* vkGetBufferOpaqueCaptureAddress */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_2) return NULL;
         return (void *)table->GetBufferOpaqueCaptureAddress;
     }
-    if (!strcmp(name, "GetDeviceMemoryOpaqueCaptureAddress")) {
+    if (nameHash == 0x9666a70591f64892 /* vkGetDeviceMemoryOpaqueCaptureAddress */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_2) return NULL;
         return (void *)table->GetDeviceMemoryOpaqueCaptureAddress;
     }
 
     // ---- Core Vulkan 1.3 commands
-    if (!strcmp(name, "CreatePrivateDataSlot")) {
+    if (nameHash == 0x126d3121c5d14c5f /* vkCreatePrivateDataSlot */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CreatePrivateDataSlot;
     }
-    if (!strcmp(name, "DestroyPrivateDataSlot")) {
+    if (nameHash == 0xe8fbd5bb4e925208 /* vkDestroyPrivateDataSlot */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->DestroyPrivateDataSlot;
     }
-    if (!strcmp(name, "SetPrivateData")) {
+    if (nameHash == 0x2384403e82f430b9 /* vkSetPrivateData */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->SetPrivateData;
     }
-    if (!strcmp(name, "GetPrivateData")) {
+    if (nameHash == 0xe43a4f01acf5a1b6 /* vkGetPrivateData */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->GetPrivateData;
     }
-    if (!strcmp(name, "CmdSetEvent2")) {
+    if (nameHash == 0x358c26001c7dea62 /* vkCmdSetEvent2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetEvent2;
     }
-    if (!strcmp(name, "CmdResetEvent2")) {
+    if (nameHash == 0x75fdc7101f295d5d /* vkCmdResetEvent2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdResetEvent2;
     }
-    if (!strcmp(name, "CmdWaitEvents2")) {
+    if (nameHash == 0xba764f7da1952e81 /* vkCmdWaitEvents2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdWaitEvents2;
     }
-    if (!strcmp(name, "CmdPipelineBarrier2")) {
+    if (nameHash == 0x5365aba2c3922f6a /* vkCmdPipelineBarrier2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdPipelineBarrier2;
     }
-    if (!strcmp(name, "CmdWriteTimestamp2")) {
+    if (nameHash == 0x6172f26a7ff5e461 /* vkCmdWriteTimestamp2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdWriteTimestamp2;
     }
-    if (!strcmp(name, "QueueSubmit2")) {
+    if (nameHash == 0x60464991fe32093e /* vkQueueSubmit2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->QueueSubmit2;
     }
-    if (!strcmp(name, "CmdCopyBuffer2")) {
+    if (nameHash == 0x6af432892c9a71c2 /* vkCmdCopyBuffer2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdCopyBuffer2;
     }
-    if (!strcmp(name, "CmdCopyImage2")) {
+    if (nameHash == 0xfbe9454065432dfa /* vkCmdCopyImage2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdCopyImage2;
     }
-    if (!strcmp(name, "CmdCopyBufferToImage2")) {
+    if (nameHash == 0xdab35189cc70375d /* vkCmdCopyBufferToImage2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdCopyBufferToImage2;
     }
-    if (!strcmp(name, "CmdCopyImageToBuffer2")) {
+    if (nameHash == 0x07b8ecf11f0a147a /* vkCmdCopyImageToBuffer2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdCopyImageToBuffer2;
     }
-    if (!strcmp(name, "CmdBlitImage2")) {
+    if (nameHash == 0xfb75695f0deb8eb6 /* vkCmdBlitImage2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdBlitImage2;
     }
-    if (!strcmp(name, "CmdResolveImage2")) {
+    if (nameHash == 0x110bf15d39ef5684 /* vkCmdResolveImage2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdResolveImage2;
     }
-    if (!strcmp(name, "CmdBeginRendering")) {
+    if (nameHash == 0x950906daed043635 /* vkCmdBeginRendering */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdBeginRendering;
     }
-    if (!strcmp(name, "CmdEndRendering")) {
+    if (nameHash == 0xc261491c6f3eb73a /* vkCmdEndRendering */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdEndRendering;
     }
-    if (!strcmp(name, "CmdSetCullMode")) {
+    if (nameHash == 0xef3c02c6a6557f67 /* vkCmdSetCullMode */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetCullMode;
     }
-    if (!strcmp(name, "CmdSetFrontFace")) {
+    if (nameHash == 0xb90a1a834aa8c307 /* vkCmdSetFrontFace */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetFrontFace;
     }
-    if (!strcmp(name, "CmdSetPrimitiveTopology")) {
+    if (nameHash == 0xc4a32c157b57c919 /* vkCmdSetPrimitiveTopology */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetPrimitiveTopology;
     }
-    if (!strcmp(name, "CmdSetViewportWithCount")) {
+    if (nameHash == 0x0198a65d97d8c9de /* vkCmdSetViewportWithCount */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetViewportWithCount;
     }
-    if (!strcmp(name, "CmdSetScissorWithCount")) {
+    if (nameHash == 0xb9dc146482b98eab /* vkCmdSetScissorWithCount */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetScissorWithCount;
     }
-    if (!strcmp(name, "CmdBindVertexBuffers2")) {
+    if (nameHash == 0xf5dd10901cd99b7e /* vkCmdBindVertexBuffers2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdBindVertexBuffers2;
     }
-    if (!strcmp(name, "CmdSetDepthTestEnable")) {
+    if (nameHash == 0xefff832805016a4e /* vkCmdSetDepthTestEnable */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetDepthTestEnable;
     }
-    if (!strcmp(name, "CmdSetDepthWriteEnable")) {
+    if (nameHash == 0xa52ec7d995ba8bd0 /* vkCmdSetDepthWriteEnable */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetDepthWriteEnable;
     }
-    if (!strcmp(name, "CmdSetDepthCompareOp")) {
+    if (nameHash == 0x97fb69a7181762a0 /* vkCmdSetDepthCompareOp */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetDepthCompareOp;
     }
-    if (!strcmp(name, "CmdSetDepthBoundsTestEnable")) {
+    if (nameHash == 0xc282ec2fb0ff4a7f /* vkCmdSetDepthBoundsTestEnable */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetDepthBoundsTestEnable;
     }
-    if (!strcmp(name, "CmdSetStencilTestEnable")) {
+    if (nameHash == 0x7d12fe073f7c9462 /* vkCmdSetStencilTestEnable */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetStencilTestEnable;
     }
-    if (!strcmp(name, "CmdSetStencilOp")) {
+    if (nameHash == 0x1ce7a67a576268eb /* vkCmdSetStencilOp */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetStencilOp;
     }
-    if (!strcmp(name, "CmdSetRasterizerDiscardEnable")) {
+    if (nameHash == 0x5ee0b29b506c2241 /* vkCmdSetRasterizerDiscardEnable */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetRasterizerDiscardEnable;
     }
-    if (!strcmp(name, "CmdSetDepthBiasEnable")) {
+    if (nameHash == 0x1de7b0458bd04513 /* vkCmdSetDepthBiasEnable */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetDepthBiasEnable;
     }
-    if (!strcmp(name, "CmdSetPrimitiveRestartEnable")) {
+    if (nameHash == 0x5a7b2addceb670c9 /* vkCmdSetPrimitiveRestartEnable */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->CmdSetPrimitiveRestartEnable;
     }
-    if (!strcmp(name, "GetDeviceBufferMemoryRequirements")) {
+    if (nameHash == 0x15aae27a7223ea5e /* vkGetDeviceBufferMemoryRequirements */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->GetDeviceBufferMemoryRequirements;
     }
-    if (!strcmp(name, "GetDeviceImageMemoryRequirements")) {
+    if (nameHash == 0x3f4274cc71793a20 /* vkGetDeviceImageMemoryRequirements */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->GetDeviceImageMemoryRequirements;
     }
-    if (!strcmp(name, "GetDeviceImageSparseMemoryRequirements")) {
+    if (nameHash == 0x987ef1c05cbaa5d8 /* vkGetDeviceImageSparseMemoryRequirements */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_3) return NULL;
         return (void *)table->GetDeviceImageSparseMemoryRequirements;
     }
 
     // ---- Core Vulkan 1.4 commands
-    if (!strcmp(name, "CmdSetLineStipple")) {
+    if (nameHash == 0xf738ab31f5c4808a /* vkCmdSetLineStipple */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->CmdSetLineStipple;
     }
-    if (!strcmp(name, "MapMemory2")) {
+    if (nameHash == 0xaf2b917e19ff90c6 /* vkMapMemory2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->MapMemory2;
     }
-    if (!strcmp(name, "UnmapMemory2")) {
+    if (nameHash == 0xd75ed866d33442a9 /* vkUnmapMemory2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->UnmapMemory2;
     }
-    if (!strcmp(name, "CmdBindIndexBuffer2")) {
+    if (nameHash == 0x540370e7058dd6ac /* vkCmdBindIndexBuffer2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->CmdBindIndexBuffer2;
     }
-    if (!strcmp(name, "GetRenderingAreaGranularity")) {
+    if (nameHash == 0xf7190fead13f236c /* vkGetRenderingAreaGranularity */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->GetRenderingAreaGranularity;
     }
-    if (!strcmp(name, "GetDeviceImageSubresourceLayout")) {
+    if (nameHash == 0xe47d87648c47352c /* vkGetDeviceImageSubresourceLayout */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->GetDeviceImageSubresourceLayout;
     }
-    if (!strcmp(name, "GetImageSubresourceLayout2")) {
+    if (nameHash == 0x656d8617bf4a33fc /* vkGetImageSubresourceLayout2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->GetImageSubresourceLayout2;
     }
-    if (!strcmp(name, "CmdPushDescriptorSet")) {
+    if (nameHash == 0xf0560464399d1a5d /* vkCmdPushDescriptorSet */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->CmdPushDescriptorSet;
     }
-    if (!strcmp(name, "CmdPushDescriptorSetWithTemplate")) {
+    if (nameHash == 0x6cd2fae1ab9c9a75 /* vkCmdPushDescriptorSetWithTemplate */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->CmdPushDescriptorSetWithTemplate;
     }
-    if (!strcmp(name, "CmdSetRenderingAttachmentLocations")) {
+    if (nameHash == 0x3a28620bd767d9f5 /* vkCmdSetRenderingAttachmentLocations */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->CmdSetRenderingAttachmentLocations;
     }
-    if (!strcmp(name, "CmdSetRenderingInputAttachmentIndices")) {
+    if (nameHash == 0xc3b0dc0e29037a73 /* vkCmdSetRenderingInputAttachmentIndices */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->CmdSetRenderingInputAttachmentIndices;
     }
-    if (!strcmp(name, "CmdBindDescriptorSets2")) {
+    if (nameHash == 0x1d81583e5255fa64 /* vkCmdBindDescriptorSets2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->CmdBindDescriptorSets2;
     }
-    if (!strcmp(name, "CmdPushConstants2")) {
+    if (nameHash == 0x7b5bca3ce9a7ccca /* vkCmdPushConstants2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->CmdPushConstants2;
     }
-    if (!strcmp(name, "CmdPushDescriptorSet2")) {
+    if (nameHash == 0x4c2e756549427154 /* vkCmdPushDescriptorSet2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->CmdPushDescriptorSet2;
     }
-    if (!strcmp(name, "CmdPushDescriptorSetWithTemplate2")) {
+    if (nameHash == 0x333e4270d99c5326 /* vkCmdPushDescriptorSetWithTemplate2 */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->CmdPushDescriptorSetWithTemplate2;
     }
-    if (!strcmp(name, "CopyMemoryToImage")) {
+    if (nameHash == 0x6333940945f764eb /* vkCopyMemoryToImage */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->CopyMemoryToImage;
     }
-    if (!strcmp(name, "CopyImageToMemory")) {
+    if (nameHash == 0x25cbce2cf01ae221 /* vkCopyImageToMemory */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->CopyImageToMemory;
     }
-    if (!strcmp(name, "CopyImageToImage")) {
+    if (nameHash == 0xa0e05031ca80b190 /* vkCopyImageToImage */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->CopyImageToImage;
     }
-    if (!strcmp(name, "TransitionImageLayout")) {
+    if (nameHash == 0x34455b16a968d1f7 /* vkTransitionImageLayout */) {
         if (dev->should_ignore_device_commands_from_newer_version && api_version < VK_API_VERSION_1_4) return NULL;
         return (void *)table->TransitionImageLayout;
     }
 
     // ---- VK_KHR_swapchain extension commands
-    if (!strcmp(name, "CreateSwapchainKHR")) return (void *)table->CreateSwapchainKHR;
-    if (!strcmp(name, "DestroySwapchainKHR")) return (void *)table->DestroySwapchainKHR;
-    if (!strcmp(name, "GetSwapchainImagesKHR")) return (void *)table->GetSwapchainImagesKHR;
-    if (!strcmp(name, "AcquireNextImageKHR")) return (void *)table->AcquireNextImageKHR;
-    if (!strcmp(name, "QueuePresentKHR")) return (void *)table->QueuePresentKHR;
-    if (!strcmp(name, "GetDeviceGroupPresentCapabilitiesKHR")) return (void *)table->GetDeviceGroupPresentCapabilitiesKHR;
-    if (!strcmp(name, "GetDeviceGroupSurfacePresentModesKHR")) return (void *)table->GetDeviceGroupSurfacePresentModesKHR;
-    if (!strcmp(name, "AcquireNextImage2KHR")) return (void *)table->AcquireNextImage2KHR;
+    if (nameHash == 0x536ddebd6b81d90a /* vkCreateSwapchainKHR */) return (void *)table->CreateSwapchainKHR;
+    if (nameHash == 0x22466386cc1398b8 /* vkDestroySwapchainKHR */) return (void *)table->DestroySwapchainKHR;
+    if (nameHash == 0xe3e71921cd13bc5f /* vkGetSwapchainImagesKHR */) return (void *)table->GetSwapchainImagesKHR;
+    if (nameHash == 0x8db47b7cc78dbf21 /* vkAcquireNextImageKHR */) return (void *)table->AcquireNextImageKHR;
+    if (nameHash == 0x003f01982149c676 /* vkQueuePresentKHR */) return (void *)table->QueuePresentKHR;
+    if (nameHash == 0xd537fdf3c85210f2 /* vkGetDeviceGroupPresentCapabilitiesKHR */) return (void *)table->GetDeviceGroupPresentCapabilitiesKHR;
+    if (nameHash == 0x32e6d8b01681a0b2 /* vkGetDeviceGroupSurfacePresentModesKHR */) return (void *)table->GetDeviceGroupSurfacePresentModesKHR;
+    if (nameHash == 0x81f991d1ab0bc5ce /* vkAcquireNextImage2KHR */) return (void *)table->AcquireNextImage2KHR;
 
     // ---- VK_KHR_display_swapchain extension commands
-    if (!strcmp(name, "CreateSharedSwapchainsKHR")) return (void *)table->CreateSharedSwapchainsKHR;
+    if (nameHash == 0x73239ae79c84cd85 /* vkCreateSharedSwapchainsKHR */) return (void *)table->CreateSharedSwapchainsKHR;
 
     // ---- VK_KHR_video_queue extension commands
-    if (!strcmp(name, "CreateVideoSessionKHR")) return (void *)table->CreateVideoSessionKHR;
-    if (!strcmp(name, "DestroyVideoSessionKHR")) return (void *)table->DestroyVideoSessionKHR;
-    if (!strcmp(name, "GetVideoSessionMemoryRequirementsKHR")) return (void *)table->GetVideoSessionMemoryRequirementsKHR;
-    if (!strcmp(name, "BindVideoSessionMemoryKHR")) return (void *)table->BindVideoSessionMemoryKHR;
-    if (!strcmp(name, "CreateVideoSessionParametersKHR")) return (void *)table->CreateVideoSessionParametersKHR;
-    if (!strcmp(name, "UpdateVideoSessionParametersKHR")) return (void *)table->UpdateVideoSessionParametersKHR;
-    if (!strcmp(name, "DestroyVideoSessionParametersKHR")) return (void *)table->DestroyVideoSessionParametersKHR;
-    if (!strcmp(name, "CmdBeginVideoCodingKHR")) return (void *)table->CmdBeginVideoCodingKHR;
-    if (!strcmp(name, "CmdEndVideoCodingKHR")) return (void *)table->CmdEndVideoCodingKHR;
-    if (!strcmp(name, "CmdControlVideoCodingKHR")) return (void *)table->CmdControlVideoCodingKHR;
+    if (nameHash == 0xf8d70781ac92a1cf /* vkCreateVideoSessionKHR */) return (void *)table->CreateVideoSessionKHR;
+    if (nameHash == 0x4bfeea912504df47 /* vkDestroyVideoSessionKHR */) return (void *)table->DestroyVideoSessionKHR;
+    if (nameHash == 0x34c3a6eee5758a70 /* vkGetVideoSessionMemoryRequirementsKHR */) return (void *)table->GetVideoSessionMemoryRequirementsKHR;
+    if (nameHash == 0x95fd48feaefe8c46 /* vkBindVideoSessionMemoryKHR */) return (void *)table->BindVideoSessionMemoryKHR;
+    if (nameHash == 0xe89bda66824b7d7d /* vkCreateVideoSessionParametersKHR */) return (void *)table->CreateVideoSessionParametersKHR;
+    if (nameHash == 0x0baf9d7df0a788b5 /* vkUpdateVideoSessionParametersKHR */) return (void *)table->UpdateVideoSessionParametersKHR;
+    if (nameHash == 0x996b8928f4147a24 /* vkDestroyVideoSessionParametersKHR */) return (void *)table->DestroyVideoSessionParametersKHR;
+    if (nameHash == 0xcfa13bad1a984ba3 /* vkCmdBeginVideoCodingKHR */) return (void *)table->CmdBeginVideoCodingKHR;
+    if (nameHash == 0xf5243f8ebe970031 /* vkCmdEndVideoCodingKHR */) return (void *)table->CmdEndVideoCodingKHR;
+    if (nameHash == 0x355f705d4d835c02 /* vkCmdControlVideoCodingKHR */) return (void *)table->CmdControlVideoCodingKHR;
 
     // ---- VK_KHR_video_decode_queue extension commands
-    if (!strcmp(name, "CmdDecodeVideoKHR")) return (void *)table->CmdDecodeVideoKHR;
+    if (nameHash == 0xa5bd2226d386dd02 /* vkCmdDecodeVideoKHR */) return (void *)table->CmdDecodeVideoKHR;
 
     // ---- VK_KHR_dynamic_rendering extension commands
-    if (!strcmp(name, "CmdBeginRenderingKHR")) return (void *)table->CmdBeginRenderingKHR;
-    if (!strcmp(name, "CmdEndRenderingKHR")) return (void *)table->CmdEndRenderingKHR;
+    if (nameHash == 0xf525fcfca497ad4d /* vkCmdBeginRenderingKHR */) return (void *)table->CmdBeginRenderingKHR;
+    if (nameHash == 0x20a57b855bed16ad /* vkCmdEndRenderingKHR */) return (void *)table->CmdEndRenderingKHR;
 
     // ---- VK_KHR_device_group extension commands
-    if (!strcmp(name, "GetDeviceGroupPeerMemoryFeaturesKHR")) return (void *)table->GetDeviceGroupPeerMemoryFeaturesKHR;
-    if (!strcmp(name, "CmdSetDeviceMaskKHR")) return (void *)table->CmdSetDeviceMaskKHR;
-    if (!strcmp(name, "CmdDispatchBaseKHR")) return (void *)table->CmdDispatchBaseKHR;
+    if (nameHash == 0xe62b971ae0a68532 /* vkGetDeviceGroupPeerMemoryFeaturesKHR */) return (void *)table->GetDeviceGroupPeerMemoryFeaturesKHR;
+    if (nameHash == 0x6a987f9eb7d4a557 /* vkCmdSetDeviceMaskKHR */) return (void *)table->CmdSetDeviceMaskKHR;
+    if (nameHash == 0x315127945d495884 /* vkCmdDispatchBaseKHR */) return (void *)table->CmdDispatchBaseKHR;
 
     // ---- VK_KHR_maintenance1 extension commands
-    if (!strcmp(name, "TrimCommandPoolKHR")) return (void *)table->TrimCommandPoolKHR;
+    if (nameHash == 0x73f1f198f822a45e /* vkTrimCommandPoolKHR */) return (void *)table->TrimCommandPoolKHR;
 
     // ---- VK_KHR_external_memory_win32 extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "GetMemoryWin32HandleKHR")) return (void *)table->GetMemoryWin32HandleKHR;
+    if (nameHash == 0xcda4a94d2c8596f7 /* vkGetMemoryWin32HandleKHR */) return (void *)table->GetMemoryWin32HandleKHR;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "GetMemoryWin32HandlePropertiesKHR")) return (void *)table->GetMemoryWin32HandlePropertiesKHR;
+    if (nameHash == 0xce5d77a823daf981 /* vkGetMemoryWin32HandlePropertiesKHR */) return (void *)table->GetMemoryWin32HandlePropertiesKHR;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_KHR_external_memory_fd extension commands
-    if (!strcmp(name, "GetMemoryFdKHR")) return (void *)table->GetMemoryFdKHR;
-    if (!strcmp(name, "GetMemoryFdPropertiesKHR")) return (void *)table->GetMemoryFdPropertiesKHR;
+    if (nameHash == 0x2ed749f13375a993 /* vkGetMemoryFdKHR */) return (void *)table->GetMemoryFdKHR;
+    if (nameHash == 0x12e6b027ea2149c2 /* vkGetMemoryFdPropertiesKHR */) return (void *)table->GetMemoryFdPropertiesKHR;
 
     // ---- VK_KHR_external_semaphore_win32 extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "ImportSemaphoreWin32HandleKHR")) return (void *)table->ImportSemaphoreWin32HandleKHR;
+    if (nameHash == 0xe66bc79887578e01 /* vkImportSemaphoreWin32HandleKHR */) return (void *)table->ImportSemaphoreWin32HandleKHR;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "GetSemaphoreWin32HandleKHR")) return (void *)table->GetSemaphoreWin32HandleKHR;
+    if (nameHash == 0xe7cfb8155a9ec7f4 /* vkGetSemaphoreWin32HandleKHR */) return (void *)table->GetSemaphoreWin32HandleKHR;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_KHR_external_semaphore_fd extension commands
-    if (!strcmp(name, "ImportSemaphoreFdKHR")) return (void *)table->ImportSemaphoreFdKHR;
-    if (!strcmp(name, "GetSemaphoreFdKHR")) return (void *)table->GetSemaphoreFdKHR;
+    if (nameHash == 0xebc09d555d9390f1 /* vkImportSemaphoreFdKHR */) return (void *)table->ImportSemaphoreFdKHR;
+    if (nameHash == 0x140ab11fc9190c09 /* vkGetSemaphoreFdKHR */) return (void *)table->GetSemaphoreFdKHR;
 
     // ---- VK_KHR_push_descriptor extension commands
-    if (!strcmp(name, "CmdPushDescriptorSetKHR")) return (void *)table->CmdPushDescriptorSetKHR;
-    if (!strcmp(name, "CmdPushDescriptorSetWithTemplateKHR")) return (void *)table->CmdPushDescriptorSetWithTemplateKHR;
+    if (nameHash == 0x2123cc5e1c438312 /* vkCmdPushDescriptorSetKHR */) return (void *)table->CmdPushDescriptorSetKHR;
+    if (nameHash == 0xc0e77996431e14e7 /* vkCmdPushDescriptorSetWithTemplateKHR */) return (void *)table->CmdPushDescriptorSetWithTemplateKHR;
 
     // ---- VK_KHR_descriptor_update_template extension commands
-    if (!strcmp(name, "CreateDescriptorUpdateTemplateKHR")) return (void *)table->CreateDescriptorUpdateTemplateKHR;
-    if (!strcmp(name, "DestroyDescriptorUpdateTemplateKHR")) return (void *)table->DestroyDescriptorUpdateTemplateKHR;
-    if (!strcmp(name, "UpdateDescriptorSetWithTemplateKHR")) return (void *)table->UpdateDescriptorSetWithTemplateKHR;
+    if (nameHash == 0xae196725993a5773 /* vkCreateDescriptorUpdateTemplateKHR */) return (void *)table->CreateDescriptorUpdateTemplateKHR;
+    if (nameHash == 0x36da6959c46b24dd /* vkDestroyDescriptorUpdateTemplateKHR */) return (void *)table->DestroyDescriptorUpdateTemplateKHR;
+    if (nameHash == 0x71b8cb2fd8159c3d /* vkUpdateDescriptorSetWithTemplateKHR */) return (void *)table->UpdateDescriptorSetWithTemplateKHR;
 
     // ---- VK_KHR_create_renderpass2 extension commands
-    if (!strcmp(name, "CreateRenderPass2KHR")) return (void *)table->CreateRenderPass2KHR;
-    if (!strcmp(name, "CmdBeginRenderPass2KHR")) return (void *)table->CmdBeginRenderPass2KHR;
-    if (!strcmp(name, "CmdNextSubpass2KHR")) return (void *)table->CmdNextSubpass2KHR;
-    if (!strcmp(name, "CmdEndRenderPass2KHR")) return (void *)table->CmdEndRenderPass2KHR;
+    if (nameHash == 0x7282c5dadf99206c /* vkCreateRenderPass2KHR */) return (void *)table->CreateRenderPass2KHR;
+    if (nameHash == 0x953dd320a2f19033 /* vkCmdBeginRenderPass2KHR */) return (void *)table->CmdBeginRenderPass2KHR;
+    if (nameHash == 0x599380d76631dbc9 /* vkCmdNextSubpass2KHR */) return (void *)table->CmdNextSubpass2KHR;
+    if (nameHash == 0xcf86c42d2695983a /* vkCmdEndRenderPass2KHR */) return (void *)table->CmdEndRenderPass2KHR;
 
     // ---- VK_KHR_shared_presentable_image extension commands
-    if (!strcmp(name, "GetSwapchainStatusKHR")) return (void *)table->GetSwapchainStatusKHR;
+    if (nameHash == 0x5df941fbd5ee53ed /* vkGetSwapchainStatusKHR */) return (void *)table->GetSwapchainStatusKHR;
 
     // ---- VK_KHR_external_fence_win32 extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "ImportFenceWin32HandleKHR")) return (void *)table->ImportFenceWin32HandleKHR;
+    if (nameHash == 0x8aa9a6ca90bcc785 /* vkImportFenceWin32HandleKHR */) return (void *)table->ImportFenceWin32HandleKHR;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "GetFenceWin32HandleKHR")) return (void *)table->GetFenceWin32HandleKHR;
+    if (nameHash == 0xd70928b0b99ddf51 /* vkGetFenceWin32HandleKHR */) return (void *)table->GetFenceWin32HandleKHR;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_KHR_external_fence_fd extension commands
-    if (!strcmp(name, "ImportFenceFdKHR")) return (void *)table->ImportFenceFdKHR;
-    if (!strcmp(name, "GetFenceFdKHR")) return (void *)table->GetFenceFdKHR;
+    if (nameHash == 0xe753bab9908ecda8 /* vkImportFenceFdKHR */) return (void *)table->ImportFenceFdKHR;
+    if (nameHash == 0x7f028870dfbbd7cd /* vkGetFenceFdKHR */) return (void *)table->GetFenceFdKHR;
 
     // ---- VK_KHR_performance_query extension commands
-    if (!strcmp(name, "AcquireProfilingLockKHR")) return (void *)table->AcquireProfilingLockKHR;
-    if (!strcmp(name, "ReleaseProfilingLockKHR")) return (void *)table->ReleaseProfilingLockKHR;
+    if (nameHash == 0xaa4956312cfc8f69 /* vkAcquireProfilingLockKHR */) return (void *)table->AcquireProfilingLockKHR;
+    if (nameHash == 0x0a9e4edad7617bf4 /* vkReleaseProfilingLockKHR */) return (void *)table->ReleaseProfilingLockKHR;
 
     // ---- VK_KHR_get_memory_requirements2 extension commands
-    if (!strcmp(name, "GetImageMemoryRequirements2KHR")) return (void *)table->GetImageMemoryRequirements2KHR;
-    if (!strcmp(name, "GetBufferMemoryRequirements2KHR")) return (void *)table->GetBufferMemoryRequirements2KHR;
-    if (!strcmp(name, "GetImageSparseMemoryRequirements2KHR")) return (void *)table->GetImageSparseMemoryRequirements2KHR;
+    if (nameHash == 0x3e094de8a08c3145 /* vkGetImageMemoryRequirements2KHR */) return (void *)table->GetImageMemoryRequirements2KHR;
+    if (nameHash == 0x77ac813268762693 /* vkGetBufferMemoryRequirements2KHR */) return (void *)table->GetBufferMemoryRequirements2KHR;
+    if (nameHash == 0x9cc130ca400434b7 /* vkGetImageSparseMemoryRequirements2KHR */) return (void *)table->GetImageSparseMemoryRequirements2KHR;
 
     // ---- VK_KHR_sampler_ycbcr_conversion extension commands
-    if (!strcmp(name, "CreateSamplerYcbcrConversionKHR")) return (void *)table->CreateSamplerYcbcrConversionKHR;
-    if (!strcmp(name, "DestroySamplerYcbcrConversionKHR")) return (void *)table->DestroySamplerYcbcrConversionKHR;
+    if (nameHash == 0xbaa71789dfb073b1 /* vkCreateSamplerYcbcrConversionKHR */) return (void *)table->CreateSamplerYcbcrConversionKHR;
+    if (nameHash == 0xb7d326eaca38da93 /* vkDestroySamplerYcbcrConversionKHR */) return (void *)table->DestroySamplerYcbcrConversionKHR;
 
     // ---- VK_KHR_bind_memory2 extension commands
-    if (!strcmp(name, "BindBufferMemory2KHR")) return (void *)table->BindBufferMemory2KHR;
-    if (!strcmp(name, "BindImageMemory2KHR")) return (void *)table->BindImageMemory2KHR;
+    if (nameHash == 0xc20b7cd3cdb4895d /* vkBindBufferMemory2KHR */) return (void *)table->BindBufferMemory2KHR;
+    if (nameHash == 0xa17b9f5a286650f5 /* vkBindImageMemory2KHR */) return (void *)table->BindImageMemory2KHR;
 
     // ---- VK_KHR_maintenance3 extension commands
-    if (!strcmp(name, "GetDescriptorSetLayoutSupportKHR")) return (void *)table->GetDescriptorSetLayoutSupportKHR;
+    if (nameHash == 0x0f7af59845222e9d /* vkGetDescriptorSetLayoutSupportKHR */) return (void *)table->GetDescriptorSetLayoutSupportKHR;
 
     // ---- VK_KHR_draw_indirect_count extension commands
-    if (!strcmp(name, "CmdDrawIndirectCountKHR")) return (void *)table->CmdDrawIndirectCountKHR;
-    if (!strcmp(name, "CmdDrawIndexedIndirectCountKHR")) return (void *)table->CmdDrawIndexedIndirectCountKHR;
+    if (nameHash == 0xd2ada1f0fce0ebc9 /* vkCmdDrawIndirectCountKHR */) return (void *)table->CmdDrawIndirectCountKHR;
+    if (nameHash == 0xa343558c3889eb3b /* vkCmdDrawIndexedIndirectCountKHR */) return (void *)table->CmdDrawIndexedIndirectCountKHR;
 
     // ---- VK_KHR_timeline_semaphore extension commands
-    if (!strcmp(name, "GetSemaphoreCounterValueKHR")) return (void *)table->GetSemaphoreCounterValueKHR;
-    if (!strcmp(name, "WaitSemaphoresKHR")) return (void *)table->WaitSemaphoresKHR;
-    if (!strcmp(name, "SignalSemaphoreKHR")) return (void *)table->SignalSemaphoreKHR;
+    if (nameHash == 0x4f323238bf52cee6 /* vkGetSemaphoreCounterValueKHR */) return (void *)table->GetSemaphoreCounterValueKHR;
+    if (nameHash == 0x90b98ea73daf2fc7 /* vkWaitSemaphoresKHR */) return (void *)table->WaitSemaphoresKHR;
+    if (nameHash == 0xb8f7f65305fa9c04 /* vkSignalSemaphoreKHR */) return (void *)table->SignalSemaphoreKHR;
 
     // ---- VK_KHR_fragment_shading_rate extension commands
-    if (!strcmp(name, "CmdSetFragmentShadingRateKHR")) return (void *)table->CmdSetFragmentShadingRateKHR;
+    if (nameHash == 0x8ed6523506902ceb /* vkCmdSetFragmentShadingRateKHR */) return (void *)table->CmdSetFragmentShadingRateKHR;
 
     // ---- VK_KHR_dynamic_rendering_local_read extension commands
-    if (!strcmp(name, "CmdSetRenderingAttachmentLocationsKHR")) return (void *)table->CmdSetRenderingAttachmentLocationsKHR;
-    if (!strcmp(name, "CmdSetRenderingInputAttachmentIndicesKHR")) return (void *)table->CmdSetRenderingInputAttachmentIndicesKHR;
+    if (nameHash == 0xabb4da3669fa0607 /* vkCmdSetRenderingAttachmentLocationsKHR */) return (void *)table->CmdSetRenderingAttachmentLocationsKHR;
+    if (nameHash == 0x8284d04d0f439b7f /* vkCmdSetRenderingInputAttachmentIndicesKHR */) return (void *)table->CmdSetRenderingInputAttachmentIndicesKHR;
 
     // ---- VK_KHR_present_wait extension commands
-    if (!strcmp(name, "WaitForPresentKHR")) return (void *)table->WaitForPresentKHR;
+    if (nameHash == 0x958f70568135c547 /* vkWaitForPresentKHR */) return (void *)table->WaitForPresentKHR;
 
     // ---- VK_KHR_buffer_device_address extension commands
-    if (!strcmp(name, "GetBufferDeviceAddressKHR")) return (void *)table->GetBufferDeviceAddressKHR;
-    if (!strcmp(name, "GetBufferOpaqueCaptureAddressKHR")) return (void *)table->GetBufferOpaqueCaptureAddressKHR;
-    if (!strcmp(name, "GetDeviceMemoryOpaqueCaptureAddressKHR")) return (void *)table->GetDeviceMemoryOpaqueCaptureAddressKHR;
+    if (nameHash == 0x62692fbaea06e05d /* vkGetBufferDeviceAddressKHR */) return (void *)table->GetBufferDeviceAddressKHR;
+    if (nameHash == 0x5de8076ffb7af976 /* vkGetBufferOpaqueCaptureAddressKHR */) return (void *)table->GetBufferOpaqueCaptureAddressKHR;
+    if (nameHash == 0x316bebcfe32855b8 /* vkGetDeviceMemoryOpaqueCaptureAddressKHR */) return (void *)table->GetDeviceMemoryOpaqueCaptureAddressKHR;
 
     // ---- VK_KHR_deferred_host_operations extension commands
-    if (!strcmp(name, "CreateDeferredOperationKHR")) return (void *)table->CreateDeferredOperationKHR;
-    if (!strcmp(name, "DestroyDeferredOperationKHR")) return (void *)table->DestroyDeferredOperationKHR;
-    if (!strcmp(name, "GetDeferredOperationMaxConcurrencyKHR")) return (void *)table->GetDeferredOperationMaxConcurrencyKHR;
-    if (!strcmp(name, "GetDeferredOperationResultKHR")) return (void *)table->GetDeferredOperationResultKHR;
-    if (!strcmp(name, "DeferredOperationJoinKHR")) return (void *)table->DeferredOperationJoinKHR;
+    if (nameHash == 0xc53d00dd120cc028 /* vkCreateDeferredOperationKHR */) return (void *)table->CreateDeferredOperationKHR;
+    if (nameHash == 0x71bb8068c1edf85e /* vkDestroyDeferredOperationKHR */) return (void *)table->DestroyDeferredOperationKHR;
+    if (nameHash == 0xe8ddcebfb8abfe62 /* vkGetDeferredOperationMaxConcurrencyKHR */) return (void *)table->GetDeferredOperationMaxConcurrencyKHR;
+    if (nameHash == 0xf325f660479c7872 /* vkGetDeferredOperationResultKHR */) return (void *)table->GetDeferredOperationResultKHR;
+    if (nameHash == 0x7379abd10f3bfb5d /* vkDeferredOperationJoinKHR */) return (void *)table->DeferredOperationJoinKHR;
 
     // ---- VK_KHR_pipeline_executable_properties extension commands
-    if (!strcmp(name, "GetPipelineExecutablePropertiesKHR")) return (void *)table->GetPipelineExecutablePropertiesKHR;
-    if (!strcmp(name, "GetPipelineExecutableStatisticsKHR")) return (void *)table->GetPipelineExecutableStatisticsKHR;
-    if (!strcmp(name, "GetPipelineExecutableInternalRepresentationsKHR")) return (void *)table->GetPipelineExecutableInternalRepresentationsKHR;
+    if (nameHash == 0xf8010e878fa40163 /* vkGetPipelineExecutablePropertiesKHR */) return (void *)table->GetPipelineExecutablePropertiesKHR;
+    if (nameHash == 0x5001dcd798e4f3a8 /* vkGetPipelineExecutableStatisticsKHR */) return (void *)table->GetPipelineExecutableStatisticsKHR;
+    if (nameHash == 0x482cb3433b920f78 /* vkGetPipelineExecutableInternalRepresentationsKHR */) return (void *)table->GetPipelineExecutableInternalRepresentationsKHR;
 
     // ---- VK_KHR_map_memory2 extension commands
-    if (!strcmp(name, "MapMemory2KHR")) return (void *)table->MapMemory2KHR;
-    if (!strcmp(name, "UnmapMemory2KHR")) return (void *)table->UnmapMemory2KHR;
+    if (nameHash == 0x34bfbbd6c34bac46 /* vkMapMemory2KHR */) return (void *)table->MapMemory2KHR;
+    if (nameHash == 0x345a6d44742dd550 /* vkUnmapMemory2KHR */) return (void *)table->UnmapMemory2KHR;
 
     // ---- VK_KHR_video_encode_queue extension commands
-    if (!strcmp(name, "GetEncodedVideoSessionParametersKHR")) return (void *)table->GetEncodedVideoSessionParametersKHR;
-    if (!strcmp(name, "CmdEncodeVideoKHR")) return (void *)table->CmdEncodeVideoKHR;
+    if (nameHash == 0xd620ed53628cc23d /* vkGetEncodedVideoSessionParametersKHR */) return (void *)table->GetEncodedVideoSessionParametersKHR;
+    if (nameHash == 0x68a8fbded268189e /* vkCmdEncodeVideoKHR */) return (void *)table->CmdEncodeVideoKHR;
 
     // ---- VK_KHR_synchronization2 extension commands
-    if (!strcmp(name, "CmdSetEvent2KHR")) return (void *)table->CmdSetEvent2KHR;
-    if (!strcmp(name, "CmdResetEvent2KHR")) return (void *)table->CmdResetEvent2KHR;
-    if (!strcmp(name, "CmdWaitEvents2KHR")) return (void *)table->CmdWaitEvents2KHR;
-    if (!strcmp(name, "CmdPipelineBarrier2KHR")) return (void *)table->CmdPipelineBarrier2KHR;
-    if (!strcmp(name, "CmdWriteTimestamp2KHR")) return (void *)table->CmdWriteTimestamp2KHR;
-    if (!strcmp(name, "QueueSubmit2KHR")) return (void *)table->QueueSubmit2KHR;
+    if (nameHash == 0x81a460bb5df2fb6c /* vkCmdSetEvent2KHR */) return (void *)table->CmdSetEvent2KHR;
+    if (nameHash == 0x8a862e62841ec082 /* vkCmdResetEvent2KHR */) return (void *)table->CmdResetEvent2KHR;
+    if (nameHash == 0x1b8ec29acf8f9c34 /* vkCmdWaitEvents2KHR */) return (void *)table->CmdWaitEvents2KHR;
+    if (nameHash == 0x47b5e34bc173355d /* vkCmdPipelineBarrier2KHR */) return (void *)table->CmdPipelineBarrier2KHR;
+    if (nameHash == 0x2e9f27714c27c160 /* vkCmdWriteTimestamp2KHR */) return (void *)table->CmdWriteTimestamp2KHR;
+    if (nameHash == 0x7eff5818fce6b445 /* vkQueueSubmit2KHR */) return (void *)table->QueueSubmit2KHR;
 
     // ---- VK_KHR_copy_commands2 extension commands
-    if (!strcmp(name, "CmdCopyBuffer2KHR")) return (void *)table->CmdCopyBuffer2KHR;
-    if (!strcmp(name, "CmdCopyImage2KHR")) return (void *)table->CmdCopyImage2KHR;
-    if (!strcmp(name, "CmdCopyBufferToImage2KHR")) return (void *)table->CmdCopyBufferToImage2KHR;
-    if (!strcmp(name, "CmdCopyImageToBuffer2KHR")) return (void *)table->CmdCopyImageToBuffer2KHR;
-    if (!strcmp(name, "CmdBlitImage2KHR")) return (void *)table->CmdBlitImage2KHR;
-    if (!strcmp(name, "CmdResolveImage2KHR")) return (void *)table->CmdResolveImage2KHR;
+    if (nameHash == 0x4d3f08ecfb5c4893 /* vkCmdCopyBuffer2KHR */) return (void *)table->CmdCopyBuffer2KHR;
+    if (nameHash == 0xb172c9f4537a3da8 /* vkCmdCopyImage2KHR */) return (void *)table->CmdCopyImage2KHR;
+    if (nameHash == 0xaae6e3e723f39a93 /* vkCmdCopyBufferToImage2KHR */) return (void *)table->CmdCopyBufferToImage2KHR;
+    if (nameHash == 0x02eb4358362cbe5f /* vkCmdCopyImageToBuffer2KHR */) return (void *)table->CmdCopyImageToBuffer2KHR;
+    if (nameHash == 0xcdda04206e1c1dfe /* vkCmdBlitImage2KHR */) return (void *)table->CmdBlitImage2KHR;
+    if (nameHash == 0xda6d56b119c97568 /* vkCmdResolveImage2KHR */) return (void *)table->CmdResolveImage2KHR;
 
     // ---- VK_KHR_ray_tracing_maintenance1 extension commands
-    if (!strcmp(name, "CmdTraceRaysIndirect2KHR")) return (void *)table->CmdTraceRaysIndirect2KHR;
+    if (nameHash == 0x40db28be40a6f866 /* vkCmdTraceRaysIndirect2KHR */) return (void *)table->CmdTraceRaysIndirect2KHR;
 
     // ---- VK_KHR_maintenance4 extension commands
-    if (!strcmp(name, "GetDeviceBufferMemoryRequirementsKHR")) return (void *)table->GetDeviceBufferMemoryRequirementsKHR;
-    if (!strcmp(name, "GetDeviceImageMemoryRequirementsKHR")) return (void *)table->GetDeviceImageMemoryRequirementsKHR;
-    if (!strcmp(name, "GetDeviceImageSparseMemoryRequirementsKHR")) return (void *)table->GetDeviceImageSparseMemoryRequirementsKHR;
+    if (nameHash == 0x0e4eac678a76ed33 /* vkGetDeviceBufferMemoryRequirementsKHR */) return (void *)table->GetDeviceBufferMemoryRequirementsKHR;
+    if (nameHash == 0xb914845a146232bd /* vkGetDeviceImageMemoryRequirementsKHR */) return (void *)table->GetDeviceImageMemoryRequirementsKHR;
+    if (nameHash == 0x423629691279d2c9 /* vkGetDeviceImageSparseMemoryRequirementsKHR */) return (void *)table->GetDeviceImageSparseMemoryRequirementsKHR;
 
     // ---- VK_KHR_maintenance5 extension commands
-    if (!strcmp(name, "CmdBindIndexBuffer2KHR")) return (void *)table->CmdBindIndexBuffer2KHR;
-    if (!strcmp(name, "GetRenderingAreaGranularityKHR")) return (void *)table->GetRenderingAreaGranularityKHR;
-    if (!strcmp(name, "GetDeviceImageSubresourceLayoutKHR")) return (void *)table->GetDeviceImageSubresourceLayoutKHR;
-    if (!strcmp(name, "GetImageSubresourceLayout2KHR")) return (void *)table->GetImageSubresourceLayout2KHR;
+    if (nameHash == 0x6fde01fd66c6087a /* vkCmdBindIndexBuffer2KHR */) return (void *)table->CmdBindIndexBuffer2KHR;
+    if (nameHash == 0xff17500f60079a4b /* vkGetRenderingAreaGranularityKHR */) return (void *)table->GetRenderingAreaGranularityKHR;
+    if (nameHash == 0xd1bfa4d3176b81a7 /* vkGetDeviceImageSubresourceLayoutKHR */) return (void *)table->GetDeviceImageSubresourceLayoutKHR;
+    if (nameHash == 0xfa88974bd2f1055c /* vkGetImageSubresourceLayout2KHR */) return (void *)table->GetImageSubresourceLayout2KHR;
 
     // ---- VK_KHR_pipeline_binary extension commands
-    if (!strcmp(name, "CreatePipelineBinariesKHR")) return (void *)table->CreatePipelineBinariesKHR;
-    if (!strcmp(name, "DestroyPipelineBinaryKHR")) return (void *)table->DestroyPipelineBinaryKHR;
-    if (!strcmp(name, "GetPipelineKeyKHR")) return (void *)table->GetPipelineKeyKHR;
-    if (!strcmp(name, "GetPipelineBinaryDataKHR")) return (void *)table->GetPipelineBinaryDataKHR;
-    if (!strcmp(name, "ReleaseCapturedPipelineDataKHR")) return (void *)table->ReleaseCapturedPipelineDataKHR;
+    if (nameHash == 0x7b8f5cb6ad62ff2c /* vkCreatePipelineBinariesKHR */) return (void *)table->CreatePipelineBinariesKHR;
+    if (nameHash == 0x5e156baf498f5138 /* vkDestroyPipelineBinaryKHR */) return (void *)table->DestroyPipelineBinaryKHR;
+    if (nameHash == 0xe7ba2bcf3218ef91 /* vkGetPipelineKeyKHR */) return (void *)table->GetPipelineKeyKHR;
+    if (nameHash == 0x3446c4b0e0ed13c7 /* vkGetPipelineBinaryDataKHR */) return (void *)table->GetPipelineBinaryDataKHR;
+    if (nameHash == 0x8f433193cdb26798 /* vkReleaseCapturedPipelineDataKHR */) return (void *)table->ReleaseCapturedPipelineDataKHR;
 
     // ---- VK_KHR_line_rasterization extension commands
-    if (!strcmp(name, "CmdSetLineStippleKHR")) return (void *)table->CmdSetLineStippleKHR;
+    if (nameHash == 0x24f886fa5cebd7ed /* vkCmdSetLineStippleKHR */) return (void *)table->CmdSetLineStippleKHR;
 
     // ---- VK_KHR_calibrated_timestamps extension commands
-    if (!strcmp(name, "GetCalibratedTimestampsKHR")) return (void *)table->GetCalibratedTimestampsKHR;
+    if (nameHash == 0x0c4f4995392e50ab /* vkGetCalibratedTimestampsKHR */) return (void *)table->GetCalibratedTimestampsKHR;
 
     // ---- VK_KHR_maintenance6 extension commands
-    if (!strcmp(name, "CmdBindDescriptorSets2KHR")) return (void *)table->CmdBindDescriptorSets2KHR;
-    if (!strcmp(name, "CmdPushConstants2KHR")) return (void *)table->CmdPushConstants2KHR;
-    if (!strcmp(name, "CmdPushDescriptorSet2KHR")) return (void *)table->CmdPushDescriptorSet2KHR;
-    if (!strcmp(name, "CmdPushDescriptorSetWithTemplate2KHR")) return (void *)table->CmdPushDescriptorSetWithTemplate2KHR;
-    if (!strcmp(name, "CmdSetDescriptorBufferOffsets2EXT")) return (void *)table->CmdSetDescriptorBufferOffsets2EXT;
-    if (!strcmp(name, "CmdBindDescriptorBufferEmbeddedSamplers2EXT")) return (void *)table->CmdBindDescriptorBufferEmbeddedSamplers2EXT;
+    if (nameHash == 0xbb625b5594f09b62 /* vkCmdBindDescriptorSets2KHR */) return (void *)table->CmdBindDescriptorSets2KHR;
+    if (nameHash == 0x844e6fc97d32338d /* vkCmdPushConstants2KHR */) return (void *)table->CmdPushConstants2KHR;
+    if (nameHash == 0xda9d391d34dd9078 /* vkCmdPushDescriptorSet2KHR */) return (void *)table->CmdPushDescriptorSet2KHR;
+    if (nameHash == 0xf42ac32ac7eb727c /* vkCmdPushDescriptorSetWithTemplate2KHR */) return (void *)table->CmdPushDescriptorSetWithTemplate2KHR;
+    if (nameHash == 0x5d404fade6187f05 /* vkCmdSetDescriptorBufferOffsets2EXT */) return (void *)table->CmdSetDescriptorBufferOffsets2EXT;
+    if (nameHash == 0x908be4be59b54bee /* vkCmdBindDescriptorBufferEmbeddedSamplers2EXT */) return (void *)table->CmdBindDescriptorBufferEmbeddedSamplers2EXT;
 
     // ---- VK_EXT_debug_marker extension commands
-    if (!strcmp(name, "DebugMarkerSetObjectTagEXT")) return dev->layer_extensions.ext_debug_marker_enabled ? (void *)DebugMarkerSetObjectTagEXT : NULL;
-    if (!strcmp(name, "DebugMarkerSetObjectNameEXT")) return dev->layer_extensions.ext_debug_marker_enabled ? (void *)DebugMarkerSetObjectNameEXT : NULL;
-    if (!strcmp(name, "CmdDebugMarkerBeginEXT")) return (void *)table->CmdDebugMarkerBeginEXT;
-    if (!strcmp(name, "CmdDebugMarkerEndEXT")) return (void *)table->CmdDebugMarkerEndEXT;
-    if (!strcmp(name, "CmdDebugMarkerInsertEXT")) return (void *)table->CmdDebugMarkerInsertEXT;
+    if (nameHash == 0xa739034f864fc640 /* vkDebugMarkerSetObjectTagEXT */) return dev->layer_extensions.ext_debug_marker_enabled ? (void *)DebugMarkerSetObjectTagEXT : NULL;
+    if (nameHash == 0xb1c51323a9aecd49 /* vkDebugMarkerSetObjectNameEXT */) return dev->layer_extensions.ext_debug_marker_enabled ? (void *)DebugMarkerSetObjectNameEXT : NULL;
+    if (nameHash == 0xba7d020dda50aee4 /* vkCmdDebugMarkerBeginEXT */) return (void *)table->CmdDebugMarkerBeginEXT;
+    if (nameHash == 0x96d500101d2c0cfc /* vkCmdDebugMarkerEndEXT */) return (void *)table->CmdDebugMarkerEndEXT;
+    if (nameHash == 0x09da53bc6b918573 /* vkCmdDebugMarkerInsertEXT */) return (void *)table->CmdDebugMarkerInsertEXT;
 
     // ---- VK_EXT_transform_feedback extension commands
-    if (!strcmp(name, "CmdBindTransformFeedbackBuffersEXT")) return (void *)table->CmdBindTransformFeedbackBuffersEXT;
-    if (!strcmp(name, "CmdBeginTransformFeedbackEXT")) return (void *)table->CmdBeginTransformFeedbackEXT;
-    if (!strcmp(name, "CmdEndTransformFeedbackEXT")) return (void *)table->CmdEndTransformFeedbackEXT;
-    if (!strcmp(name, "CmdBeginQueryIndexedEXT")) return (void *)table->CmdBeginQueryIndexedEXT;
-    if (!strcmp(name, "CmdEndQueryIndexedEXT")) return (void *)table->CmdEndQueryIndexedEXT;
-    if (!strcmp(name, "CmdDrawIndirectByteCountEXT")) return (void *)table->CmdDrawIndirectByteCountEXT;
+    if (nameHash == 0x24975600fb49fd73 /* vkCmdBindTransformFeedbackBuffersEXT */) return (void *)table->CmdBindTransformFeedbackBuffersEXT;
+    if (nameHash == 0xae000b2715cd085c /* vkCmdBeginTransformFeedbackEXT */) return (void *)table->CmdBeginTransformFeedbackEXT;
+    if (nameHash == 0x20681e0c6bf30380 /* vkCmdEndTransformFeedbackEXT */) return (void *)table->CmdEndTransformFeedbackEXT;
+    if (nameHash == 0xa3c120c4c081785a /* vkCmdBeginQueryIndexedEXT */) return (void *)table->CmdBeginQueryIndexedEXT;
+    if (nameHash == 0xcb5126a43f13e1de /* vkCmdEndQueryIndexedEXT */) return (void *)table->CmdEndQueryIndexedEXT;
+    if (nameHash == 0x1028e41b255d6802 /* vkCmdDrawIndirectByteCountEXT */) return (void *)table->CmdDrawIndirectByteCountEXT;
 
     // ---- VK_NVX_binary_import extension commands
-    if (!strcmp(name, "CreateCuModuleNVX")) return (void *)table->CreateCuModuleNVX;
-    if (!strcmp(name, "CreateCuFunctionNVX")) return (void *)table->CreateCuFunctionNVX;
-    if (!strcmp(name, "DestroyCuModuleNVX")) return (void *)table->DestroyCuModuleNVX;
-    if (!strcmp(name, "DestroyCuFunctionNVX")) return (void *)table->DestroyCuFunctionNVX;
-    if (!strcmp(name, "CmdCuLaunchKernelNVX")) return (void *)table->CmdCuLaunchKernelNVX;
+    if (nameHash == 0x70f16cd080e5a1e1 /* vkCreateCuModuleNVX */) return (void *)table->CreateCuModuleNVX;
+    if (nameHash == 0x9df40d3bb19dc7f0 /* vkCreateCuFunctionNVX */) return (void *)table->CreateCuFunctionNVX;
+    if (nameHash == 0xa47abcf416f45e13 /* vkDestroyCuModuleNVX */) return (void *)table->DestroyCuModuleNVX;
+    if (nameHash == 0xe9321def2e9912ac /* vkDestroyCuFunctionNVX */) return (void *)table->DestroyCuFunctionNVX;
+    if (nameHash == 0xc8ce9307051f9bc4 /* vkCmdCuLaunchKernelNVX */) return (void *)table->CmdCuLaunchKernelNVX;
 
     // ---- VK_NVX_image_view_handle extension commands
-    if (!strcmp(name, "GetImageViewHandleNVX")) return (void *)table->GetImageViewHandleNVX;
-    if (!strcmp(name, "GetImageViewHandle64NVX")) return (void *)table->GetImageViewHandle64NVX;
-    if (!strcmp(name, "GetImageViewAddressNVX")) return (void *)table->GetImageViewAddressNVX;
+    if (nameHash == 0x1b250d8529b8c649 /* vkGetImageViewHandleNVX */) return (void *)table->GetImageViewHandleNVX;
+    if (nameHash == 0x45e8058b548405ce /* vkGetImageViewHandle64NVX */) return (void *)table->GetImageViewHandle64NVX;
+    if (nameHash == 0x2c6e7da8d69f6259 /* vkGetImageViewAddressNVX */) return (void *)table->GetImageViewAddressNVX;
 
     // ---- VK_AMD_draw_indirect_count extension commands
-    if (!strcmp(name, "CmdDrawIndirectCountAMD")) return (void *)table->CmdDrawIndirectCountAMD;
-    if (!strcmp(name, "CmdDrawIndexedIndirectCountAMD")) return (void *)table->CmdDrawIndexedIndirectCountAMD;
+    if (nameHash == 0x658b77dd8968ff3b /* vkCmdDrawIndirectCountAMD */) return (void *)table->CmdDrawIndirectCountAMD;
+    if (nameHash == 0x95e478a17bd017c9 /* vkCmdDrawIndexedIndirectCountAMD */) return (void *)table->CmdDrawIndexedIndirectCountAMD;
 
     // ---- VK_AMD_shader_info extension commands
-    if (!strcmp(name, "GetShaderInfoAMD")) return (void *)table->GetShaderInfoAMD;
+    if (nameHash == 0x899487a9c9bfa851 /* vkGetShaderInfoAMD */) return (void *)table->GetShaderInfoAMD;
 
     // ---- VK_NV_external_memory_win32 extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "GetMemoryWin32HandleNV")) return (void *)table->GetMemoryWin32HandleNV;
+    if (nameHash == 0xc21c28ddac3fbec3 /* vkGetMemoryWin32HandleNV */) return (void *)table->GetMemoryWin32HandleNV;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_EXT_conditional_rendering extension commands
-    if (!strcmp(name, "CmdBeginConditionalRenderingEXT")) return (void *)table->CmdBeginConditionalRenderingEXT;
-    if (!strcmp(name, "CmdEndConditionalRenderingEXT")) return (void *)table->CmdEndConditionalRenderingEXT;
+    if (nameHash == 0x73bc2739d085085f /* vkCmdBeginConditionalRenderingEXT */) return (void *)table->CmdBeginConditionalRenderingEXT;
+    if (nameHash == 0x1812390287e35f0c /* vkCmdEndConditionalRenderingEXT */) return (void *)table->CmdEndConditionalRenderingEXT;
 
     // ---- VK_NV_clip_space_w_scaling extension commands
-    if (!strcmp(name, "CmdSetViewportWScalingNV")) return (void *)table->CmdSetViewportWScalingNV;
+    if (nameHash == 0xb67ff6e303d3c4fb /* vkCmdSetViewportWScalingNV */) return (void *)table->CmdSetViewportWScalingNV;
 
     // ---- VK_EXT_display_control extension commands
-    if (!strcmp(name, "DisplayPowerControlEXT")) return (void *)table->DisplayPowerControlEXT;
-    if (!strcmp(name, "RegisterDeviceEventEXT")) return (void *)table->RegisterDeviceEventEXT;
-    if (!strcmp(name, "RegisterDisplayEventEXT")) return (void *)table->RegisterDisplayEventEXT;
-    if (!strcmp(name, "GetSwapchainCounterEXT")) return (void *)table->GetSwapchainCounterEXT;
+    if (nameHash == 0x2bd217fc8713bb23 /* vkDisplayPowerControlEXT */) return (void *)table->DisplayPowerControlEXT;
+    if (nameHash == 0x8a4301ac1aeca958 /* vkRegisterDeviceEventEXT */) return (void *)table->RegisterDeviceEventEXT;
+    if (nameHash == 0x21f4e40d1b10ea20 /* vkRegisterDisplayEventEXT */) return (void *)table->RegisterDisplayEventEXT;
+    if (nameHash == 0x04134f0c5694394f /* vkGetSwapchainCounterEXT */) return (void *)table->GetSwapchainCounterEXT;
 
     // ---- VK_GOOGLE_display_timing extension commands
-    if (!strcmp(name, "GetRefreshCycleDurationGOOGLE")) return (void *)table->GetRefreshCycleDurationGOOGLE;
-    if (!strcmp(name, "GetPastPresentationTimingGOOGLE")) return (void *)table->GetPastPresentationTimingGOOGLE;
+    if (nameHash == 0x9fd2d4176909d303 /* vkGetRefreshCycleDurationGOOGLE */) return (void *)table->GetRefreshCycleDurationGOOGLE;
+    if (nameHash == 0x5dcda38c668184b8 /* vkGetPastPresentationTimingGOOGLE */) return (void *)table->GetPastPresentationTimingGOOGLE;
 
     // ---- VK_EXT_discard_rectangles extension commands
-    if (!strcmp(name, "CmdSetDiscardRectangleEXT")) return (void *)table->CmdSetDiscardRectangleEXT;
-    if (!strcmp(name, "CmdSetDiscardRectangleEnableEXT")) return (void *)table->CmdSetDiscardRectangleEnableEXT;
-    if (!strcmp(name, "CmdSetDiscardRectangleModeEXT")) return (void *)table->CmdSetDiscardRectangleModeEXT;
+    if (nameHash == 0x92bb34229e07c467 /* vkCmdSetDiscardRectangleEXT */) return (void *)table->CmdSetDiscardRectangleEXT;
+    if (nameHash == 0xae74bca0714f1b3b /* vkCmdSetDiscardRectangleEnableEXT */) return (void *)table->CmdSetDiscardRectangleEnableEXT;
+    if (nameHash == 0xe5686168ac2e1c2a /* vkCmdSetDiscardRectangleModeEXT */) return (void *)table->CmdSetDiscardRectangleModeEXT;
 
     // ---- VK_EXT_hdr_metadata extension commands
-    if (!strcmp(name, "SetHdrMetadataEXT")) return (void *)table->SetHdrMetadataEXT;
+    if (nameHash == 0x35a324447b0101e4 /* vkSetHdrMetadataEXT */) return (void *)table->SetHdrMetadataEXT;
 
     // ---- VK_EXT_debug_utils extension commands
-    if (!strcmp(name, "SetDebugUtilsObjectNameEXT")) return dev->layer_extensions.ext_debug_utils_enabled ? (void *)SetDebugUtilsObjectNameEXT : NULL;
-    if (!strcmp(name, "SetDebugUtilsObjectTagEXT")) return dev->layer_extensions.ext_debug_utils_enabled ? (void *)SetDebugUtilsObjectTagEXT : NULL;
-    if (!strcmp(name, "QueueBeginDebugUtilsLabelEXT")) return (void *)table->QueueBeginDebugUtilsLabelEXT;
-    if (!strcmp(name, "QueueEndDebugUtilsLabelEXT")) return (void *)table->QueueEndDebugUtilsLabelEXT;
-    if (!strcmp(name, "QueueInsertDebugUtilsLabelEXT")) return (void *)table->QueueInsertDebugUtilsLabelEXT;
-    if (!strcmp(name, "CmdBeginDebugUtilsLabelEXT")) return (void *)table->CmdBeginDebugUtilsLabelEXT;
-    if (!strcmp(name, "CmdEndDebugUtilsLabelEXT")) return (void *)table->CmdEndDebugUtilsLabelEXT;
-    if (!strcmp(name, "CmdInsertDebugUtilsLabelEXT")) return (void *)table->CmdInsertDebugUtilsLabelEXT;
+    if (nameHash == 0xfccd697bc5cf4494 /* vkSetDebugUtilsObjectNameEXT */) return dev->layer_extensions.ext_debug_utils_enabled ? (void *)SetDebugUtilsObjectNameEXT : NULL;
+    if (nameHash == 0x7fd35824391d47a4 /* vkSetDebugUtilsObjectTagEXT */) return dev->layer_extensions.ext_debug_utils_enabled ? (void *)SetDebugUtilsObjectTagEXT : NULL;
+    if (nameHash == 0xd88e4fe9c0329771 /* vkQueueBeginDebugUtilsLabelEXT */) return (void *)table->QueueBeginDebugUtilsLabelEXT;
+    if (nameHash == 0x6756af5e610d6533 /* vkQueueEndDebugUtilsLabelEXT */) return (void *)table->QueueEndDebugUtilsLabelEXT;
+    if (nameHash == 0xe2b6c462d682d0aa /* vkQueueInsertDebugUtilsLabelEXT */) return (void *)table->QueueInsertDebugUtilsLabelEXT;
+    if (nameHash == 0xa53a9028f9deee27 /* vkCmdBeginDebugUtilsLabelEXT */) return (void *)table->CmdBeginDebugUtilsLabelEXT;
+    if (nameHash == 0xb70a1f7b0d640472 /* vkCmdEndDebugUtilsLabelEXT */) return (void *)table->CmdEndDebugUtilsLabelEXT;
+    if (nameHash == 0x0f70146a40b73eaf /* vkCmdInsertDebugUtilsLabelEXT */) return (void *)table->CmdInsertDebugUtilsLabelEXT;
 
     // ---- VK_ANDROID_external_memory_android_hardware_buffer extension commands
 #if defined(VK_USE_PLATFORM_ANDROID_KHR)
-    if (!strcmp(name, "GetAndroidHardwareBufferPropertiesANDROID")) return (void *)table->GetAndroidHardwareBufferPropertiesANDROID;
+    if (nameHash == 0x0e2e5dfee87cb6bc /* vkGetAndroidHardwareBufferPropertiesANDROID */) return (void *)table->GetAndroidHardwareBufferPropertiesANDROID;
 #endif // VK_USE_PLATFORM_ANDROID_KHR
 #if defined(VK_USE_PLATFORM_ANDROID_KHR)
-    if (!strcmp(name, "GetMemoryAndroidHardwareBufferANDROID")) return (void *)table->GetMemoryAndroidHardwareBufferANDROID;
+    if (nameHash == 0x821ae6559b48f066 /* vkGetMemoryAndroidHardwareBufferANDROID */) return (void *)table->GetMemoryAndroidHardwareBufferANDROID;
 #endif // VK_USE_PLATFORM_ANDROID_KHR
 
     // ---- VK_AMDX_shader_enqueue extension commands
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp(name, "CreateExecutionGraphPipelinesAMDX")) return (void *)table->CreateExecutionGraphPipelinesAMDX;
+    if (nameHash == 0x714129686c9da431 /* vkCreateExecutionGraphPipelinesAMDX */) return (void *)table->CreateExecutionGraphPipelinesAMDX;
 #endif // VK_ENABLE_BETA_EXTENSIONS
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp(name, "GetExecutionGraphPipelineScratchSizeAMDX")) return (void *)table->GetExecutionGraphPipelineScratchSizeAMDX;
+    if (nameHash == 0x272dc15f9cab3de4 /* vkGetExecutionGraphPipelineScratchSizeAMDX */) return (void *)table->GetExecutionGraphPipelineScratchSizeAMDX;
 #endif // VK_ENABLE_BETA_EXTENSIONS
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp(name, "GetExecutionGraphPipelineNodeIndexAMDX")) return (void *)table->GetExecutionGraphPipelineNodeIndexAMDX;
+    if (nameHash == 0x9c10b26ceb8d7cd4 /* vkGetExecutionGraphPipelineNodeIndexAMDX */) return (void *)table->GetExecutionGraphPipelineNodeIndexAMDX;
 #endif // VK_ENABLE_BETA_EXTENSIONS
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp(name, "CmdInitializeGraphScratchMemoryAMDX")) return (void *)table->CmdInitializeGraphScratchMemoryAMDX;
+    if (nameHash == 0xa143601d567d78a8 /* vkCmdInitializeGraphScratchMemoryAMDX */) return (void *)table->CmdInitializeGraphScratchMemoryAMDX;
 #endif // VK_ENABLE_BETA_EXTENSIONS
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp(name, "CmdDispatchGraphAMDX")) return (void *)table->CmdDispatchGraphAMDX;
+    if (nameHash == 0xf31eeaf76f0b6dca /* vkCmdDispatchGraphAMDX */) return (void *)table->CmdDispatchGraphAMDX;
 #endif // VK_ENABLE_BETA_EXTENSIONS
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp(name, "CmdDispatchGraphIndirectAMDX")) return (void *)table->CmdDispatchGraphIndirectAMDX;
+    if (nameHash == 0x4e7d037aae3a3033 /* vkCmdDispatchGraphIndirectAMDX */) return (void *)table->CmdDispatchGraphIndirectAMDX;
 #endif // VK_ENABLE_BETA_EXTENSIONS
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp(name, "CmdDispatchGraphIndirectCountAMDX")) return (void *)table->CmdDispatchGraphIndirectCountAMDX;
+    if (nameHash == 0xd8c4bb7f3586d513 /* vkCmdDispatchGraphIndirectCountAMDX */) return (void *)table->CmdDispatchGraphIndirectCountAMDX;
 #endif // VK_ENABLE_BETA_EXTENSIONS
 
     // ---- VK_EXT_sample_locations extension commands
-    if (!strcmp(name, "CmdSetSampleLocationsEXT")) return (void *)table->CmdSetSampleLocationsEXT;
+    if (nameHash == 0xfa5d78b1a973792e /* vkCmdSetSampleLocationsEXT */) return (void *)table->CmdSetSampleLocationsEXT;
 
     // ---- VK_EXT_image_drm_format_modifier extension commands
-    if (!strcmp(name, "GetImageDrmFormatModifierPropertiesEXT")) return (void *)table->GetImageDrmFormatModifierPropertiesEXT;
+    if (nameHash == 0x85f72ff33d09f9fc /* vkGetImageDrmFormatModifierPropertiesEXT */) return (void *)table->GetImageDrmFormatModifierPropertiesEXT;
 
     // ---- VK_EXT_validation_cache extension commands
-    if (!strcmp(name, "CreateValidationCacheEXT")) return (void *)table->CreateValidationCacheEXT;
-    if (!strcmp(name, "DestroyValidationCacheEXT")) return (void *)table->DestroyValidationCacheEXT;
-    if (!strcmp(name, "MergeValidationCachesEXT")) return (void *)table->MergeValidationCachesEXT;
-    if (!strcmp(name, "GetValidationCacheDataEXT")) return (void *)table->GetValidationCacheDataEXT;
+    if (nameHash == 0x80ad81694be917a9 /* vkCreateValidationCacheEXT */) return (void *)table->CreateValidationCacheEXT;
+    if (nameHash == 0xc522092927d98161 /* vkDestroyValidationCacheEXT */) return (void *)table->DestroyValidationCacheEXT;
+    if (nameHash == 0x91b293db19f39ca5 /* vkMergeValidationCachesEXT */) return (void *)table->MergeValidationCachesEXT;
+    if (nameHash == 0x10635a7a4fcc2c76 /* vkGetValidationCacheDataEXT */) return (void *)table->GetValidationCacheDataEXT;
 
     // ---- VK_NV_shading_rate_image extension commands
-    if (!strcmp(name, "CmdBindShadingRateImageNV")) return (void *)table->CmdBindShadingRateImageNV;
-    if (!strcmp(name, "CmdSetViewportShadingRatePaletteNV")) return (void *)table->CmdSetViewportShadingRatePaletteNV;
-    if (!strcmp(name, "CmdSetCoarseSampleOrderNV")) return (void *)table->CmdSetCoarseSampleOrderNV;
+    if (nameHash == 0x36135fe5c54d3b34 /* vkCmdBindShadingRateImageNV */) return (void *)table->CmdBindShadingRateImageNV;
+    if (nameHash == 0x26c37395ff9739bc /* vkCmdSetViewportShadingRatePaletteNV */) return (void *)table->CmdSetViewportShadingRatePaletteNV;
+    if (nameHash == 0x12ca3f3ec96315f3 /* vkCmdSetCoarseSampleOrderNV */) return (void *)table->CmdSetCoarseSampleOrderNV;
 
     // ---- VK_NV_ray_tracing extension commands
-    if (!strcmp(name, "CreateAccelerationStructureNV")) return (void *)table->CreateAccelerationStructureNV;
-    if (!strcmp(name, "DestroyAccelerationStructureNV")) return (void *)table->DestroyAccelerationStructureNV;
-    if (!strcmp(name, "GetAccelerationStructureMemoryRequirementsNV")) return (void *)table->GetAccelerationStructureMemoryRequirementsNV;
-    if (!strcmp(name, "BindAccelerationStructureMemoryNV")) return (void *)table->BindAccelerationStructureMemoryNV;
-    if (!strcmp(name, "CmdBuildAccelerationStructureNV")) return (void *)table->CmdBuildAccelerationStructureNV;
-    if (!strcmp(name, "CmdCopyAccelerationStructureNV")) return (void *)table->CmdCopyAccelerationStructureNV;
-    if (!strcmp(name, "CmdTraceRaysNV")) return (void *)table->CmdTraceRaysNV;
-    if (!strcmp(name, "CreateRayTracingPipelinesNV")) return (void *)table->CreateRayTracingPipelinesNV;
-    if (!strcmp(name, "GetRayTracingShaderGroupHandlesKHR")) return (void *)table->GetRayTracingShaderGroupHandlesKHR;
-    if (!strcmp(name, "GetRayTracingShaderGroupHandlesNV")) return (void *)table->GetRayTracingShaderGroupHandlesNV;
-    if (!strcmp(name, "GetAccelerationStructureHandleNV")) return (void *)table->GetAccelerationStructureHandleNV;
-    if (!strcmp(name, "CmdWriteAccelerationStructuresPropertiesNV")) return (void *)table->CmdWriteAccelerationStructuresPropertiesNV;
-    if (!strcmp(name, "CompileDeferredNV")) return (void *)table->CompileDeferredNV;
+    if (nameHash == 0x3ce0faf5d18dc25b /* vkCreateAccelerationStructureNV */) return (void *)table->CreateAccelerationStructureNV;
+    if (nameHash == 0xfe4be9de353f2023 /* vkDestroyAccelerationStructureNV */) return (void *)table->DestroyAccelerationStructureNV;
+    if (nameHash == 0x5c965829c780d9f3 /* vkGetAccelerationStructureMemoryRequirementsNV */) return (void *)table->GetAccelerationStructureMemoryRequirementsNV;
+    if (nameHash == 0x6e0d98ae9ace40d5 /* vkBindAccelerationStructureMemoryNV */) return (void *)table->BindAccelerationStructureMemoryNV;
+    if (nameHash == 0x4092cc86b9e7806e /* vkCmdBuildAccelerationStructureNV */) return (void *)table->CmdBuildAccelerationStructureNV;
+    if (nameHash == 0x1d7e628cb67db142 /* vkCmdCopyAccelerationStructureNV */) return (void *)table->CmdCopyAccelerationStructureNV;
+    if (nameHash == 0x877be98356e2a511 /* vkCmdTraceRaysNV */) return (void *)table->CmdTraceRaysNV;
+    if (nameHash == 0x4d0e89b321a6faef /* vkCreateRayTracingPipelinesNV */) return (void *)table->CreateRayTracingPipelinesNV;
+    if (nameHash == 0x0802604e7494d3a4 /* vkGetRayTracingShaderGroupHandlesKHR */) return (void *)table->GetRayTracingShaderGroupHandlesKHR;
+    if (nameHash == 0x8bd0b4949f3f2aa3 /* vkGetRayTracingShaderGroupHandlesNV */) return (void *)table->GetRayTracingShaderGroupHandlesNV;
+    if (nameHash == 0x9e1cf02c5780b2d6 /* vkGetAccelerationStructureHandleNV */) return (void *)table->GetAccelerationStructureHandleNV;
+    if (nameHash == 0x9f690b963d6e97a7 /* vkCmdWriteAccelerationStructuresPropertiesNV */) return (void *)table->CmdWriteAccelerationStructuresPropertiesNV;
+    if (nameHash == 0xe7b1ed7ad6f748f7 /* vkCompileDeferredNV */) return (void *)table->CompileDeferredNV;
 
     // ---- VK_EXT_external_memory_host extension commands
-    if (!strcmp(name, "GetMemoryHostPointerPropertiesEXT")) return (void *)table->GetMemoryHostPointerPropertiesEXT;
+    if (nameHash == 0x70cfd8006341080a /* vkGetMemoryHostPointerPropertiesEXT */) return (void *)table->GetMemoryHostPointerPropertiesEXT;
 
     // ---- VK_AMD_buffer_marker extension commands
-    if (!strcmp(name, "CmdWriteBufferMarkerAMD")) return (void *)table->CmdWriteBufferMarkerAMD;
-    if (!strcmp(name, "CmdWriteBufferMarker2AMD")) return (void *)table->CmdWriteBufferMarker2AMD;
+    if (nameHash == 0x75e32a36acf72579 /* vkCmdWriteBufferMarkerAMD */) return (void *)table->CmdWriteBufferMarkerAMD;
+    if (nameHash == 0xb523ea07e8e7d77f /* vkCmdWriteBufferMarker2AMD */) return (void *)table->CmdWriteBufferMarker2AMD;
 
     // ---- VK_EXT_calibrated_timestamps extension commands
-    if (!strcmp(name, "GetCalibratedTimestampsEXT")) return (void *)table->GetCalibratedTimestampsEXT;
+    if (nameHash == 0x49a74d66be4fce8b /* vkGetCalibratedTimestampsEXT */) return (void *)table->GetCalibratedTimestampsEXT;
 
     // ---- VK_NV_mesh_shader extension commands
-    if (!strcmp(name, "CmdDrawMeshTasksNV")) return (void *)table->CmdDrawMeshTasksNV;
-    if (!strcmp(name, "CmdDrawMeshTasksIndirectNV")) return (void *)table->CmdDrawMeshTasksIndirectNV;
-    if (!strcmp(name, "CmdDrawMeshTasksIndirectCountNV")) return (void *)table->CmdDrawMeshTasksIndirectCountNV;
+    if (nameHash == 0xb0aeacfa9fc521aa /* vkCmdDrawMeshTasksNV */) return (void *)table->CmdDrawMeshTasksNV;
+    if (nameHash == 0x56698661adbb7534 /* vkCmdDrawMeshTasksIndirectNV */) return (void *)table->CmdDrawMeshTasksIndirectNV;
+    if (nameHash == 0xae68bbafa60e1bfd /* vkCmdDrawMeshTasksIndirectCountNV */) return (void *)table->CmdDrawMeshTasksIndirectCountNV;
 
     // ---- VK_NV_scissor_exclusive extension commands
-    if (!strcmp(name, "CmdSetExclusiveScissorEnableNV")) return (void *)table->CmdSetExclusiveScissorEnableNV;
-    if (!strcmp(name, "CmdSetExclusiveScissorNV")) return (void *)table->CmdSetExclusiveScissorNV;
+    if (nameHash == 0x085d172fa3bb5527 /* vkCmdSetExclusiveScissorEnableNV */) return (void *)table->CmdSetExclusiveScissorEnableNV;
+    if (nameHash == 0x429417467467b909 /* vkCmdSetExclusiveScissorNV */) return (void *)table->CmdSetExclusiveScissorNV;
 
     // ---- VK_NV_device_diagnostic_checkpoints extension commands
-    if (!strcmp(name, "CmdSetCheckpointNV")) return (void *)table->CmdSetCheckpointNV;
-    if (!strcmp(name, "GetQueueCheckpointDataNV")) return (void *)table->GetQueueCheckpointDataNV;
-    if (!strcmp(name, "GetQueueCheckpointData2NV")) return (void *)table->GetQueueCheckpointData2NV;
+    if (nameHash == 0x35ddb5f0819f35bf /* vkCmdSetCheckpointNV */) return (void *)table->CmdSetCheckpointNV;
+    if (nameHash == 0x3d8f82b873097a02 /* vkGetQueueCheckpointDataNV */) return (void *)table->GetQueueCheckpointDataNV;
+    if (nameHash == 0x66d07f2af74e8d8b /* vkGetQueueCheckpointData2NV */) return (void *)table->GetQueueCheckpointData2NV;
 
     // ---- VK_INTEL_performance_query extension commands
-    if (!strcmp(name, "InitializePerformanceApiINTEL")) return (void *)table->InitializePerformanceApiINTEL;
-    if (!strcmp(name, "UninitializePerformanceApiINTEL")) return (void *)table->UninitializePerformanceApiINTEL;
-    if (!strcmp(name, "CmdSetPerformanceMarkerINTEL")) return (void *)table->CmdSetPerformanceMarkerINTEL;
-    if (!strcmp(name, "CmdSetPerformanceStreamMarkerINTEL")) return (void *)table->CmdSetPerformanceStreamMarkerINTEL;
-    if (!strcmp(name, "CmdSetPerformanceOverrideINTEL")) return (void *)table->CmdSetPerformanceOverrideINTEL;
-    if (!strcmp(name, "AcquirePerformanceConfigurationINTEL")) return (void *)table->AcquirePerformanceConfigurationINTEL;
-    if (!strcmp(name, "ReleasePerformanceConfigurationINTEL")) return (void *)table->ReleasePerformanceConfigurationINTEL;
-    if (!strcmp(name, "QueueSetPerformanceConfigurationINTEL")) return (void *)table->QueueSetPerformanceConfigurationINTEL;
-    if (!strcmp(name, "GetPerformanceParameterINTEL")) return (void *)table->GetPerformanceParameterINTEL;
+    if (nameHash == 0xaaee8606a2f000f3 /* vkInitializePerformanceApiINTEL */) return (void *)table->InitializePerformanceApiINTEL;
+    if (nameHash == 0xef99360f052b923d /* vkUninitializePerformanceApiINTEL */) return (void *)table->UninitializePerformanceApiINTEL;
+    if (nameHash == 0x4888445b33d1d1a9 /* vkCmdSetPerformanceMarkerINTEL */) return (void *)table->CmdSetPerformanceMarkerINTEL;
+    if (nameHash == 0xc0b67df33e46a5f0 /* vkCmdSetPerformanceStreamMarkerINTEL */) return (void *)table->CmdSetPerformanceStreamMarkerINTEL;
+    if (nameHash == 0x81a2503b2e89f09e /* vkCmdSetPerformanceOverrideINTEL */) return (void *)table->CmdSetPerformanceOverrideINTEL;
+    if (nameHash == 0x1173dfede1e58b0e /* vkAcquirePerformanceConfigurationINTEL */) return (void *)table->AcquirePerformanceConfigurationINTEL;
+    if (nameHash == 0x480770881849ff9e /* vkReleasePerformanceConfigurationINTEL */) return (void *)table->ReleasePerformanceConfigurationINTEL;
+    if (nameHash == 0x22611ab44638175f /* vkQueueSetPerformanceConfigurationINTEL */) return (void *)table->QueueSetPerformanceConfigurationINTEL;
+    if (nameHash == 0x49bda364217fc34a /* vkGetPerformanceParameterINTEL */) return (void *)table->GetPerformanceParameterINTEL;
 
     // ---- VK_AMD_display_native_hdr extension commands
-    if (!strcmp(name, "SetLocalDimmingAMD")) return (void *)table->SetLocalDimmingAMD;
+    if (nameHash == 0x7629dff55e4d0af3 /* vkSetLocalDimmingAMD */) return (void *)table->SetLocalDimmingAMD;
 
     // ---- VK_EXT_buffer_device_address extension commands
-    if (!strcmp(name, "GetBufferDeviceAddressEXT")) return (void *)table->GetBufferDeviceAddressEXT;
+    if (nameHash == 0x399268bd1fae323b /* vkGetBufferDeviceAddressEXT */) return (void *)table->GetBufferDeviceAddressEXT;
 
     // ---- VK_EXT_full_screen_exclusive extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "AcquireFullScreenExclusiveModeEXT")) return (void *)table->AcquireFullScreenExclusiveModeEXT;
+    if (nameHash == 0x269c5788bd9937d1 /* vkAcquireFullScreenExclusiveModeEXT */) return (void *)table->AcquireFullScreenExclusiveModeEXT;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "ReleaseFullScreenExclusiveModeEXT")) return (void *)table->ReleaseFullScreenExclusiveModeEXT;
+    if (nameHash == 0xdad4b40f2b59becc /* vkReleaseFullScreenExclusiveModeEXT */) return (void *)table->ReleaseFullScreenExclusiveModeEXT;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "GetDeviceGroupSurfacePresentModes2EXT")) return (void *)table->GetDeviceGroupSurfacePresentModes2EXT;
+    if (nameHash == 0x9166d9b745afd8af /* vkGetDeviceGroupSurfacePresentModes2EXT */) return (void *)table->GetDeviceGroupSurfacePresentModes2EXT;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_EXT_line_rasterization extension commands
-    if (!strcmp(name, "CmdSetLineStippleEXT")) return (void *)table->CmdSetLineStippleEXT;
+    if (nameHash == 0x10cb3a8400778673 /* vkCmdSetLineStippleEXT */) return (void *)table->CmdSetLineStippleEXT;
 
     // ---- VK_EXT_host_query_reset extension commands
-    if (!strcmp(name, "ResetQueryPoolEXT")) return (void *)table->ResetQueryPoolEXT;
+    if (nameHash == 0x40648ed2af7eecdd /* vkResetQueryPoolEXT */) return (void *)table->ResetQueryPoolEXT;
 
     // ---- VK_EXT_extended_dynamic_state extension commands
-    if (!strcmp(name, "CmdSetCullModeEXT")) return (void *)table->CmdSetCullModeEXT;
-    if (!strcmp(name, "CmdSetFrontFaceEXT")) return (void *)table->CmdSetFrontFaceEXT;
-    if (!strcmp(name, "CmdSetPrimitiveTopologyEXT")) return (void *)table->CmdSetPrimitiveTopologyEXT;
-    if (!strcmp(name, "CmdSetViewportWithCountEXT")) return (void *)table->CmdSetViewportWithCountEXT;
-    if (!strcmp(name, "CmdSetScissorWithCountEXT")) return (void *)table->CmdSetScissorWithCountEXT;
-    if (!strcmp(name, "CmdBindVertexBuffers2EXT")) return (void *)table->CmdBindVertexBuffers2EXT;
-    if (!strcmp(name, "CmdSetDepthTestEnableEXT")) return (void *)table->CmdSetDepthTestEnableEXT;
-    if (!strcmp(name, "CmdSetDepthWriteEnableEXT")) return (void *)table->CmdSetDepthWriteEnableEXT;
-    if (!strcmp(name, "CmdSetDepthCompareOpEXT")) return (void *)table->CmdSetDepthCompareOpEXT;
-    if (!strcmp(name, "CmdSetDepthBoundsTestEnableEXT")) return (void *)table->CmdSetDepthBoundsTestEnableEXT;
-    if (!strcmp(name, "CmdSetStencilTestEnableEXT")) return (void *)table->CmdSetStencilTestEnableEXT;
-    if (!strcmp(name, "CmdSetStencilOpEXT")) return (void *)table->CmdSetStencilOpEXT;
+    if (nameHash == 0x8ad52c133e5fcc89 /* vkCmdSetCullModeEXT */) return (void *)table->CmdSetCullModeEXT;
+    if (nameHash == 0x335573b897d8b48c /* vkCmdSetFrontFaceEXT */) return (void *)table->CmdSetFrontFaceEXT;
+    if (nameHash == 0xf991ab3939955de5 /* vkCmdSetPrimitiveTopologyEXT */) return (void *)table->CmdSetPrimitiveTopologyEXT;
+    if (nameHash == 0xffa40d4e01bf3cc0 /* vkCmdSetViewportWithCountEXT */) return (void *)table->CmdSetViewportWithCountEXT;
+    if (nameHash == 0x6aa7b18e001aa3e3 /* vkCmdSetScissorWithCountEXT */) return (void *)table->CmdSetScissorWithCountEXT;
+    if (nameHash == 0x95e7e04ef3cf5655 /* vkCmdBindVertexBuffers2EXT */) return (void *)table->CmdBindVertexBuffers2EXT;
+    if (nameHash == 0xae8baaf2908ad9f8 /* vkCmdSetDepthTestEnableEXT */) return (void *)table->CmdSetDepthTestEnableEXT;
+    if (nameHash == 0x25e2c1a1ae2efd24 /* vkCmdSetDepthWriteEnableEXT */) return (void *)table->CmdSetDepthWriteEnableEXT;
+    if (nameHash == 0xbf39cf164d4f3b71 /* vkCmdSetDepthCompareOpEXT */) return (void *)table->CmdSetDepthCompareOpEXT;
+    if (nameHash == 0x09f73ab4947aa834 /* vkCmdSetDepthBoundsTestEnableEXT */) return (void *)table->CmdSetDepthBoundsTestEnableEXT;
+    if (nameHash == 0xcb818f46817e8697 /* vkCmdSetStencilTestEnableEXT */) return (void *)table->CmdSetStencilTestEnableEXT;
+    if (nameHash == 0x0c7a936d63d4b37e /* vkCmdSetStencilOpEXT */) return (void *)table->CmdSetStencilOpEXT;
 
     // ---- VK_EXT_host_image_copy extension commands
-    if (!strcmp(name, "CopyMemoryToImageEXT")) return (void *)table->CopyMemoryToImageEXT;
-    if (!strcmp(name, "CopyImageToMemoryEXT")) return (void *)table->CopyImageToMemoryEXT;
-    if (!strcmp(name, "CopyImageToImageEXT")) return (void *)table->CopyImageToImageEXT;
-    if (!strcmp(name, "TransitionImageLayoutEXT")) return (void *)table->TransitionImageLayoutEXT;
-    if (!strcmp(name, "GetImageSubresourceLayout2EXT")) return (void *)table->GetImageSubresourceLayout2EXT;
+    if (nameHash == 0x95a0cae5a6723961 /* vkCopyMemoryToImageEXT */) return (void *)table->CopyMemoryToImageEXT;
+    if (nameHash == 0xb1f1669ee2dd4847 /* vkCopyImageToMemoryEXT */) return (void *)table->CopyImageToMemoryEXT;
+    if (nameHash == 0x238991922eb2dc5f /* vkCopyImageToImageEXT */) return (void *)table->CopyImageToImageEXT;
+    if (nameHash == 0x233da64d987f39c6 /* vkTransitionImageLayoutEXT */) return (void *)table->TransitionImageLayoutEXT;
+    if (nameHash == 0x724faacf94fc9fe1 /* vkGetImageSubresourceLayout2EXT */) return (void *)table->GetImageSubresourceLayout2EXT;
 
     // ---- VK_EXT_swapchain_maintenance1 extension commands
-    if (!strcmp(name, "ReleaseSwapchainImagesEXT")) return (void *)table->ReleaseSwapchainImagesEXT;
+    if (nameHash == 0x09e9bc32d119dd75 /* vkReleaseSwapchainImagesEXT */) return (void *)table->ReleaseSwapchainImagesEXT;
 
     // ---- VK_NV_device_generated_commands extension commands
-    if (!strcmp(name, "GetGeneratedCommandsMemoryRequirementsNV")) return (void *)table->GetGeneratedCommandsMemoryRequirementsNV;
-    if (!strcmp(name, "CmdPreprocessGeneratedCommandsNV")) return (void *)table->CmdPreprocessGeneratedCommandsNV;
-    if (!strcmp(name, "CmdExecuteGeneratedCommandsNV")) return (void *)table->CmdExecuteGeneratedCommandsNV;
-    if (!strcmp(name, "CmdBindPipelineShaderGroupNV")) return (void *)table->CmdBindPipelineShaderGroupNV;
-    if (!strcmp(name, "CreateIndirectCommandsLayoutNV")) return (void *)table->CreateIndirectCommandsLayoutNV;
-    if (!strcmp(name, "DestroyIndirectCommandsLayoutNV")) return (void *)table->DestroyIndirectCommandsLayoutNV;
+    if (nameHash == 0x45568382cd976a58 /* vkGetGeneratedCommandsMemoryRequirementsNV */) return (void *)table->GetGeneratedCommandsMemoryRequirementsNV;
+    if (nameHash == 0xbbb204c332bf3b26 /* vkCmdPreprocessGeneratedCommandsNV */) return (void *)table->CmdPreprocessGeneratedCommandsNV;
+    if (nameHash == 0xc7e4fe21b7623076 /* vkCmdExecuteGeneratedCommandsNV */) return (void *)table->CmdExecuteGeneratedCommandsNV;
+    if (nameHash == 0xfb6168e88a9522ee /* vkCmdBindPipelineShaderGroupNV */) return (void *)table->CmdBindPipelineShaderGroupNV;
+    if (nameHash == 0x8977eb367d2cc188 /* vkCreateIndirectCommandsLayoutNV */) return (void *)table->CreateIndirectCommandsLayoutNV;
+    if (nameHash == 0x67d5c823a6e5f838 /* vkDestroyIndirectCommandsLayoutNV */) return (void *)table->DestroyIndirectCommandsLayoutNV;
 
     // ---- VK_EXT_depth_bias_control extension commands
-    if (!strcmp(name, "CmdSetDepthBias2EXT")) return (void *)table->CmdSetDepthBias2EXT;
+    if (nameHash == 0xf1159d930e7b7f9b /* vkCmdSetDepthBias2EXT */) return (void *)table->CmdSetDepthBias2EXT;
 
     // ---- VK_EXT_private_data extension commands
-    if (!strcmp(name, "CreatePrivateDataSlotEXT")) return (void *)table->CreatePrivateDataSlotEXT;
-    if (!strcmp(name, "DestroyPrivateDataSlotEXT")) return (void *)table->DestroyPrivateDataSlotEXT;
-    if (!strcmp(name, "SetPrivateDataEXT")) return (void *)table->SetPrivateDataEXT;
-    if (!strcmp(name, "GetPrivateDataEXT")) return (void *)table->GetPrivateDataEXT;
+    if (nameHash == 0x914ccba5ef3134d3 /* vkCreatePrivateDataSlotEXT */) return (void *)table->CreatePrivateDataSlotEXT;
+    if (nameHash == 0xdce67e01cb34aa72 /* vkDestroyPrivateDataSlotEXT */) return (void *)table->DestroyPrivateDataSlotEXT;
+    if (nameHash == 0xc2f02663a1a88208 /* vkSetPrivateDataEXT */) return (void *)table->SetPrivateDataEXT;
+    if (nameHash == 0x8da528a7d8e71c4a /* vkGetPrivateDataEXT */) return (void *)table->GetPrivateDataEXT;
 
     // ---- VK_NV_cuda_kernel_launch extension commands
-    if (!strcmp(name, "CreateCudaModuleNV")) return (void *)table->CreateCudaModuleNV;
-    if (!strcmp(name, "GetCudaModuleCacheNV")) return (void *)table->GetCudaModuleCacheNV;
-    if (!strcmp(name, "CreateCudaFunctionNV")) return (void *)table->CreateCudaFunctionNV;
-    if (!strcmp(name, "DestroyCudaModuleNV")) return (void *)table->DestroyCudaModuleNV;
-    if (!strcmp(name, "DestroyCudaFunctionNV")) return (void *)table->DestroyCudaFunctionNV;
-    if (!strcmp(name, "CmdCudaLaunchKernelNV")) return (void *)table->CmdCudaLaunchKernelNV;
+    if (nameHash == 0x5f79fd00863c735c /* vkCreateCudaModuleNV */) return (void *)table->CreateCudaModuleNV;
+    if (nameHash == 0x568b92e4b678bc0d /* vkGetCudaModuleCacheNV */) return (void *)table->GetCudaModuleCacheNV;
+    if (nameHash == 0x2959ea9ac9517bb5 /* vkCreateCudaFunctionNV */) return (void *)table->CreateCudaFunctionNV;
+    if (nameHash == 0x46bd70f746f4073f /* vkDestroyCudaModuleNV */) return (void *)table->DestroyCudaModuleNV;
+    if (nameHash == 0xb811d13ae8ba8698 /* vkDestroyCudaFunctionNV */) return (void *)table->DestroyCudaFunctionNV;
+    if (nameHash == 0x9508bfb817e18156 /* vkCmdCudaLaunchKernelNV */) return (void *)table->CmdCudaLaunchKernelNV;
 
     // ---- VK_EXT_metal_objects extension commands
 #if defined(VK_USE_PLATFORM_METAL_EXT)
-    if (!strcmp(name, "ExportMetalObjectsEXT")) return (void *)table->ExportMetalObjectsEXT;
+    if (nameHash == 0xcf18436e233f62fe /* vkExportMetalObjectsEXT */) return (void *)table->ExportMetalObjectsEXT;
 #endif // VK_USE_PLATFORM_METAL_EXT
 
     // ---- VK_EXT_descriptor_buffer extension commands
-    if (!strcmp(name, "GetDescriptorSetLayoutSizeEXT")) return (void *)table->GetDescriptorSetLayoutSizeEXT;
-    if (!strcmp(name, "GetDescriptorSetLayoutBindingOffsetEXT")) return (void *)table->GetDescriptorSetLayoutBindingOffsetEXT;
-    if (!strcmp(name, "GetDescriptorEXT")) return (void *)table->GetDescriptorEXT;
-    if (!strcmp(name, "CmdBindDescriptorBuffersEXT")) return (void *)table->CmdBindDescriptorBuffersEXT;
-    if (!strcmp(name, "CmdSetDescriptorBufferOffsetsEXT")) return (void *)table->CmdSetDescriptorBufferOffsetsEXT;
-    if (!strcmp(name, "CmdBindDescriptorBufferEmbeddedSamplersEXT")) return (void *)table->CmdBindDescriptorBufferEmbeddedSamplersEXT;
-    if (!strcmp(name, "GetBufferOpaqueCaptureDescriptorDataEXT")) return (void *)table->GetBufferOpaqueCaptureDescriptorDataEXT;
-    if (!strcmp(name, "GetImageOpaqueCaptureDescriptorDataEXT")) return (void *)table->GetImageOpaqueCaptureDescriptorDataEXT;
-    if (!strcmp(name, "GetImageViewOpaqueCaptureDescriptorDataEXT")) return (void *)table->GetImageViewOpaqueCaptureDescriptorDataEXT;
-    if (!strcmp(name, "GetSamplerOpaqueCaptureDescriptorDataEXT")) return (void *)table->GetSamplerOpaqueCaptureDescriptorDataEXT;
-    if (!strcmp(name, "GetAccelerationStructureOpaqueCaptureDescriptorDataEXT")) return (void *)table->GetAccelerationStructureOpaqueCaptureDescriptorDataEXT;
+    if (nameHash == 0xb615047d05c91282 /* vkGetDescriptorSetLayoutSizeEXT */) return (void *)table->GetDescriptorSetLayoutSizeEXT;
+    if (nameHash == 0x6688394878be035e /* vkGetDescriptorSetLayoutBindingOffsetEXT */) return (void *)table->GetDescriptorSetLayoutBindingOffsetEXT;
+    if (nameHash == 0x99dfcdbeb70620f3 /* vkGetDescriptorEXT */) return (void *)table->GetDescriptorEXT;
+    if (nameHash == 0xd3d8cd8814a0cdd8 /* vkCmdBindDescriptorBuffersEXT */) return (void *)table->CmdBindDescriptorBuffersEXT;
+    if (nameHash == 0x3cb127add67d0963 /* vkCmdSetDescriptorBufferOffsetsEXT */) return (void *)table->CmdSetDescriptorBufferOffsetsEXT;
+    if (nameHash == 0xc5d77b727d806ce6 /* vkCmdBindDescriptorBufferEmbeddedSamplersEXT */) return (void *)table->CmdBindDescriptorBufferEmbeddedSamplersEXT;
+    if (nameHash == 0x2f2449681e594992 /* vkGetBufferOpaqueCaptureDescriptorDataEXT */) return (void *)table->GetBufferOpaqueCaptureDescriptorDataEXT;
+    if (nameHash == 0x4852117a823da29e /* vkGetImageOpaqueCaptureDescriptorDataEXT */) return (void *)table->GetImageOpaqueCaptureDescriptorDataEXT;
+    if (nameHash == 0x26037ce5b636f47f /* vkGetImageViewOpaqueCaptureDescriptorDataEXT */) return (void *)table->GetImageViewOpaqueCaptureDescriptorDataEXT;
+    if (nameHash == 0x5d99174ab12822bd /* vkGetSamplerOpaqueCaptureDescriptorDataEXT */) return (void *)table->GetSamplerOpaqueCaptureDescriptorDataEXT;
+    if (nameHash == 0x6d4934759c97e7a4 /* vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT */) return (void *)table->GetAccelerationStructureOpaqueCaptureDescriptorDataEXT;
 
     // ---- VK_NV_fragment_shading_rate_enums extension commands
-    if (!strcmp(name, "CmdSetFragmentShadingRateEnumNV")) return (void *)table->CmdSetFragmentShadingRateEnumNV;
+    if (nameHash == 0x86a35fcb0cd25838 /* vkCmdSetFragmentShadingRateEnumNV */) return (void *)table->CmdSetFragmentShadingRateEnumNV;
 
     // ---- VK_EXT_device_fault extension commands
-    if (!strcmp(name, "GetDeviceFaultInfoEXT")) return (void *)table->GetDeviceFaultInfoEXT;
+    if (nameHash == 0x166f6358bfe0fce0 /* vkGetDeviceFaultInfoEXT */) return (void *)table->GetDeviceFaultInfoEXT;
 
     // ---- VK_EXT_vertex_input_dynamic_state extension commands
-    if (!strcmp(name, "CmdSetVertexInputEXT")) return (void *)table->CmdSetVertexInputEXT;
+    if (nameHash == 0x54f4e0d0a5c3dbbf /* vkCmdSetVertexInputEXT */) return (void *)table->CmdSetVertexInputEXT;
 
     // ---- VK_FUCHSIA_external_memory extension commands
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp(name, "GetMemoryZirconHandleFUCHSIA")) return (void *)table->GetMemoryZirconHandleFUCHSIA;
+    if (nameHash == 0xbde4c14636640d82 /* vkGetMemoryZirconHandleFUCHSIA */) return (void *)table->GetMemoryZirconHandleFUCHSIA;
 #endif // VK_USE_PLATFORM_FUCHSIA
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp(name, "GetMemoryZirconHandlePropertiesFUCHSIA")) return (void *)table->GetMemoryZirconHandlePropertiesFUCHSIA;
+    if (nameHash == 0xc77b0aec1b685e42 /* vkGetMemoryZirconHandlePropertiesFUCHSIA */) return (void *)table->GetMemoryZirconHandlePropertiesFUCHSIA;
 #endif // VK_USE_PLATFORM_FUCHSIA
 
     // ---- VK_FUCHSIA_external_semaphore extension commands
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp(name, "ImportSemaphoreZirconHandleFUCHSIA")) return (void *)table->ImportSemaphoreZirconHandleFUCHSIA;
+    if (nameHash == 0x334314efb11c7144 /* vkImportSemaphoreZirconHandleFUCHSIA */) return (void *)table->ImportSemaphoreZirconHandleFUCHSIA;
 #endif // VK_USE_PLATFORM_FUCHSIA
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp(name, "GetSemaphoreZirconHandleFUCHSIA")) return (void *)table->GetSemaphoreZirconHandleFUCHSIA;
+    if (nameHash == 0xb3fc6ad1eebe5d90 /* vkGetSemaphoreZirconHandleFUCHSIA */) return (void *)table->GetSemaphoreZirconHandleFUCHSIA;
 #endif // VK_USE_PLATFORM_FUCHSIA
 
     // ---- VK_FUCHSIA_buffer_collection extension commands
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp(name, "CreateBufferCollectionFUCHSIA")) return (void *)table->CreateBufferCollectionFUCHSIA;
+    if (nameHash == 0xce653760953e9106 /* vkCreateBufferCollectionFUCHSIA */) return (void *)table->CreateBufferCollectionFUCHSIA;
 #endif // VK_USE_PLATFORM_FUCHSIA
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp(name, "SetBufferCollectionImageConstraintsFUCHSIA")) return (void *)table->SetBufferCollectionImageConstraintsFUCHSIA;
+    if (nameHash == 0xd10afc8461e339f2 /* vkSetBufferCollectionImageConstraintsFUCHSIA */) return (void *)table->SetBufferCollectionImageConstraintsFUCHSIA;
 #endif // VK_USE_PLATFORM_FUCHSIA
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp(name, "SetBufferCollectionBufferConstraintsFUCHSIA")) return (void *)table->SetBufferCollectionBufferConstraintsFUCHSIA;
+    if (nameHash == 0x36d94ea1570378f7 /* vkSetBufferCollectionBufferConstraintsFUCHSIA */) return (void *)table->SetBufferCollectionBufferConstraintsFUCHSIA;
 #endif // VK_USE_PLATFORM_FUCHSIA
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp(name, "DestroyBufferCollectionFUCHSIA")) return (void *)table->DestroyBufferCollectionFUCHSIA;
+    if (nameHash == 0xb055e21eec61f87e /* vkDestroyBufferCollectionFUCHSIA */) return (void *)table->DestroyBufferCollectionFUCHSIA;
 #endif // VK_USE_PLATFORM_FUCHSIA
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp(name, "GetBufferCollectionPropertiesFUCHSIA")) return (void *)table->GetBufferCollectionPropertiesFUCHSIA;
+    if (nameHash == 0x2c457bf2268490e8 /* vkGetBufferCollectionPropertiesFUCHSIA */) return (void *)table->GetBufferCollectionPropertiesFUCHSIA;
 #endif // VK_USE_PLATFORM_FUCHSIA
 
     // ---- VK_HUAWEI_subpass_shading extension commands
-    if (!strcmp(name, "GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI")) return (void *)table->GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI;
-    if (!strcmp(name, "CmdSubpassShadingHUAWEI")) return (void *)table->CmdSubpassShadingHUAWEI;
+    if (nameHash == 0xcc38e899cdc6433c /* vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI */) return (void *)table->GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI;
+    if (nameHash == 0x149123ece151c923 /* vkCmdSubpassShadingHUAWEI */) return (void *)table->CmdSubpassShadingHUAWEI;
 
     // ---- VK_HUAWEI_invocation_mask extension commands
-    if (!strcmp(name, "CmdBindInvocationMaskHUAWEI")) return (void *)table->CmdBindInvocationMaskHUAWEI;
+    if (nameHash == 0x5dd077e15ef82882 /* vkCmdBindInvocationMaskHUAWEI */) return (void *)table->CmdBindInvocationMaskHUAWEI;
 
     // ---- VK_NV_external_memory_rdma extension commands
-    if (!strcmp(name, "GetMemoryRemoteAddressNV")) return (void *)table->GetMemoryRemoteAddressNV;
+    if (nameHash == 0x5ee3413a16ecc62a /* vkGetMemoryRemoteAddressNV */) return (void *)table->GetMemoryRemoteAddressNV;
 
     // ---- VK_EXT_pipeline_properties extension commands
-    if (!strcmp(name, "GetPipelinePropertiesEXT")) return (void *)table->GetPipelinePropertiesEXT;
+    if (nameHash == 0x6987d1107990db8b /* vkGetPipelinePropertiesEXT */) return (void *)table->GetPipelinePropertiesEXT;
 
     // ---- VK_EXT_extended_dynamic_state2 extension commands
-    if (!strcmp(name, "CmdSetPatchControlPointsEXT")) return (void *)table->CmdSetPatchControlPointsEXT;
-    if (!strcmp(name, "CmdSetRasterizerDiscardEnableEXT")) return (void *)table->CmdSetRasterizerDiscardEnableEXT;
-    if (!strcmp(name, "CmdSetDepthBiasEnableEXT")) return (void *)table->CmdSetDepthBiasEnableEXT;
-    if (!strcmp(name, "CmdSetLogicOpEXT")) return (void *)table->CmdSetLogicOpEXT;
-    if (!strcmp(name, "CmdSetPrimitiveRestartEnableEXT")) return (void *)table->CmdSetPrimitiveRestartEnableEXT;
+    if (nameHash == 0x77298a207cf7470a /* vkCmdSetPatchControlPointsEXT */) return (void *)table->CmdSetPatchControlPointsEXT;
+    if (nameHash == 0x20e538050b42f767 /* vkCmdSetRasterizerDiscardEnableEXT */) return (void *)table->CmdSetRasterizerDiscardEnableEXT;
+    if (nameHash == 0xafe12b5c094c8aeb /* vkCmdSetDepthBiasEnableEXT */) return (void *)table->CmdSetDepthBiasEnableEXT;
+    if (nameHash == 0x4fdb2f0ce0346b73 /* vkCmdSetLogicOpEXT */) return (void *)table->CmdSetLogicOpEXT;
+    if (nameHash == 0x8debabeca0bc6dd7 /* vkCmdSetPrimitiveRestartEnableEXT */) return (void *)table->CmdSetPrimitiveRestartEnableEXT;
 
     // ---- VK_EXT_color_write_enable extension commands
-    if (!strcmp(name, "CmdSetColorWriteEnableEXT")) return (void *)table->CmdSetColorWriteEnableEXT;
+    if (nameHash == 0xee0c987fe12167e5 /* vkCmdSetColorWriteEnableEXT */) return (void *)table->CmdSetColorWriteEnableEXT;
 
     // ---- VK_EXT_multi_draw extension commands
-    if (!strcmp(name, "CmdDrawMultiEXT")) return (void *)table->CmdDrawMultiEXT;
-    if (!strcmp(name, "CmdDrawMultiIndexedEXT")) return (void *)table->CmdDrawMultiIndexedEXT;
+    if (nameHash == 0x13672ea08d07fa9d /* vkCmdDrawMultiEXT */) return (void *)table->CmdDrawMultiEXT;
+    if (nameHash == 0x15b0ebcd4268ceb0 /* vkCmdDrawMultiIndexedEXT */) return (void *)table->CmdDrawMultiIndexedEXT;
 
     // ---- VK_EXT_opacity_micromap extension commands
-    if (!strcmp(name, "CreateMicromapEXT")) return (void *)table->CreateMicromapEXT;
-    if (!strcmp(name, "DestroyMicromapEXT")) return (void *)table->DestroyMicromapEXT;
-    if (!strcmp(name, "CmdBuildMicromapsEXT")) return (void *)table->CmdBuildMicromapsEXT;
-    if (!strcmp(name, "BuildMicromapsEXT")) return (void *)table->BuildMicromapsEXT;
-    if (!strcmp(name, "CopyMicromapEXT")) return (void *)table->CopyMicromapEXT;
-    if (!strcmp(name, "CopyMicromapToMemoryEXT")) return (void *)table->CopyMicromapToMemoryEXT;
-    if (!strcmp(name, "CopyMemoryToMicromapEXT")) return (void *)table->CopyMemoryToMicromapEXT;
-    if (!strcmp(name, "WriteMicromapsPropertiesEXT")) return (void *)table->WriteMicromapsPropertiesEXT;
-    if (!strcmp(name, "CmdCopyMicromapEXT")) return (void *)table->CmdCopyMicromapEXT;
-    if (!strcmp(name, "CmdCopyMicromapToMemoryEXT")) return (void *)table->CmdCopyMicromapToMemoryEXT;
-    if (!strcmp(name, "CmdCopyMemoryToMicromapEXT")) return (void *)table->CmdCopyMemoryToMicromapEXT;
-    if (!strcmp(name, "CmdWriteMicromapsPropertiesEXT")) return (void *)table->CmdWriteMicromapsPropertiesEXT;
-    if (!strcmp(name, "GetDeviceMicromapCompatibilityEXT")) return (void *)table->GetDeviceMicromapCompatibilityEXT;
-    if (!strcmp(name, "GetMicromapBuildSizesEXT")) return (void *)table->GetMicromapBuildSizesEXT;
+    if (nameHash == 0xb6e8dcebebd08436 /* vkCreateMicromapEXT */) return (void *)table->CreateMicromapEXT;
+    if (nameHash == 0x3a88835e421d53cd /* vkDestroyMicromapEXT */) return (void *)table->DestroyMicromapEXT;
+    if (nameHash == 0xdad7d425257f2349 /* vkCmdBuildMicromapsEXT */) return (void *)table->CmdBuildMicromapsEXT;
+    if (nameHash == 0x31070cdf29394f00 /* vkBuildMicromapsEXT */) return (void *)table->BuildMicromapsEXT;
+    if (nameHash == 0xf39873088d0d505a /* vkCopyMicromapEXT */) return (void *)table->CopyMicromapEXT;
+    if (nameHash == 0x0b4161174ca14c67 /* vkCopyMicromapToMemoryEXT */) return (void *)table->CopyMicromapToMemoryEXT;
+    if (nameHash == 0x19f19eb801eb4fea /* vkCopyMemoryToMicromapEXT */) return (void *)table->CopyMemoryToMicromapEXT;
+    if (nameHash == 0x11a78b6266b8d57c /* vkWriteMicromapsPropertiesEXT */) return (void *)table->WriteMicromapsPropertiesEXT;
+    if (nameHash == 0x07982f27d5cc9e3d /* vkCmdCopyMicromapEXT */) return (void *)table->CmdCopyMicromapEXT;
+    if (nameHash == 0x31241535b9bc3b52 /* vkCmdCopyMicromapToMemoryEXT */) return (void *)table->CmdCopyMicromapToMemoryEXT;
+    if (nameHash == 0x09bcf6218bf7a7cc /* vkCmdCopyMemoryToMicromapEXT */) return (void *)table->CmdCopyMemoryToMicromapEXT;
+    if (nameHash == 0xa966bf46df7237f0 /* vkCmdWriteMicromapsPropertiesEXT */) return (void *)table->CmdWriteMicromapsPropertiesEXT;
+    if (nameHash == 0x4067528a7c46d3d1 /* vkGetDeviceMicromapCompatibilityEXT */) return (void *)table->GetDeviceMicromapCompatibilityEXT;
+    if (nameHash == 0x3683952ff1e39c69 /* vkGetMicromapBuildSizesEXT */) return (void *)table->GetMicromapBuildSizesEXT;
 
     // ---- VK_HUAWEI_cluster_culling_shader extension commands
-    if (!strcmp(name, "CmdDrawClusterHUAWEI")) return (void *)table->CmdDrawClusterHUAWEI;
-    if (!strcmp(name, "CmdDrawClusterIndirectHUAWEI")) return (void *)table->CmdDrawClusterIndirectHUAWEI;
+    if (nameHash == 0xcd3579faa9244fe8 /* vkCmdDrawClusterHUAWEI */) return (void *)table->CmdDrawClusterHUAWEI;
+    if (nameHash == 0x753af4a2035f5325 /* vkCmdDrawClusterIndirectHUAWEI */) return (void *)table->CmdDrawClusterIndirectHUAWEI;
 
     // ---- VK_EXT_pageable_device_local_memory extension commands
-    if (!strcmp(name, "SetDeviceMemoryPriorityEXT")) return (void *)table->SetDeviceMemoryPriorityEXT;
+    if (nameHash == 0x6124012503a7634c /* vkSetDeviceMemoryPriorityEXT */) return (void *)table->SetDeviceMemoryPriorityEXT;
 
     // ---- VK_VALVE_descriptor_set_host_mapping extension commands
-    if (!strcmp(name, "GetDescriptorSetLayoutHostMappingInfoVALVE")) return (void *)table->GetDescriptorSetLayoutHostMappingInfoVALVE;
-    if (!strcmp(name, "GetDescriptorSetHostMappingVALVE")) return (void *)table->GetDescriptorSetHostMappingVALVE;
+    if (nameHash == 0xe67ea7bf4305edd8 /* vkGetDescriptorSetLayoutHostMappingInfoVALVE */) return (void *)table->GetDescriptorSetLayoutHostMappingInfoVALVE;
+    if (nameHash == 0x9d134d5d5df51d6b /* vkGetDescriptorSetHostMappingVALVE */) return (void *)table->GetDescriptorSetHostMappingVALVE;
 
     // ---- VK_NV_copy_memory_indirect extension commands
-    if (!strcmp(name, "CmdCopyMemoryIndirectNV")) return (void *)table->CmdCopyMemoryIndirectNV;
-    if (!strcmp(name, "CmdCopyMemoryToImageIndirectNV")) return (void *)table->CmdCopyMemoryToImageIndirectNV;
+    if (nameHash == 0xea1cabf280ef8b04 /* vkCmdCopyMemoryIndirectNV */) return (void *)table->CmdCopyMemoryIndirectNV;
+    if (nameHash == 0x41a01ed27bc041f2 /* vkCmdCopyMemoryToImageIndirectNV */) return (void *)table->CmdCopyMemoryToImageIndirectNV;
 
     // ---- VK_NV_memory_decompression extension commands
-    if (!strcmp(name, "CmdDecompressMemoryNV")) return (void *)table->CmdDecompressMemoryNV;
-    if (!strcmp(name, "CmdDecompressMemoryIndirectCountNV")) return (void *)table->CmdDecompressMemoryIndirectCountNV;
+    if (nameHash == 0x1c4feae5ecde76d9 /* vkCmdDecompressMemoryNV */) return (void *)table->CmdDecompressMemoryNV;
+    if (nameHash == 0xa9a55fd0d9b55eda /* vkCmdDecompressMemoryIndirectCountNV */) return (void *)table->CmdDecompressMemoryIndirectCountNV;
 
     // ---- VK_NV_device_generated_commands_compute extension commands
-    if (!strcmp(name, "GetPipelineIndirectMemoryRequirementsNV")) return (void *)table->GetPipelineIndirectMemoryRequirementsNV;
-    if (!strcmp(name, "CmdUpdatePipelineIndirectBufferNV")) return (void *)table->CmdUpdatePipelineIndirectBufferNV;
-    if (!strcmp(name, "GetPipelineIndirectDeviceAddressNV")) return (void *)table->GetPipelineIndirectDeviceAddressNV;
+    if (nameHash == 0xd8b91a19d2c84eba /* vkGetPipelineIndirectMemoryRequirementsNV */) return (void *)table->GetPipelineIndirectMemoryRequirementsNV;
+    if (nameHash == 0x59e3b39cfad2a148 /* vkCmdUpdatePipelineIndirectBufferNV */) return (void *)table->CmdUpdatePipelineIndirectBufferNV;
+    if (nameHash == 0x076d9ee8752c3cd2 /* vkGetPipelineIndirectDeviceAddressNV */) return (void *)table->GetPipelineIndirectDeviceAddressNV;
 
     // ---- VK_EXT_extended_dynamic_state3 extension commands
-    if (!strcmp(name, "CmdSetDepthClampEnableEXT")) return (void *)table->CmdSetDepthClampEnableEXT;
-    if (!strcmp(name, "CmdSetPolygonModeEXT")) return (void *)table->CmdSetPolygonModeEXT;
-    if (!strcmp(name, "CmdSetRasterizationSamplesEXT")) return (void *)table->CmdSetRasterizationSamplesEXT;
-    if (!strcmp(name, "CmdSetSampleMaskEXT")) return (void *)table->CmdSetSampleMaskEXT;
-    if (!strcmp(name, "CmdSetAlphaToCoverageEnableEXT")) return (void *)table->CmdSetAlphaToCoverageEnableEXT;
-    if (!strcmp(name, "CmdSetAlphaToOneEnableEXT")) return (void *)table->CmdSetAlphaToOneEnableEXT;
-    if (!strcmp(name, "CmdSetLogicOpEnableEXT")) return (void *)table->CmdSetLogicOpEnableEXT;
-    if (!strcmp(name, "CmdSetColorBlendEnableEXT")) return (void *)table->CmdSetColorBlendEnableEXT;
-    if (!strcmp(name, "CmdSetColorBlendEquationEXT")) return (void *)table->CmdSetColorBlendEquationEXT;
-    if (!strcmp(name, "CmdSetColorWriteMaskEXT")) return (void *)table->CmdSetColorWriteMaskEXT;
-    if (!strcmp(name, "CmdSetTessellationDomainOriginEXT")) return (void *)table->CmdSetTessellationDomainOriginEXT;
-    if (!strcmp(name, "CmdSetRasterizationStreamEXT")) return (void *)table->CmdSetRasterizationStreamEXT;
-    if (!strcmp(name, "CmdSetConservativeRasterizationModeEXT")) return (void *)table->CmdSetConservativeRasterizationModeEXT;
-    if (!strcmp(name, "CmdSetExtraPrimitiveOverestimationSizeEXT")) return (void *)table->CmdSetExtraPrimitiveOverestimationSizeEXT;
-    if (!strcmp(name, "CmdSetDepthClipEnableEXT")) return (void *)table->CmdSetDepthClipEnableEXT;
-    if (!strcmp(name, "CmdSetSampleLocationsEnableEXT")) return (void *)table->CmdSetSampleLocationsEnableEXT;
-    if (!strcmp(name, "CmdSetColorBlendAdvancedEXT")) return (void *)table->CmdSetColorBlendAdvancedEXT;
-    if (!strcmp(name, "CmdSetProvokingVertexModeEXT")) return (void *)table->CmdSetProvokingVertexModeEXT;
-    if (!strcmp(name, "CmdSetLineRasterizationModeEXT")) return (void *)table->CmdSetLineRasterizationModeEXT;
-    if (!strcmp(name, "CmdSetLineStippleEnableEXT")) return (void *)table->CmdSetLineStippleEnableEXT;
-    if (!strcmp(name, "CmdSetDepthClipNegativeOneToOneEXT")) return (void *)table->CmdSetDepthClipNegativeOneToOneEXT;
-    if (!strcmp(name, "CmdSetViewportWScalingEnableNV")) return (void *)table->CmdSetViewportWScalingEnableNV;
-    if (!strcmp(name, "CmdSetViewportSwizzleNV")) return (void *)table->CmdSetViewportSwizzleNV;
-    if (!strcmp(name, "CmdSetCoverageToColorEnableNV")) return (void *)table->CmdSetCoverageToColorEnableNV;
-    if (!strcmp(name, "CmdSetCoverageToColorLocationNV")) return (void *)table->CmdSetCoverageToColorLocationNV;
-    if (!strcmp(name, "CmdSetCoverageModulationModeNV")) return (void *)table->CmdSetCoverageModulationModeNV;
-    if (!strcmp(name, "CmdSetCoverageModulationTableEnableNV")) return (void *)table->CmdSetCoverageModulationTableEnableNV;
-    if (!strcmp(name, "CmdSetCoverageModulationTableNV")) return (void *)table->CmdSetCoverageModulationTableNV;
-    if (!strcmp(name, "CmdSetShadingRateImageEnableNV")) return (void *)table->CmdSetShadingRateImageEnableNV;
-    if (!strcmp(name, "CmdSetRepresentativeFragmentTestEnableNV")) return (void *)table->CmdSetRepresentativeFragmentTestEnableNV;
-    if (!strcmp(name, "CmdSetCoverageReductionModeNV")) return (void *)table->CmdSetCoverageReductionModeNV;
+    if (nameHash == 0x52bc0c7023b88e90 /* vkCmdSetDepthClampEnableEXT */) return (void *)table->CmdSetDepthClampEnableEXT;
+    if (nameHash == 0x48e9ce5a58c1c252 /* vkCmdSetPolygonModeEXT */) return (void *)table->CmdSetPolygonModeEXT;
+    if (nameHash == 0xf02843786e3933f8 /* vkCmdSetRasterizationSamplesEXT */) return (void *)table->CmdSetRasterizationSamplesEXT;
+    if (nameHash == 0x79bbe5a8a2c19b65 /* vkCmdSetSampleMaskEXT */) return (void *)table->CmdSetSampleMaskEXT;
+    if (nameHash == 0x4c351cfa990e9dce /* vkCmdSetAlphaToCoverageEnableEXT */) return (void *)table->CmdSetAlphaToCoverageEnableEXT;
+    if (nameHash == 0x983f1d9254a0a363 /* vkCmdSetAlphaToOneEnableEXT */) return (void *)table->CmdSetAlphaToOneEnableEXT;
+    if (nameHash == 0x735a3459f80339e7 /* vkCmdSetLogicOpEnableEXT */) return (void *)table->CmdSetLogicOpEnableEXT;
+    if (nameHash == 0x17f9a371c7111a63 /* vkCmdSetColorBlendEnableEXT */) return (void *)table->CmdSetColorBlendEnableEXT;
+    if (nameHash == 0x8ada4cd22e8a735c /* vkCmdSetColorBlendEquationEXT */) return (void *)table->CmdSetColorBlendEquationEXT;
+    if (nameHash == 0xe6b91e7965ee4a9f /* vkCmdSetColorWriteMaskEXT */) return (void *)table->CmdSetColorWriteMaskEXT;
+    if (nameHash == 0x4b963cb16d7a5ad8 /* vkCmdSetTessellationDomainOriginEXT */) return (void *)table->CmdSetTessellationDomainOriginEXT;
+    if (nameHash == 0x7b3f73b0c28b9ac0 /* vkCmdSetRasterizationStreamEXT */) return (void *)table->CmdSetRasterizationStreamEXT;
+    if (nameHash == 0x659cd4a0990430f6 /* vkCmdSetConservativeRasterizationModeEXT */) return (void *)table->CmdSetConservativeRasterizationModeEXT;
+    if (nameHash == 0x538223e2090de1df /* vkCmdSetExtraPrimitiveOverestimationSizeEXT */) return (void *)table->CmdSetExtraPrimitiveOverestimationSizeEXT;
+    if (nameHash == 0x172c55dd5dc1bc3a /* vkCmdSetDepthClipEnableEXT */) return (void *)table->CmdSetDepthClipEnableEXT;
+    if (nameHash == 0xcc661f1aee937b88 /* vkCmdSetSampleLocationsEnableEXT */) return (void *)table->CmdSetSampleLocationsEnableEXT;
+    if (nameHash == 0xa0f10e474c7a0e0d /* vkCmdSetColorBlendAdvancedEXT */) return (void *)table->CmdSetColorBlendAdvancedEXT;
+    if (nameHash == 0xadd175019f7d316f /* vkCmdSetProvokingVertexModeEXT */) return (void *)table->CmdSetProvokingVertexModeEXT;
+    if (nameHash == 0xe86e1a671a40b3b7 /* vkCmdSetLineRasterizationModeEXT */) return (void *)table->CmdSetLineRasterizationModeEXT;
+    if (nameHash == 0xa664321f63cd904a /* vkCmdSetLineStippleEnableEXT */) return (void *)table->CmdSetLineStippleEnableEXT;
+    if (nameHash == 0x1def9e89a041b817 /* vkCmdSetDepthClipNegativeOneToOneEXT */) return (void *)table->CmdSetDepthClipNegativeOneToOneEXT;
+    if (nameHash == 0xd35e353760f41c6f /* vkCmdSetViewportWScalingEnableNV */) return (void *)table->CmdSetViewportWScalingEnableNV;
+    if (nameHash == 0xb449b51a1fdae15f /* vkCmdSetViewportSwizzleNV */) return (void *)table->CmdSetViewportSwizzleNV;
+    if (nameHash == 0xe0f1d5482a04901c /* vkCmdSetCoverageToColorEnableNV */) return (void *)table->CmdSetCoverageToColorEnableNV;
+    if (nameHash == 0xfe8be5739d1d70ae /* vkCmdSetCoverageToColorLocationNV */) return (void *)table->CmdSetCoverageToColorLocationNV;
+    if (nameHash == 0x1e31e79e5158a92a /* vkCmdSetCoverageModulationModeNV */) return (void *)table->CmdSetCoverageModulationModeNV;
+    if (nameHash == 0x9b7c9ebe9b147cf1 /* vkCmdSetCoverageModulationTableEnableNV */) return (void *)table->CmdSetCoverageModulationTableEnableNV;
+    if (nameHash == 0xa34e1bfd05275463 /* vkCmdSetCoverageModulationTableNV */) return (void *)table->CmdSetCoverageModulationTableNV;
+    if (nameHash == 0x2ca882d31d4721ba /* vkCmdSetShadingRateImageEnableNV */) return (void *)table->CmdSetShadingRateImageEnableNV;
+    if (nameHash == 0x2b78093ae32cb916 /* vkCmdSetRepresentativeFragmentTestEnableNV */) return (void *)table->CmdSetRepresentativeFragmentTestEnableNV;
+    if (nameHash == 0xc1fb12d42b3f2d2c /* vkCmdSetCoverageReductionModeNV */) return (void *)table->CmdSetCoverageReductionModeNV;
 
     // ---- VK_EXT_shader_module_identifier extension commands
-    if (!strcmp(name, "GetShaderModuleIdentifierEXT")) return (void *)table->GetShaderModuleIdentifierEXT;
-    if (!strcmp(name, "GetShaderModuleCreateInfoIdentifierEXT")) return (void *)table->GetShaderModuleCreateInfoIdentifierEXT;
+    if (nameHash == 0x0602c29db03eb8ab /* vkGetShaderModuleIdentifierEXT */) return (void *)table->GetShaderModuleIdentifierEXT;
+    if (nameHash == 0x2ad0e3cb5f37720f /* vkGetShaderModuleCreateInfoIdentifierEXT */) return (void *)table->GetShaderModuleCreateInfoIdentifierEXT;
 
     // ---- VK_NV_optical_flow extension commands
-    if (!strcmp(name, "CreateOpticalFlowSessionNV")) return (void *)table->CreateOpticalFlowSessionNV;
-    if (!strcmp(name, "DestroyOpticalFlowSessionNV")) return (void *)table->DestroyOpticalFlowSessionNV;
-    if (!strcmp(name, "BindOpticalFlowSessionImageNV")) return (void *)table->BindOpticalFlowSessionImageNV;
-    if (!strcmp(name, "CmdOpticalFlowExecuteNV")) return (void *)table->CmdOpticalFlowExecuteNV;
+    if (nameHash == 0x990606475b0662c9 /* vkCreateOpticalFlowSessionNV */) return (void *)table->CreateOpticalFlowSessionNV;
+    if (nameHash == 0x8eaf0b3e0a85d3bc /* vkDestroyOpticalFlowSessionNV */) return (void *)table->DestroyOpticalFlowSessionNV;
+    if (nameHash == 0x611ba0d146ed962c /* vkBindOpticalFlowSessionImageNV */) return (void *)table->BindOpticalFlowSessionImageNV;
+    if (nameHash == 0xc0130a682397781c /* vkCmdOpticalFlowExecuteNV */) return (void *)table->CmdOpticalFlowExecuteNV;
 
     // ---- VK_AMD_anti_lag extension commands
-    if (!strcmp(name, "AntiLagUpdateAMD")) return (void *)table->AntiLagUpdateAMD;
+    if (nameHash == 0xe06aa3b9e8eeba91 /* vkAntiLagUpdateAMD */) return (void *)table->AntiLagUpdateAMD;
 
     // ---- VK_EXT_shader_object extension commands
-    if (!strcmp(name, "CreateShadersEXT")) return (void *)table->CreateShadersEXT;
-    if (!strcmp(name, "DestroyShaderEXT")) return (void *)table->DestroyShaderEXT;
-    if (!strcmp(name, "GetShaderBinaryDataEXT")) return (void *)table->GetShaderBinaryDataEXT;
-    if (!strcmp(name, "CmdBindShadersEXT")) return (void *)table->CmdBindShadersEXT;
-    if (!strcmp(name, "CmdSetDepthClampRangeEXT")) return (void *)table->CmdSetDepthClampRangeEXT;
+    if (nameHash == 0x5736d06f9f7521f5 /* vkCreateShadersEXT */) return (void *)table->CreateShadersEXT;
+    if (nameHash == 0xb32de6d8d29abe22 /* vkDestroyShaderEXT */) return (void *)table->DestroyShaderEXT;
+    if (nameHash == 0x8b087bf937ffd567 /* vkGetShaderBinaryDataEXT */) return (void *)table->GetShaderBinaryDataEXT;
+    if (nameHash == 0x213f8b33c25f4ec9 /* vkCmdBindShadersEXT */) return (void *)table->CmdBindShadersEXT;
+    if (nameHash == 0x7937cbd95db509a9 /* vkCmdSetDepthClampRangeEXT */) return (void *)table->CmdSetDepthClampRangeEXT;
 
     // ---- VK_QCOM_tile_properties extension commands
-    if (!strcmp(name, "GetFramebufferTilePropertiesQCOM")) return (void *)table->GetFramebufferTilePropertiesQCOM;
-    if (!strcmp(name, "GetDynamicRenderingTilePropertiesQCOM")) return (void *)table->GetDynamicRenderingTilePropertiesQCOM;
+    if (nameHash == 0xbb471ca7efa2efd6 /* vkGetFramebufferTilePropertiesQCOM */) return (void *)table->GetFramebufferTilePropertiesQCOM;
+    if (nameHash == 0xc3d161a58a0be001 /* vkGetDynamicRenderingTilePropertiesQCOM */) return (void *)table->GetDynamicRenderingTilePropertiesQCOM;
 
     // ---- VK_NV_low_latency2 extension commands
-    if (!strcmp(name, "SetLatencySleepModeNV")) return (void *)table->SetLatencySleepModeNV;
-    if (!strcmp(name, "LatencySleepNV")) return (void *)table->LatencySleepNV;
-    if (!strcmp(name, "SetLatencyMarkerNV")) return (void *)table->SetLatencyMarkerNV;
-    if (!strcmp(name, "GetLatencyTimingsNV")) return (void *)table->GetLatencyTimingsNV;
-    if (!strcmp(name, "QueueNotifyOutOfBandNV")) return (void *)table->QueueNotifyOutOfBandNV;
+    if (nameHash == 0xc3167c9cdfe12247 /* vkSetLatencySleepModeNV */) return (void *)table->SetLatencySleepModeNV;
+    if (nameHash == 0x7f231d810d3308b5 /* vkLatencySleepNV */) return (void *)table->LatencySleepNV;
+    if (nameHash == 0x5e82c425367c6366 /* vkSetLatencyMarkerNV */) return (void *)table->SetLatencyMarkerNV;
+    if (nameHash == 0xf1696abc2816c1f0 /* vkGetLatencyTimingsNV */) return (void *)table->GetLatencyTimingsNV;
+    if (nameHash == 0x43962ea5cc322bab /* vkQueueNotifyOutOfBandNV */) return (void *)table->QueueNotifyOutOfBandNV;
 
     // ---- VK_EXT_attachment_feedback_loop_dynamic_state extension commands
-    if (!strcmp(name, "CmdSetAttachmentFeedbackLoopEnableEXT")) return (void *)table->CmdSetAttachmentFeedbackLoopEnableEXT;
+    if (nameHash == 0xd31d2bb517a75484 /* vkCmdSetAttachmentFeedbackLoopEnableEXT */) return (void *)table->CmdSetAttachmentFeedbackLoopEnableEXT;
 
     // ---- VK_QNX_external_memory_screen_buffer extension commands
 #if defined(VK_USE_PLATFORM_SCREEN_QNX)
-    if (!strcmp(name, "GetScreenBufferPropertiesQNX")) return (void *)table->GetScreenBufferPropertiesQNX;
+    if (nameHash == 0xe2152f86c3e27268 /* vkGetScreenBufferPropertiesQNX */) return (void *)table->GetScreenBufferPropertiesQNX;
 #endif // VK_USE_PLATFORM_SCREEN_QNX
 
     // ---- VK_EXT_device_generated_commands extension commands
-    if (!strcmp(name, "GetGeneratedCommandsMemoryRequirementsEXT")) return (void *)table->GetGeneratedCommandsMemoryRequirementsEXT;
-    if (!strcmp(name, "CmdPreprocessGeneratedCommandsEXT")) return (void *)table->CmdPreprocessGeneratedCommandsEXT;
-    if (!strcmp(name, "CmdExecuteGeneratedCommandsEXT")) return (void *)table->CmdExecuteGeneratedCommandsEXT;
-    if (!strcmp(name, "CreateIndirectCommandsLayoutEXT")) return (void *)table->CreateIndirectCommandsLayoutEXT;
-    if (!strcmp(name, "DestroyIndirectCommandsLayoutEXT")) return (void *)table->DestroyIndirectCommandsLayoutEXT;
-    if (!strcmp(name, "CreateIndirectExecutionSetEXT")) return (void *)table->CreateIndirectExecutionSetEXT;
-    if (!strcmp(name, "DestroyIndirectExecutionSetEXT")) return (void *)table->DestroyIndirectExecutionSetEXT;
-    if (!strcmp(name, "UpdateIndirectExecutionSetPipelineEXT")) return (void *)table->UpdateIndirectExecutionSetPipelineEXT;
-    if (!strcmp(name, "UpdateIndirectExecutionSetShaderEXT")) return (void *)table->UpdateIndirectExecutionSetShaderEXT;
+    if (nameHash == 0x0d4c393e3bfb6e8f /* vkGetGeneratedCommandsMemoryRequirementsEXT */) return (void *)table->GetGeneratedCommandsMemoryRequirementsEXT;
+    if (nameHash == 0x37569a6dd4dad322 /* vkCmdPreprocessGeneratedCommandsEXT */) return (void *)table->CmdPreprocessGeneratedCommandsEXT;
+    if (nameHash == 0x95035412cfab2a57 /* vkCmdExecuteGeneratedCommandsEXT */) return (void *)table->CmdExecuteGeneratedCommandsEXT;
+    if (nameHash == 0x8130a83ccd423f02 /* vkCreateIndirectCommandsLayoutEXT */) return (void *)table->CreateIndirectCommandsLayoutEXT;
+    if (nameHash == 0xf9a65ae9b4a10e79 /* vkDestroyIndirectCommandsLayoutEXT */) return (void *)table->DestroyIndirectCommandsLayoutEXT;
+    if (nameHash == 0xb57d926305bc8ed4 /* vkCreateIndirectExecutionSetEXT */) return (void *)table->CreateIndirectExecutionSetEXT;
+    if (nameHash == 0x9cbf04885cb0f4c1 /* vkDestroyIndirectExecutionSetEXT */) return (void *)table->DestroyIndirectExecutionSetEXT;
+    if (nameHash == 0xd74792cfb5d068ce /* vkUpdateIndirectExecutionSetPipelineEXT */) return (void *)table->UpdateIndirectExecutionSetPipelineEXT;
+    if (nameHash == 0xf9df59021b7985d5 /* vkUpdateIndirectExecutionSetShaderEXT */) return (void *)table->UpdateIndirectExecutionSetShaderEXT;
 
     // ---- VK_KHR_acceleration_structure extension commands
-    if (!strcmp(name, "CreateAccelerationStructureKHR")) return (void *)table->CreateAccelerationStructureKHR;
-    if (!strcmp(name, "DestroyAccelerationStructureKHR")) return (void *)table->DestroyAccelerationStructureKHR;
-    if (!strcmp(name, "CmdBuildAccelerationStructuresKHR")) return (void *)table->CmdBuildAccelerationStructuresKHR;
-    if (!strcmp(name, "CmdBuildAccelerationStructuresIndirectKHR")) return (void *)table->CmdBuildAccelerationStructuresIndirectKHR;
-    if (!strcmp(name, "BuildAccelerationStructuresKHR")) return (void *)table->BuildAccelerationStructuresKHR;
-    if (!strcmp(name, "CopyAccelerationStructureKHR")) return (void *)table->CopyAccelerationStructureKHR;
-    if (!strcmp(name, "CopyAccelerationStructureToMemoryKHR")) return (void *)table->CopyAccelerationStructureToMemoryKHR;
-    if (!strcmp(name, "CopyMemoryToAccelerationStructureKHR")) return (void *)table->CopyMemoryToAccelerationStructureKHR;
-    if (!strcmp(name, "WriteAccelerationStructuresPropertiesKHR")) return (void *)table->WriteAccelerationStructuresPropertiesKHR;
-    if (!strcmp(name, "CmdCopyAccelerationStructureKHR")) return (void *)table->CmdCopyAccelerationStructureKHR;
-    if (!strcmp(name, "CmdCopyAccelerationStructureToMemoryKHR")) return (void *)table->CmdCopyAccelerationStructureToMemoryKHR;
-    if (!strcmp(name, "CmdCopyMemoryToAccelerationStructureKHR")) return (void *)table->CmdCopyMemoryToAccelerationStructureKHR;
-    if (!strcmp(name, "GetAccelerationStructureDeviceAddressKHR")) return (void *)table->GetAccelerationStructureDeviceAddressKHR;
-    if (!strcmp(name, "CmdWriteAccelerationStructuresPropertiesKHR")) return (void *)table->CmdWriteAccelerationStructuresPropertiesKHR;
-    if (!strcmp(name, "GetDeviceAccelerationStructureCompatibilityKHR")) return (void *)table->GetDeviceAccelerationStructureCompatibilityKHR;
-    if (!strcmp(name, "GetAccelerationStructureBuildSizesKHR")) return (void *)table->GetAccelerationStructureBuildSizesKHR;
+    if (nameHash == 0x452970172a23c174 /* vkCreateAccelerationStructureKHR */) return (void *)table->CreateAccelerationStructureKHR;
+    if (nameHash == 0xd536d860a73cf116 /* vkDestroyAccelerationStructureKHR */) return (void *)table->DestroyAccelerationStructureKHR;
+    if (nameHash == 0x56e0a0791533454f /* vkCmdBuildAccelerationStructuresKHR */) return (void *)table->CmdBuildAccelerationStructuresKHR;
+    if (nameHash == 0xa99627a28d359157 /* vkCmdBuildAccelerationStructuresIndirectKHR */) return (void *)table->CmdBuildAccelerationStructuresIndirectKHR;
+    if (nameHash == 0x2d831a042e0d1b62 /* vkBuildAccelerationStructuresKHR */) return (void *)table->BuildAccelerationStructuresKHR;
+    if (nameHash == 0x5ad7e13a5109c73a /* vkCopyAccelerationStructureKHR */) return (void *)table->CopyAccelerationStructureKHR;
+    if (nameHash == 0xe43e1298ce6a3bfe /* vkCopyAccelerationStructureToMemoryKHR */) return (void *)table->CopyAccelerationStructureToMemoryKHR;
+    if (nameHash == 0x2ed27a2c09707e8c /* vkCopyMemoryToAccelerationStructureKHR */) return (void *)table->CopyMemoryToAccelerationStructureKHR;
+    if (nameHash == 0xbe6ba58fe9b83a9f /* vkWriteAccelerationStructuresPropertiesKHR */) return (void *)table->WriteAccelerationStructuresPropertiesKHR;
+    if (nameHash == 0x338a1ed4b2ca0c7a /* vkCmdCopyAccelerationStructureKHR */) return (void *)table->CmdCopyAccelerationStructureKHR;
+    if (nameHash == 0xc73b61c79b859a21 /* vkCmdCopyAccelerationStructureToMemoryKHR */) return (void *)table->CmdCopyAccelerationStructureToMemoryKHR;
+    if (nameHash == 0xc24235cf58916cb3 /* vkCmdCopyMemoryToAccelerationStructureKHR */) return (void *)table->CmdCopyMemoryToAccelerationStructureKHR;
+    if (nameHash == 0x85a37e4af2a5d369 /* vkGetAccelerationStructureDeviceAddressKHR */) return (void *)table->GetAccelerationStructureDeviceAddressKHR;
+    if (nameHash == 0xe9afc748cd05801d /* vkCmdWriteAccelerationStructuresPropertiesKHR */) return (void *)table->CmdWriteAccelerationStructuresPropertiesKHR;
+    if (nameHash == 0xf88aec90a89de0da /* vkGetDeviceAccelerationStructureCompatibilityKHR */) return (void *)table->GetDeviceAccelerationStructureCompatibilityKHR;
+    if (nameHash == 0x6c52ced389956a1d /* vkGetAccelerationStructureBuildSizesKHR */) return (void *)table->GetAccelerationStructureBuildSizesKHR;
 
     // ---- VK_KHR_ray_tracing_pipeline extension commands
-    if (!strcmp(name, "CmdTraceRaysKHR")) return (void *)table->CmdTraceRaysKHR;
-    if (!strcmp(name, "CreateRayTracingPipelinesKHR")) return (void *)table->CreateRayTracingPipelinesKHR;
-    if (!strcmp(name, "GetRayTracingCaptureReplayShaderGroupHandlesKHR")) return (void *)table->GetRayTracingCaptureReplayShaderGroupHandlesKHR;
-    if (!strcmp(name, "CmdTraceRaysIndirectKHR")) return (void *)table->CmdTraceRaysIndirectKHR;
-    if (!strcmp(name, "GetRayTracingShaderGroupStackSizeKHR")) return (void *)table->GetRayTracingShaderGroupStackSizeKHR;
-    if (!strcmp(name, "CmdSetRayTracingPipelineStackSizeKHR")) return (void *)table->CmdSetRayTracingPipelineStackSizeKHR;
+    if (nameHash == 0x71d79d686f22d526 /* vkCmdTraceRaysKHR */) return (void *)table->CmdTraceRaysKHR;
+    if (nameHash == 0x1be0142d7b82c8c3 /* vkCreateRayTracingPipelinesKHR */) return (void *)table->CreateRayTracingPipelinesKHR;
+    if (nameHash == 0x860a89bcaf7d40af /* vkGetRayTracingCaptureReplayShaderGroupHandlesKHR */) return (void *)table->GetRayTracingCaptureReplayShaderGroupHandlesKHR;
+    if (nameHash == 0xc1239f4d94d0ccd5 /* vkCmdTraceRaysIndirectKHR */) return (void *)table->CmdTraceRaysIndirectKHR;
+    if (nameHash == 0xdd609c8b8fed0093 /* vkGetRayTracingShaderGroupStackSizeKHR */) return (void *)table->GetRayTracingShaderGroupStackSizeKHR;
+    if (nameHash == 0x20e1f9030911f404 /* vkCmdSetRayTracingPipelineStackSizeKHR */) return (void *)table->CmdSetRayTracingPipelineStackSizeKHR;
 
     // ---- VK_EXT_mesh_shader extension commands
-    if (!strcmp(name, "CmdDrawMeshTasksEXT")) return (void *)table->CmdDrawMeshTasksEXT;
-    if (!strcmp(name, "CmdDrawMeshTasksIndirectEXT")) return (void *)table->CmdDrawMeshTasksIndirectEXT;
-    if (!strcmp(name, "CmdDrawMeshTasksIndirectCountEXT")) return (void *)table->CmdDrawMeshTasksIndirectCountEXT;
+    if (nameHash == 0x1660d6d65602a1e2 /* vkCmdDrawMeshTasksEXT */) return (void *)table->CmdDrawMeshTasksEXT;
+    if (nameHash == 0x94400ae778a5a963 /* vkCmdDrawMeshTasksIndirectEXT */) return (void *)table->CmdDrawMeshTasksIndirectEXT;
+    if (nameHash == 0x3ac504ab87b15a1d /* vkCmdDrawMeshTasksIndirectCountEXT */) return (void *)table->CmdDrawMeshTasksIndirectCountEXT;
 
     *found_name = false;
     return NULL;
@@ -3112,265 +3113,265 @@ VKAPI_ATTR void* VKAPI_CALL loader_lookup_device_dispatch_table(const VkLayerDis
 
 // Instance command lookup function
 VKAPI_ATTR void* VKAPI_CALL loader_lookup_instance_dispatch_table(const VkLayerInstanceDispatchTable *table, const char *name,
-                                                                 bool *found_name) {
+                                                                  uint64_t nameHash, bool *found_name) {
     if (!name || name[0] != 'v' || name[1] != 'k') {
         *found_name = false;
         return NULL;
     }
 
     *found_name = true;
-    name += 2;
+
 
     // ---- Core Vulkan 1.0 commands
-    if (!strcmp(name, "DestroyInstance")) return (void *)table->DestroyInstance;
-    if (!strcmp(name, "EnumeratePhysicalDevices")) return (void *)table->EnumeratePhysicalDevices;
-    if (!strcmp(name, "GetPhysicalDeviceFeatures")) return (void *)table->GetPhysicalDeviceFeatures;
-    if (!strcmp(name, "GetPhysicalDeviceFormatProperties")) return (void *)table->GetPhysicalDeviceFormatProperties;
-    if (!strcmp(name, "GetPhysicalDeviceImageFormatProperties")) return (void *)table->GetPhysicalDeviceImageFormatProperties;
-    if (!strcmp(name, "GetPhysicalDeviceProperties")) return (void *)table->GetPhysicalDeviceProperties;
-    if (!strcmp(name, "GetPhysicalDeviceQueueFamilyProperties")) return (void *)table->GetPhysicalDeviceQueueFamilyProperties;
-    if (!strcmp(name, "GetPhysicalDeviceMemoryProperties")) return (void *)table->GetPhysicalDeviceMemoryProperties;
-    if (!strcmp(name, "GetInstanceProcAddr")) return (void *)table->GetInstanceProcAddr;
-    if (!strcmp(name, "EnumerateDeviceExtensionProperties")) return (void *)table->EnumerateDeviceExtensionProperties;
-    if (!strcmp(name, "EnumerateDeviceLayerProperties")) return (void *)table->EnumerateDeviceLayerProperties;
-    if (!strcmp(name, "GetPhysicalDeviceSparseImageFormatProperties")) return (void *)table->GetPhysicalDeviceSparseImageFormatProperties;
+    if (nameHash == 0x698f41e6299f30d2 /* vkDestroyInstance */) return (void *)table->DestroyInstance;
+    if (nameHash == 0x18d0a02e3ba007fe /* vkEnumeratePhysicalDevices */) return (void *)table->EnumeratePhysicalDevices;
+    if (nameHash == 0xaf9743132d216c3f /* vkGetPhysicalDeviceFeatures */) return (void *)table->GetPhysicalDeviceFeatures;
+    if (nameHash == 0x39eec9d5f829fd31 /* vkGetPhysicalDeviceFormatProperties */) return (void *)table->GetPhysicalDeviceFormatProperties;
+    if (nameHash == 0x4a1ca0b582a457c0 /* vkGetPhysicalDeviceImageFormatProperties */) return (void *)table->GetPhysicalDeviceImageFormatProperties;
+    if (nameHash == 0xdf1e5a19dae9208b /* vkGetPhysicalDeviceProperties */) return (void *)table->GetPhysicalDeviceProperties;
+    if (nameHash == 0x736479d9aaecd06e /* vkGetPhysicalDeviceQueueFamilyProperties */) return (void *)table->GetPhysicalDeviceQueueFamilyProperties;
+    if (nameHash == 0x80666bfa24dd996f /* vkGetPhysicalDeviceMemoryProperties */) return (void *)table->GetPhysicalDeviceMemoryProperties;
+    if (nameHash == 0xbdf594b7ae4af921 /* vkGetInstanceProcAddr */) return (void *)table->GetInstanceProcAddr;
+    if (nameHash == 0x38ad6b820ca1b604 /* vkEnumerateDeviceExtensionProperties */) return (void *)table->EnumerateDeviceExtensionProperties;
+    if (nameHash == 0x0d1d0e6ec5e20528 /* vkEnumerateDeviceLayerProperties */) return (void *)table->EnumerateDeviceLayerProperties;
+    if (nameHash == 0x9ce9a534a3acc808 /* vkGetPhysicalDeviceSparseImageFormatProperties */) return (void *)table->GetPhysicalDeviceSparseImageFormatProperties;
 
     // ---- Core Vulkan 1.1 commands
-    if (!strcmp(name, "EnumeratePhysicalDeviceGroups")) return (void *)table->EnumeratePhysicalDeviceGroups;
-    if (!strcmp(name, "GetPhysicalDeviceFeatures2")) return (void *)table->GetPhysicalDeviceFeatures2;
-    if (!strcmp(name, "GetPhysicalDeviceProperties2")) return (void *)table->GetPhysicalDeviceProperties2;
-    if (!strcmp(name, "GetPhysicalDeviceFormatProperties2")) return (void *)table->GetPhysicalDeviceFormatProperties2;
-    if (!strcmp(name, "GetPhysicalDeviceImageFormatProperties2")) return (void *)table->GetPhysicalDeviceImageFormatProperties2;
-    if (!strcmp(name, "GetPhysicalDeviceQueueFamilyProperties2")) return (void *)table->GetPhysicalDeviceQueueFamilyProperties2;
-    if (!strcmp(name, "GetPhysicalDeviceMemoryProperties2")) return (void *)table->GetPhysicalDeviceMemoryProperties2;
-    if (!strcmp(name, "GetPhysicalDeviceSparseImageFormatProperties2")) return (void *)table->GetPhysicalDeviceSparseImageFormatProperties2;
-    if (!strcmp(name, "GetPhysicalDeviceExternalBufferProperties")) return (void *)table->GetPhysicalDeviceExternalBufferProperties;
-    if (!strcmp(name, "GetPhysicalDeviceExternalFenceProperties")) return (void *)table->GetPhysicalDeviceExternalFenceProperties;
-    if (!strcmp(name, "GetPhysicalDeviceExternalSemaphoreProperties")) return (void *)table->GetPhysicalDeviceExternalSemaphoreProperties;
+    if (nameHash == 0x606f8ae1aaacec90 /* vkEnumeratePhysicalDeviceGroups */) return (void *)table->EnumeratePhysicalDeviceGroups;
+    if (nameHash == 0x5dca2dd1ea6654ee /* vkGetPhysicalDeviceFeatures2 */) return (void *)table->GetPhysicalDeviceFeatures2;
+    if (nameHash == 0xd36fa6a24fe70f58 /* vkGetPhysicalDeviceProperties2 */) return (void *)table->GetPhysicalDeviceProperties2;
+    if (nameHash == 0x53d1f58fd7e7558c /* vkGetPhysicalDeviceFormatProperties2 */) return (void *)table->GetPhysicalDeviceFormatProperties2;
+    if (nameHash == 0xdfeb05796ee61f38 /* vkGetPhysicalDeviceImageFormatProperties2 */) return (void *)table->GetPhysicalDeviceImageFormatProperties2;
+    if (nameHash == 0x5e3c48604b7158a4 /* vkGetPhysicalDeviceQueueFamilyProperties2 */) return (void *)table->GetPhysicalDeviceQueueFamilyProperties2;
+    if (nameHash == 0xc92b2f5a154a828d /* vkGetPhysicalDeviceMemoryProperties2 */) return (void *)table->GetPhysicalDeviceMemoryProperties2;
+    if (nameHash == 0x9338d10ef240c729 /* vkGetPhysicalDeviceSparseImageFormatProperties2 */) return (void *)table->GetPhysicalDeviceSparseImageFormatProperties2;
+    if (nameHash == 0x9d45d6ceeb54540f /* vkGetPhysicalDeviceExternalBufferProperties */) return (void *)table->GetPhysicalDeviceExternalBufferProperties;
+    if (nameHash == 0xdf03aa8b036d5b06 /* vkGetPhysicalDeviceExternalFenceProperties */) return (void *)table->GetPhysicalDeviceExternalFenceProperties;
+    if (nameHash == 0xd7c941518fd0e818 /* vkGetPhysicalDeviceExternalSemaphoreProperties */) return (void *)table->GetPhysicalDeviceExternalSemaphoreProperties;
 
     // ---- Core Vulkan 1.3 commands
-    if (!strcmp(name, "GetPhysicalDeviceToolProperties")) return (void *)table->GetPhysicalDeviceToolProperties;
+    if (nameHash == 0xf14ce64102b8eced /* vkGetPhysicalDeviceToolProperties */) return (void *)table->GetPhysicalDeviceToolProperties;
 
     // ---- VK_KHR_surface extension commands
-    if (!strcmp(name, "DestroySurfaceKHR")) return (void *)table->DestroySurfaceKHR;
-    if (!strcmp(name, "GetPhysicalDeviceSurfaceSupportKHR")) return (void *)table->GetPhysicalDeviceSurfaceSupportKHR;
-    if (!strcmp(name, "GetPhysicalDeviceSurfaceCapabilitiesKHR")) return (void *)table->GetPhysicalDeviceSurfaceCapabilitiesKHR;
-    if (!strcmp(name, "GetPhysicalDeviceSurfaceFormatsKHR")) return (void *)table->GetPhysicalDeviceSurfaceFormatsKHR;
-    if (!strcmp(name, "GetPhysicalDeviceSurfacePresentModesKHR")) return (void *)table->GetPhysicalDeviceSurfacePresentModesKHR;
+    if (nameHash == 0xb746a730e03f945f /* vkDestroySurfaceKHR */) return (void *)table->DestroySurfaceKHR;
+    if (nameHash == 0xfa972e7a0d03ee3c /* vkGetPhysicalDeviceSurfaceSupportKHR */) return (void *)table->GetPhysicalDeviceSurfaceSupportKHR;
+    if (nameHash == 0x70e6e260c2fba0f4 /* vkGetPhysicalDeviceSurfaceCapabilitiesKHR */) return (void *)table->GetPhysicalDeviceSurfaceCapabilitiesKHR;
+    if (nameHash == 0x3c043f25e88ad467 /* vkGetPhysicalDeviceSurfaceFormatsKHR */) return (void *)table->GetPhysicalDeviceSurfaceFormatsKHR;
+    if (nameHash == 0x52d4fff81b4ea8de /* vkGetPhysicalDeviceSurfacePresentModesKHR */) return (void *)table->GetPhysicalDeviceSurfacePresentModesKHR;
 
     // ---- VK_KHR_swapchain extension commands
-    if (!strcmp(name, "GetPhysicalDevicePresentRectanglesKHR")) return (void *)table->GetPhysicalDevicePresentRectanglesKHR;
+    if (nameHash == 0xadec6ca4a17a30f5 /* vkGetPhysicalDevicePresentRectanglesKHR */) return (void *)table->GetPhysicalDevicePresentRectanglesKHR;
 
     // ---- VK_KHR_display extension commands
-    if (!strcmp(name, "GetPhysicalDeviceDisplayPropertiesKHR")) return (void *)table->GetPhysicalDeviceDisplayPropertiesKHR;
-    if (!strcmp(name, "GetPhysicalDeviceDisplayPlanePropertiesKHR")) return (void *)table->GetPhysicalDeviceDisplayPlanePropertiesKHR;
-    if (!strcmp(name, "GetDisplayPlaneSupportedDisplaysKHR")) return (void *)table->GetDisplayPlaneSupportedDisplaysKHR;
-    if (!strcmp(name, "GetDisplayModePropertiesKHR")) return (void *)table->GetDisplayModePropertiesKHR;
-    if (!strcmp(name, "CreateDisplayModeKHR")) return (void *)table->CreateDisplayModeKHR;
-    if (!strcmp(name, "GetDisplayPlaneCapabilitiesKHR")) return (void *)table->GetDisplayPlaneCapabilitiesKHR;
-    if (!strcmp(name, "CreateDisplayPlaneSurfaceKHR")) return (void *)table->CreateDisplayPlaneSurfaceKHR;
+    if (nameHash == 0x69ef92b3a62ea127 /* vkGetPhysicalDeviceDisplayPropertiesKHR */) return (void *)table->GetPhysicalDeviceDisplayPropertiesKHR;
+    if (nameHash == 0x825cde4b6e7e00ea /* vkGetPhysicalDeviceDisplayPlanePropertiesKHR */) return (void *)table->GetPhysicalDeviceDisplayPlanePropertiesKHR;
+    if (nameHash == 0x43524692a7f3408b /* vkGetDisplayPlaneSupportedDisplaysKHR */) return (void *)table->GetDisplayPlaneSupportedDisplaysKHR;
+    if (nameHash == 0x0f4117dbba29bc3a /* vkGetDisplayModePropertiesKHR */) return (void *)table->GetDisplayModePropertiesKHR;
+    if (nameHash == 0xade0cf089ad306ef /* vkCreateDisplayModeKHR */) return (void *)table->CreateDisplayModeKHR;
+    if (nameHash == 0x0e00b79e53c7512d /* vkGetDisplayPlaneCapabilitiesKHR */) return (void *)table->GetDisplayPlaneCapabilitiesKHR;
+    if (nameHash == 0xe8d5da825e49ede6 /* vkCreateDisplayPlaneSurfaceKHR */) return (void *)table->CreateDisplayPlaneSurfaceKHR;
 
     // ---- VK_KHR_xlib_surface extension commands
 #if defined(VK_USE_PLATFORM_XLIB_KHR)
-    if (!strcmp(name, "CreateXlibSurfaceKHR")) return (void *)table->CreateXlibSurfaceKHR;
+    if (nameHash == 0xf2f37645ab938329 /* vkCreateXlibSurfaceKHR */) return (void *)table->CreateXlibSurfaceKHR;
 #endif // VK_USE_PLATFORM_XLIB_KHR
 #if defined(VK_USE_PLATFORM_XLIB_KHR)
-    if (!strcmp(name, "GetPhysicalDeviceXlibPresentationSupportKHR")) return (void *)table->GetPhysicalDeviceXlibPresentationSupportKHR;
+    if (nameHash == 0x45ce665f079d08ec /* vkGetPhysicalDeviceXlibPresentationSupportKHR */) return (void *)table->GetPhysicalDeviceXlibPresentationSupportKHR;
 #endif // VK_USE_PLATFORM_XLIB_KHR
 
     // ---- VK_KHR_xcb_surface extension commands
 #if defined(VK_USE_PLATFORM_XCB_KHR)
-    if (!strcmp(name, "CreateXcbSurfaceKHR")) return (void *)table->CreateXcbSurfaceKHR;
+    if (nameHash == 0xc8b1c23e6174b64b /* vkCreateXcbSurfaceKHR */) return (void *)table->CreateXcbSurfaceKHR;
 #endif // VK_USE_PLATFORM_XCB_KHR
 #if defined(VK_USE_PLATFORM_XCB_KHR)
-    if (!strcmp(name, "GetPhysicalDeviceXcbPresentationSupportKHR")) return (void *)table->GetPhysicalDeviceXcbPresentationSupportKHR;
+    if (nameHash == 0x01628e687379a800 /* vkGetPhysicalDeviceXcbPresentationSupportKHR */) return (void *)table->GetPhysicalDeviceXcbPresentationSupportKHR;
 #endif // VK_USE_PLATFORM_XCB_KHR
 
     // ---- VK_KHR_wayland_surface extension commands
 #if defined(VK_USE_PLATFORM_WAYLAND_KHR)
-    if (!strcmp(name, "CreateWaylandSurfaceKHR")) return (void *)table->CreateWaylandSurfaceKHR;
+    if (nameHash == 0x2bcf2ad912ad48a3 /* vkCreateWaylandSurfaceKHR */) return (void *)table->CreateWaylandSurfaceKHR;
 #endif // VK_USE_PLATFORM_WAYLAND_KHR
 #if defined(VK_USE_PLATFORM_WAYLAND_KHR)
-    if (!strcmp(name, "GetPhysicalDeviceWaylandPresentationSupportKHR")) return (void *)table->GetPhysicalDeviceWaylandPresentationSupportKHR;
+    if (nameHash == 0xd40235c9cab9b686 /* vkGetPhysicalDeviceWaylandPresentationSupportKHR */) return (void *)table->GetPhysicalDeviceWaylandPresentationSupportKHR;
 #endif // VK_USE_PLATFORM_WAYLAND_KHR
 
     // ---- VK_KHR_android_surface extension commands
 #if defined(VK_USE_PLATFORM_ANDROID_KHR)
-    if (!strcmp(name, "CreateAndroidSurfaceKHR")) return (void *)table->CreateAndroidSurfaceKHR;
+    if (nameHash == 0xff2edfe5fb33ed95 /* vkCreateAndroidSurfaceKHR */) return (void *)table->CreateAndroidSurfaceKHR;
 #endif // VK_USE_PLATFORM_ANDROID_KHR
 
     // ---- VK_KHR_win32_surface extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "CreateWin32SurfaceKHR")) return (void *)table->CreateWin32SurfaceKHR;
+    if (nameHash == 0xd6fbb1a654e70656 /* vkCreateWin32SurfaceKHR */) return (void *)table->CreateWin32SurfaceKHR;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "GetPhysicalDeviceWin32PresentationSupportKHR")) return (void *)table->GetPhysicalDeviceWin32PresentationSupportKHR;
+    if (nameHash == 0x148832c9169f3e74 /* vkGetPhysicalDeviceWin32PresentationSupportKHR */) return (void *)table->GetPhysicalDeviceWin32PresentationSupportKHR;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_KHR_video_queue extension commands
-    if (!strcmp(name, "GetPhysicalDeviceVideoCapabilitiesKHR")) return (void *)table->GetPhysicalDeviceVideoCapabilitiesKHR;
-    if (!strcmp(name, "GetPhysicalDeviceVideoFormatPropertiesKHR")) return (void *)table->GetPhysicalDeviceVideoFormatPropertiesKHR;
+    if (nameHash == 0x2517bce1d06e4a03 /* vkGetPhysicalDeviceVideoCapabilitiesKHR */) return (void *)table->GetPhysicalDeviceVideoCapabilitiesKHR;
+    if (nameHash == 0xb55826fa36b0b298 /* vkGetPhysicalDeviceVideoFormatPropertiesKHR */) return (void *)table->GetPhysicalDeviceVideoFormatPropertiesKHR;
 
     // ---- VK_KHR_get_physical_device_properties2 extension commands
-    if (!strcmp(name, "GetPhysicalDeviceFeatures2KHR")) return (void *)table->GetPhysicalDeviceFeatures2KHR;
-    if (!strcmp(name, "GetPhysicalDeviceProperties2KHR")) return (void *)table->GetPhysicalDeviceProperties2KHR;
-    if (!strcmp(name, "GetPhysicalDeviceFormatProperties2KHR")) return (void *)table->GetPhysicalDeviceFormatProperties2KHR;
-    if (!strcmp(name, "GetPhysicalDeviceImageFormatProperties2KHR")) return (void *)table->GetPhysicalDeviceImageFormatProperties2KHR;
-    if (!strcmp(name, "GetPhysicalDeviceQueueFamilyProperties2KHR")) return (void *)table->GetPhysicalDeviceQueueFamilyProperties2KHR;
-    if (!strcmp(name, "GetPhysicalDeviceMemoryProperties2KHR")) return (void *)table->GetPhysicalDeviceMemoryProperties2KHR;
-    if (!strcmp(name, "GetPhysicalDeviceSparseImageFormatProperties2KHR")) return (void *)table->GetPhysicalDeviceSparseImageFormatProperties2KHR;
+    if (nameHash == 0x271fe9077ef533d1 /* vkGetPhysicalDeviceFeatures2KHR */) return (void *)table->GetPhysicalDeviceFeatures2KHR;
+    if (nameHash == 0x3acc37b403e87ac3 /* vkGetPhysicalDeviceProperties2KHR */) return (void *)table->GetPhysicalDeviceProperties2KHR;
+    if (nameHash == 0x39fbee03ddc7e70e /* vkGetPhysicalDeviceFormatProperties2KHR */) return (void *)table->GetPhysicalDeviceFormatProperties2KHR;
+    if (nameHash == 0xc0305d666c70b81b /* vkGetPhysicalDeviceImageFormatProperties2KHR */) return (void *)table->GetPhysicalDeviceImageFormatProperties2KHR;
+    if (nameHash == 0x435d49e0c9740090 /* vkGetPhysicalDeviceQueueFamilyProperties2KHR */) return (void *)table->GetPhysicalDeviceQueueFamilyProperties2KHR;
+    if (nameHash == 0xd6701419da6617d4 /* vkGetPhysicalDeviceMemoryProperties2KHR */) return (void *)table->GetPhysicalDeviceMemoryProperties2KHR;
+    if (nameHash == 0xc79bcf369fe8ca6e /* vkGetPhysicalDeviceSparseImageFormatProperties2KHR */) return (void *)table->GetPhysicalDeviceSparseImageFormatProperties2KHR;
 
     // ---- VK_KHR_device_group_creation extension commands
-    if (!strcmp(name, "EnumeratePhysicalDeviceGroupsKHR")) return (void *)table->EnumeratePhysicalDeviceGroupsKHR;
+    if (nameHash == 0x52e6981b035c87fe /* vkEnumeratePhysicalDeviceGroupsKHR */) return (void *)table->EnumeratePhysicalDeviceGroupsKHR;
 
     // ---- VK_KHR_external_memory_capabilities extension commands
-    if (!strcmp(name, "GetPhysicalDeviceExternalBufferPropertiesKHR")) return (void *)table->GetPhysicalDeviceExternalBufferPropertiesKHR;
+    if (nameHash == 0xe3c8b71d8ae8e847 /* vkGetPhysicalDeviceExternalBufferPropertiesKHR */) return (void *)table->GetPhysicalDeviceExternalBufferPropertiesKHR;
 
     // ---- VK_KHR_external_semaphore_capabilities extension commands
-    if (!strcmp(name, "GetPhysicalDeviceExternalSemaphorePropertiesKHR")) return (void *)table->GetPhysicalDeviceExternalSemaphorePropertiesKHR;
+    if (nameHash == 0x3d3954d1737cc2bd /* vkGetPhysicalDeviceExternalSemaphorePropertiesKHR */) return (void *)table->GetPhysicalDeviceExternalSemaphorePropertiesKHR;
 
     // ---- VK_KHR_external_fence_capabilities extension commands
-    if (!strcmp(name, "GetPhysicalDeviceExternalFencePropertiesKHR")) return (void *)table->GetPhysicalDeviceExternalFencePropertiesKHR;
+    if (nameHash == 0x167106e03eb07e8d /* vkGetPhysicalDeviceExternalFencePropertiesKHR */) return (void *)table->GetPhysicalDeviceExternalFencePropertiesKHR;
 
     // ---- VK_KHR_performance_query extension commands
-    if (!strcmp(name, "EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR")) return (void *)table->EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR;
-    if (!strcmp(name, "GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR")) return (void *)table->GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR;
+    if (nameHash == 0x077270ba2023329b /* vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR */) return (void *)table->EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR;
+    if (nameHash == 0xf38f3b03668798a8 /* vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR */) return (void *)table->GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR;
 
     // ---- VK_KHR_get_surface_capabilities2 extension commands
-    if (!strcmp(name, "GetPhysicalDeviceSurfaceCapabilities2KHR")) return (void *)table->GetPhysicalDeviceSurfaceCapabilities2KHR;
-    if (!strcmp(name, "GetPhysicalDeviceSurfaceFormats2KHR")) return (void *)table->GetPhysicalDeviceSurfaceFormats2KHR;
+    if (nameHash == 0xeadc76790fea3998 /* vkGetPhysicalDeviceSurfaceCapabilities2KHR */) return (void *)table->GetPhysicalDeviceSurfaceCapabilities2KHR;
+    if (nameHash == 0xba60d8eb22951ad2 /* vkGetPhysicalDeviceSurfaceFormats2KHR */) return (void *)table->GetPhysicalDeviceSurfaceFormats2KHR;
 
     // ---- VK_KHR_get_display_properties2 extension commands
-    if (!strcmp(name, "GetPhysicalDeviceDisplayProperties2KHR")) return (void *)table->GetPhysicalDeviceDisplayProperties2KHR;
-    if (!strcmp(name, "GetPhysicalDeviceDisplayPlaneProperties2KHR")) return (void *)table->GetPhysicalDeviceDisplayPlaneProperties2KHR;
-    if (!strcmp(name, "GetDisplayModeProperties2KHR")) return (void *)table->GetDisplayModeProperties2KHR;
-    if (!strcmp(name, "GetDisplayPlaneCapabilities2KHR")) return (void *)table->GetDisplayPlaneCapabilities2KHR;
+    if (nameHash == 0xdec11a6b6abbaa1b /* vkGetPhysicalDeviceDisplayProperties2KHR */) return (void *)table->GetPhysicalDeviceDisplayProperties2KHR;
+    if (nameHash == 0x1a2ceebf7665e634 /* vkGetPhysicalDeviceDisplayPlaneProperties2KHR */) return (void *)table->GetPhysicalDeviceDisplayPlaneProperties2KHR;
+    if (nameHash == 0x49b103cf69b48bba /* vkGetDisplayModeProperties2KHR */) return (void *)table->GetDisplayModeProperties2KHR;
+    if (nameHash == 0x5ec24bf8bf79e8fd /* vkGetDisplayPlaneCapabilities2KHR */) return (void *)table->GetDisplayPlaneCapabilities2KHR;
 
     // ---- VK_KHR_fragment_shading_rate extension commands
-    if (!strcmp(name, "GetPhysicalDeviceFragmentShadingRatesKHR")) return (void *)table->GetPhysicalDeviceFragmentShadingRatesKHR;
+    if (nameHash == 0x0d649c4383ec7a89 /* vkGetPhysicalDeviceFragmentShadingRatesKHR */) return (void *)table->GetPhysicalDeviceFragmentShadingRatesKHR;
 
     // ---- VK_KHR_video_encode_queue extension commands
-    if (!strcmp(name, "GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR")) return (void *)table->GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR;
+    if (nameHash == 0xb5b7cd77fde2741a /* vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR */) return (void *)table->GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR;
 
     // ---- VK_KHR_cooperative_matrix extension commands
-    if (!strcmp(name, "GetPhysicalDeviceCooperativeMatrixPropertiesKHR")) return (void *)table->GetPhysicalDeviceCooperativeMatrixPropertiesKHR;
+    if (nameHash == 0x875c67a6f6143fdd /* vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR */) return (void *)table->GetPhysicalDeviceCooperativeMatrixPropertiesKHR;
 
     // ---- VK_KHR_calibrated_timestamps extension commands
-    if (!strcmp(name, "GetPhysicalDeviceCalibrateableTimeDomainsKHR")) return (void *)table->GetPhysicalDeviceCalibrateableTimeDomainsKHR;
+    if (nameHash == 0x1a4224a14b693350 /* vkGetPhysicalDeviceCalibrateableTimeDomainsKHR */) return (void *)table->GetPhysicalDeviceCalibrateableTimeDomainsKHR;
 
     // ---- VK_EXT_debug_report extension commands
-    if (!strcmp(name, "CreateDebugReportCallbackEXT")) return (void *)table->CreateDebugReportCallbackEXT;
-    if (!strcmp(name, "DestroyDebugReportCallbackEXT")) return (void *)table->DestroyDebugReportCallbackEXT;
-    if (!strcmp(name, "DebugReportMessageEXT")) return (void *)table->DebugReportMessageEXT;
+    if (nameHash == 0xab1126fda3a0fa8d /* vkCreateDebugReportCallbackEXT */) return (void *)table->CreateDebugReportCallbackEXT;
+    if (nameHash == 0x75357780677617ea /* vkDestroyDebugReportCallbackEXT */) return (void *)table->DestroyDebugReportCallbackEXT;
+    if (nameHash == 0xad6c4532349fd476 /* vkDebugReportMessageEXT */) return (void *)table->DebugReportMessageEXT;
 
     // ---- VK_GGP_stream_descriptor_surface extension commands
 #if defined(VK_USE_PLATFORM_GGP)
-    if (!strcmp(name, "CreateStreamDescriptorSurfaceGGP")) return (void *)table->CreateStreamDescriptorSurfaceGGP;
+    if (nameHash == 0x43d06e39e3edac61 /* vkCreateStreamDescriptorSurfaceGGP */) return (void *)table->CreateStreamDescriptorSurfaceGGP;
 #endif // VK_USE_PLATFORM_GGP
 
     // ---- VK_NV_external_memory_capabilities extension commands
-    if (!strcmp(name, "GetPhysicalDeviceExternalImageFormatPropertiesNV")) return (void *)table->GetPhysicalDeviceExternalImageFormatPropertiesNV;
+    if (nameHash == 0x47ac80818c4e0a8a /* vkGetPhysicalDeviceExternalImageFormatPropertiesNV */) return (void *)table->GetPhysicalDeviceExternalImageFormatPropertiesNV;
 
     // ---- VK_NN_vi_surface extension commands
 #if defined(VK_USE_PLATFORM_VI_NN)
-    if (!strcmp(name, "CreateViSurfaceNN")) return (void *)table->CreateViSurfaceNN;
+    if (nameHash == 0xe6edbd25c980bbfb /* vkCreateViSurfaceNN */) return (void *)table->CreateViSurfaceNN;
 #endif // VK_USE_PLATFORM_VI_NN
 
     // ---- VK_EXT_direct_mode_display extension commands
-    if (!strcmp(name, "ReleaseDisplayEXT")) return (void *)table->ReleaseDisplayEXT;
+    if (nameHash == 0x07d7f65f9502b047 /* vkReleaseDisplayEXT */) return (void *)table->ReleaseDisplayEXT;
 
     // ---- VK_EXT_acquire_xlib_display extension commands
 #if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
-    if (!strcmp(name, "AcquireXlibDisplayEXT")) return (void *)table->AcquireXlibDisplayEXT;
+    if (nameHash == 0xd07a635e04a59475 /* vkAcquireXlibDisplayEXT */) return (void *)table->AcquireXlibDisplayEXT;
 #endif // VK_USE_PLATFORM_XLIB_XRANDR_EXT
 #if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
-    if (!strcmp(name, "GetRandROutputDisplayEXT")) return (void *)table->GetRandROutputDisplayEXT;
+    if (nameHash == 0x3d31a6a7bedfba51 /* vkGetRandROutputDisplayEXT */) return (void *)table->GetRandROutputDisplayEXT;
 #endif // VK_USE_PLATFORM_XLIB_XRANDR_EXT
 
     // ---- VK_EXT_display_surface_counter extension commands
-    if (!strcmp(name, "GetPhysicalDeviceSurfaceCapabilities2EXT")) return (void *)table->GetPhysicalDeviceSurfaceCapabilities2EXT;
+    if (nameHash == 0xdc45f87f50da94d9 /* vkGetPhysicalDeviceSurfaceCapabilities2EXT */) return (void *)table->GetPhysicalDeviceSurfaceCapabilities2EXT;
 
     // ---- VK_MVK_ios_surface extension commands
 #if defined(VK_USE_PLATFORM_IOS_MVK)
-    if (!strcmp(name, "CreateIOSSurfaceMVK")) return (void *)table->CreateIOSSurfaceMVK;
+    if (nameHash == 0x952f84e4519a6819 /* vkCreateIOSSurfaceMVK */) return (void *)table->CreateIOSSurfaceMVK;
 #endif // VK_USE_PLATFORM_IOS_MVK
 
     // ---- VK_MVK_macos_surface extension commands
 #if defined(VK_USE_PLATFORM_MACOS_MVK)
-    if (!strcmp(name, "CreateMacOSSurfaceMVK")) return (void *)table->CreateMacOSSurfaceMVK;
+    if (nameHash == 0x93c0d2b7c2a1fcdc /* vkCreateMacOSSurfaceMVK */) return (void *)table->CreateMacOSSurfaceMVK;
 #endif // VK_USE_PLATFORM_MACOS_MVK
 
     // ---- VK_EXT_debug_utils extension commands
-    if (!strcmp(name, "CreateDebugUtilsMessengerEXT")) return (void *)table->CreateDebugUtilsMessengerEXT;
-    if (!strcmp(name, "DestroyDebugUtilsMessengerEXT")) return (void *)table->DestroyDebugUtilsMessengerEXT;
-    if (!strcmp(name, "SubmitDebugUtilsMessageEXT")) return (void *)table->SubmitDebugUtilsMessageEXT;
+    if (nameHash == 0xbecec18dc0f1923b /* vkCreateDebugUtilsMessengerEXT */) return (void *)table->CreateDebugUtilsMessengerEXT;
+    if (nameHash == 0x82c3f5f82d3f7a21 /* vkDestroyDebugUtilsMessengerEXT */) return (void *)table->DestroyDebugUtilsMessengerEXT;
+    if (nameHash == 0xbe616f5f63c1ce25 /* vkSubmitDebugUtilsMessageEXT */) return (void *)table->SubmitDebugUtilsMessageEXT;
 
     // ---- VK_EXT_sample_locations extension commands
-    if (!strcmp(name, "GetPhysicalDeviceMultisamplePropertiesEXT")) return (void *)table->GetPhysicalDeviceMultisamplePropertiesEXT;
+    if (nameHash == 0x57fddf2e7905b565 /* vkGetPhysicalDeviceMultisamplePropertiesEXT */) return (void *)table->GetPhysicalDeviceMultisamplePropertiesEXT;
 
     // ---- VK_EXT_calibrated_timestamps extension commands
-    if (!strcmp(name, "GetPhysicalDeviceCalibrateableTimeDomainsEXT")) return (void *)table->GetPhysicalDeviceCalibrateableTimeDomainsEXT;
+    if (nameHash == 0x5cd180715ec81628 /* vkGetPhysicalDeviceCalibrateableTimeDomainsEXT */) return (void *)table->GetPhysicalDeviceCalibrateableTimeDomainsEXT;
 
     // ---- VK_FUCHSIA_imagepipe_surface extension commands
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp(name, "CreateImagePipeSurfaceFUCHSIA")) return (void *)table->CreateImagePipeSurfaceFUCHSIA;
+    if (nameHash == 0xce552719aadd91f1 /* vkCreateImagePipeSurfaceFUCHSIA */) return (void *)table->CreateImagePipeSurfaceFUCHSIA;
 #endif // VK_USE_PLATFORM_FUCHSIA
 
     // ---- VK_EXT_metal_surface extension commands
 #if defined(VK_USE_PLATFORM_METAL_EXT)
-    if (!strcmp(name, "CreateMetalSurfaceEXT")) return (void *)table->CreateMetalSurfaceEXT;
+    if (nameHash == 0xc8c1cf60816e6d0b /* vkCreateMetalSurfaceEXT */) return (void *)table->CreateMetalSurfaceEXT;
 #endif // VK_USE_PLATFORM_METAL_EXT
 
     // ---- VK_EXT_tooling_info extension commands
-    if (!strcmp(name, "GetPhysicalDeviceToolPropertiesEXT")) return (void *)table->GetPhysicalDeviceToolPropertiesEXT;
+    if (nameHash == 0x537299821dbd504f /* vkGetPhysicalDeviceToolPropertiesEXT */) return (void *)table->GetPhysicalDeviceToolPropertiesEXT;
 
     // ---- VK_NV_cooperative_matrix extension commands
-    if (!strcmp(name, "GetPhysicalDeviceCooperativeMatrixPropertiesNV")) return (void *)table->GetPhysicalDeviceCooperativeMatrixPropertiesNV;
+    if (nameHash == 0xbd9b598956c7366a /* vkGetPhysicalDeviceCooperativeMatrixPropertiesNV */) return (void *)table->GetPhysicalDeviceCooperativeMatrixPropertiesNV;
 
     // ---- VK_NV_coverage_reduction_mode extension commands
-    if (!strcmp(name, "GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV")) return (void *)table->GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV;
+    if (nameHash == 0xf43459aa9a0dd505 /* vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV */) return (void *)table->GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV;
 
     // ---- VK_EXT_full_screen_exclusive extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "GetPhysicalDeviceSurfacePresentModes2EXT")) return (void *)table->GetPhysicalDeviceSurfacePresentModes2EXT;
+    if (nameHash == 0xb4e2ff145e115a30 /* vkGetPhysicalDeviceSurfacePresentModes2EXT */) return (void *)table->GetPhysicalDeviceSurfacePresentModes2EXT;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_EXT_headless_surface extension commands
-    if (!strcmp(name, "CreateHeadlessSurfaceEXT")) return (void *)table->CreateHeadlessSurfaceEXT;
+    if (nameHash == 0x32e1633a3f5c604b /* vkCreateHeadlessSurfaceEXT */) return (void *)table->CreateHeadlessSurfaceEXT;
 
     // ---- VK_EXT_acquire_drm_display extension commands
-    if (!strcmp(name, "AcquireDrmDisplayEXT")) return (void *)table->AcquireDrmDisplayEXT;
-    if (!strcmp(name, "GetDrmDisplayEXT")) return (void *)table->GetDrmDisplayEXT;
+    if (nameHash == 0x07c6f662a8afbdcd /* vkAcquireDrmDisplayEXT */) return (void *)table->AcquireDrmDisplayEXT;
+    if (nameHash == 0x7ad0a59b02543fcd /* vkGetDrmDisplayEXT */) return (void *)table->GetDrmDisplayEXT;
 
     // ---- VK_NV_acquire_winrt_display extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "AcquireWinrtDisplayNV")) return (void *)table->AcquireWinrtDisplayNV;
+    if (nameHash == 0xad319e2c95c14175 /* vkAcquireWinrtDisplayNV */) return (void *)table->AcquireWinrtDisplayNV;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp(name, "GetWinrtDisplayNV")) return (void *)table->GetWinrtDisplayNV;
+    if (nameHash == 0x61c13e84ce5c483b /* vkGetWinrtDisplayNV */) return (void *)table->GetWinrtDisplayNV;
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_EXT_directfb_surface extension commands
 #if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
-    if (!strcmp(name, "CreateDirectFBSurfaceEXT")) return (void *)table->CreateDirectFBSurfaceEXT;
+    if (nameHash == 0x0a7cb804a19f8d38 /* vkCreateDirectFBSurfaceEXT */) return (void *)table->CreateDirectFBSurfaceEXT;
 #endif // VK_USE_PLATFORM_DIRECTFB_EXT
 #if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
-    if (!strcmp(name, "GetPhysicalDeviceDirectFBPresentationSupportEXT")) return (void *)table->GetPhysicalDeviceDirectFBPresentationSupportEXT;
+    if (nameHash == 0xe0e022af99face3d /* vkGetPhysicalDeviceDirectFBPresentationSupportEXT */) return (void *)table->GetPhysicalDeviceDirectFBPresentationSupportEXT;
 #endif // VK_USE_PLATFORM_DIRECTFB_EXT
 
     // ---- VK_QNX_screen_surface extension commands
 #if defined(VK_USE_PLATFORM_SCREEN_QNX)
-    if (!strcmp(name, "CreateScreenSurfaceQNX")) return (void *)table->CreateScreenSurfaceQNX;
+    if (nameHash == 0x4b8ff5f08d987c5a /* vkCreateScreenSurfaceQNX */) return (void *)table->CreateScreenSurfaceQNX;
 #endif // VK_USE_PLATFORM_SCREEN_QNX
 #if defined(VK_USE_PLATFORM_SCREEN_QNX)
-    if (!strcmp(name, "GetPhysicalDeviceScreenPresentationSupportQNX")) return (void *)table->GetPhysicalDeviceScreenPresentationSupportQNX;
+    if (nameHash == 0xf3c741c713ed78b6 /* vkGetPhysicalDeviceScreenPresentationSupportQNX */) return (void *)table->GetPhysicalDeviceScreenPresentationSupportQNX;
 #endif // VK_USE_PLATFORM_SCREEN_QNX
 
     // ---- VK_NV_optical_flow extension commands
-    if (!strcmp(name, "GetPhysicalDeviceOpticalFlowImageFormatsNV")) return (void *)table->GetPhysicalDeviceOpticalFlowImageFormatsNV;
+    if (nameHash == 0x06f2fe22a6f73ea9 /* vkGetPhysicalDeviceOpticalFlowImageFormatsNV */) return (void *)table->GetPhysicalDeviceOpticalFlowImageFormatsNV;
 
     // ---- VK_NV_cooperative_matrix2 extension commands
-    if (!strcmp(name, "GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV")) return (void *)table->GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV;
+    if (nameHash == 0x0d056d30f5678b25 /* vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV */) return (void *)table->GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV;
 
     *found_name = false;
     return NULL;
@@ -10231,114 +10232,113 @@ VKAPI_ATTR void VKAPI_CALL CmdDrawMeshTasksIndirectCountEXT(
 }
 
 // GPA helpers for extensions
-bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *name, void **addr) {
+bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *name, uint64_t nameHash, void **addr) {
     *addr = NULL;
 
-
     // ---- VK_KHR_video_queue extension commands
-    if (!strcmp("vkGetPhysicalDeviceVideoCapabilitiesKHR", name)) {
+    if (nameHash == 0x2517bce1d06e4a03 /* vkGetPhysicalDeviceVideoCapabilitiesKHR */) {
         *addr = (void *)GetPhysicalDeviceVideoCapabilitiesKHR;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceVideoFormatPropertiesKHR", name)) {
+    if (nameHash == 0xb55826fa36b0b298 /* vkGetPhysicalDeviceVideoFormatPropertiesKHR */) {
         *addr = (void *)GetPhysicalDeviceVideoFormatPropertiesKHR;
         return true;
     }
-    if (!strcmp("vkCreateVideoSessionKHR", name)) {
+    if (nameHash == 0xf8d70781ac92a1cf /* vkCreateVideoSessionKHR */) {
         *addr = (void *)CreateVideoSessionKHR;
         return true;
     }
-    if (!strcmp("vkDestroyVideoSessionKHR", name)) {
+    if (nameHash == 0x4bfeea912504df47 /* vkDestroyVideoSessionKHR */) {
         *addr = (void *)DestroyVideoSessionKHR;
         return true;
     }
-    if (!strcmp("vkGetVideoSessionMemoryRequirementsKHR", name)) {
+    if (nameHash == 0x34c3a6eee5758a70 /* vkGetVideoSessionMemoryRequirementsKHR */) {
         *addr = (void *)GetVideoSessionMemoryRequirementsKHR;
         return true;
     }
-    if (!strcmp("vkBindVideoSessionMemoryKHR", name)) {
+    if (nameHash == 0x95fd48feaefe8c46 /* vkBindVideoSessionMemoryKHR */) {
         *addr = (void *)BindVideoSessionMemoryKHR;
         return true;
     }
-    if (!strcmp("vkCreateVideoSessionParametersKHR", name)) {
+    if (nameHash == 0xe89bda66824b7d7d /* vkCreateVideoSessionParametersKHR */) {
         *addr = (void *)CreateVideoSessionParametersKHR;
         return true;
     }
-    if (!strcmp("vkUpdateVideoSessionParametersKHR", name)) {
+    if (nameHash == 0x0baf9d7df0a788b5 /* vkUpdateVideoSessionParametersKHR */) {
         *addr = (void *)UpdateVideoSessionParametersKHR;
         return true;
     }
-    if (!strcmp("vkDestroyVideoSessionParametersKHR", name)) {
+    if (nameHash == 0x996b8928f4147a24 /* vkDestroyVideoSessionParametersKHR */) {
         *addr = (void *)DestroyVideoSessionParametersKHR;
         return true;
     }
-    if (!strcmp("vkCmdBeginVideoCodingKHR", name)) {
+    if (nameHash == 0xcfa13bad1a984ba3 /* vkCmdBeginVideoCodingKHR */) {
         *addr = (void *)CmdBeginVideoCodingKHR;
         return true;
     }
-    if (!strcmp("vkCmdEndVideoCodingKHR", name)) {
+    if (nameHash == 0xf5243f8ebe970031 /* vkCmdEndVideoCodingKHR */) {
         *addr = (void *)CmdEndVideoCodingKHR;
         return true;
     }
-    if (!strcmp("vkCmdControlVideoCodingKHR", name)) {
+    if (nameHash == 0x355f705d4d835c02 /* vkCmdControlVideoCodingKHR */) {
         *addr = (void *)CmdControlVideoCodingKHR;
         return true;
     }
 
     // ---- VK_KHR_video_decode_queue extension commands
-    if (!strcmp("vkCmdDecodeVideoKHR", name)) {
+    if (nameHash == 0xa5bd2226d386dd02 /* vkCmdDecodeVideoKHR */) {
         *addr = (void *)CmdDecodeVideoKHR;
         return true;
     }
 
     // ---- VK_KHR_dynamic_rendering extension commands
-    if (!strcmp("vkCmdBeginRenderingKHR", name)) {
+    if (nameHash == 0xf525fcfca497ad4d /* vkCmdBeginRenderingKHR */) {
         *addr = (void *)CmdBeginRenderingKHR;
         return true;
     }
-    if (!strcmp("vkCmdEndRenderingKHR", name)) {
+    if (nameHash == 0x20a57b855bed16ad /* vkCmdEndRenderingKHR */) {
         *addr = (void *)CmdEndRenderingKHR;
         return true;
     }
 
     // ---- VK_KHR_get_physical_device_properties2 extension commands
-    if (!strcmp("vkGetPhysicalDeviceFeatures2KHR", name)) {
+    if (nameHash == 0x271fe9077ef533d1 /* vkGetPhysicalDeviceFeatures2KHR */) {
         *addr = (ptr_instance->enabled_known_extensions.khr_get_physical_device_properties2 == 1)
                      ? (void *)vkGetPhysicalDeviceFeatures2
                      : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceProperties2KHR", name)) {
+    if (nameHash == 0x3acc37b403e87ac3 /* vkGetPhysicalDeviceProperties2KHR */) {
         *addr = (ptr_instance->enabled_known_extensions.khr_get_physical_device_properties2 == 1)
                      ? (void *)vkGetPhysicalDeviceProperties2
                      : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceFormatProperties2KHR", name)) {
+    if (nameHash == 0x39fbee03ddc7e70e /* vkGetPhysicalDeviceFormatProperties2KHR */) {
         *addr = (ptr_instance->enabled_known_extensions.khr_get_physical_device_properties2 == 1)
                      ? (void *)vkGetPhysicalDeviceFormatProperties2
                      : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceImageFormatProperties2KHR", name)) {
+    if (nameHash == 0xc0305d666c70b81b /* vkGetPhysicalDeviceImageFormatProperties2KHR */) {
         *addr = (ptr_instance->enabled_known_extensions.khr_get_physical_device_properties2 == 1)
                      ? (void *)vkGetPhysicalDeviceImageFormatProperties2
                      : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceQueueFamilyProperties2KHR", name)) {
+    if (nameHash == 0x435d49e0c9740090 /* vkGetPhysicalDeviceQueueFamilyProperties2KHR */) {
         *addr = (ptr_instance->enabled_known_extensions.khr_get_physical_device_properties2 == 1)
                      ? (void *)vkGetPhysicalDeviceQueueFamilyProperties2
                      : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceMemoryProperties2KHR", name)) {
+    if (nameHash == 0xd6701419da6617d4 /* vkGetPhysicalDeviceMemoryProperties2KHR */) {
         *addr = (ptr_instance->enabled_known_extensions.khr_get_physical_device_properties2 == 1)
                      ? (void *)vkGetPhysicalDeviceMemoryProperties2
                      : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceSparseImageFormatProperties2KHR", name)) {
+    if (nameHash == 0xc79bcf369fe8ca6e /* vkGetPhysicalDeviceSparseImageFormatProperties2KHR */) {
         *addr = (ptr_instance->enabled_known_extensions.khr_get_physical_device_properties2 == 1)
                      ? (void *)vkGetPhysicalDeviceSparseImageFormatProperties2
                      : NULL;
@@ -10346,27 +10346,27 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
     }
 
     // ---- VK_KHR_device_group extension commands
-    if (!strcmp("vkGetDeviceGroupPeerMemoryFeaturesKHR", name)) {
+    if (nameHash == 0xe62b971ae0a68532 /* vkGetDeviceGroupPeerMemoryFeaturesKHR */) {
         *addr = (void *)GetDeviceGroupPeerMemoryFeaturesKHR;
         return true;
     }
-    if (!strcmp("vkCmdSetDeviceMaskKHR", name)) {
+    if (nameHash == 0x6a987f9eb7d4a557 /* vkCmdSetDeviceMaskKHR */) {
         *addr = (void *)CmdSetDeviceMaskKHR;
         return true;
     }
-    if (!strcmp("vkCmdDispatchBaseKHR", name)) {
+    if (nameHash == 0x315127945d495884 /* vkCmdDispatchBaseKHR */) {
         *addr = (void *)CmdDispatchBaseKHR;
         return true;
     }
 
     // ---- VK_KHR_maintenance1 extension commands
-    if (!strcmp("vkTrimCommandPoolKHR", name)) {
+    if (nameHash == 0x73f1f198f822a45e /* vkTrimCommandPoolKHR */) {
         *addr = (void *)TrimCommandPoolKHR;
         return true;
     }
 
     // ---- VK_KHR_device_group_creation extension commands
-    if (!strcmp("vkEnumeratePhysicalDeviceGroupsKHR", name)) {
+    if (nameHash == 0x52e6981b035c87fe /* vkEnumeratePhysicalDeviceGroupsKHR */) {
         *addr = (ptr_instance->enabled_known_extensions.khr_device_group_creation == 1)
                      ? (void *)vkEnumeratePhysicalDeviceGroups
                      : NULL;
@@ -10374,7 +10374,7 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
     }
 
     // ---- VK_KHR_external_memory_capabilities extension commands
-    if (!strcmp("vkGetPhysicalDeviceExternalBufferPropertiesKHR", name)) {
+    if (nameHash == 0xe3c8b71d8ae8e847 /* vkGetPhysicalDeviceExternalBufferPropertiesKHR */) {
         *addr = (ptr_instance->enabled_known_extensions.khr_external_memory_capabilities == 1)
                      ? (void *)vkGetPhysicalDeviceExternalBufferProperties
                      : NULL;
@@ -10383,30 +10383,30 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
 
     // ---- VK_KHR_external_memory_win32 extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp("vkGetMemoryWin32HandleKHR", name)) {
+    if (nameHash == 0xcda4a94d2c8596f7 /* vkGetMemoryWin32HandleKHR */) {
         *addr = (void *)GetMemoryWin32HandleKHR;
         return true;
     }
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp("vkGetMemoryWin32HandlePropertiesKHR", name)) {
+    if (nameHash == 0xce5d77a823daf981 /* vkGetMemoryWin32HandlePropertiesKHR */) {
         *addr = (void *)GetMemoryWin32HandlePropertiesKHR;
         return true;
     }
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_KHR_external_memory_fd extension commands
-    if (!strcmp("vkGetMemoryFdKHR", name)) {
+    if (nameHash == 0x2ed749f13375a993 /* vkGetMemoryFdKHR */) {
         *addr = (void *)GetMemoryFdKHR;
         return true;
     }
-    if (!strcmp("vkGetMemoryFdPropertiesKHR", name)) {
+    if (nameHash == 0x12e6b027ea2149c2 /* vkGetMemoryFdPropertiesKHR */) {
         *addr = (void *)GetMemoryFdPropertiesKHR;
         return true;
     }
 
     // ---- VK_KHR_external_semaphore_capabilities extension commands
-    if (!strcmp("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", name)) {
+    if (nameHash == 0x3d3954d1737cc2bd /* vkGetPhysicalDeviceExternalSemaphorePropertiesKHR */) {
         *addr = (ptr_instance->enabled_known_extensions.khr_external_semaphore_capabilities == 1)
                      ? (void *)vkGetPhysicalDeviceExternalSemaphoreProperties
                      : NULL;
@@ -10415,78 +10415,78 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
 
     // ---- VK_KHR_external_semaphore_win32 extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp("vkImportSemaphoreWin32HandleKHR", name)) {
+    if (nameHash == 0xe66bc79887578e01 /* vkImportSemaphoreWin32HandleKHR */) {
         *addr = (void *)ImportSemaphoreWin32HandleKHR;
         return true;
     }
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp("vkGetSemaphoreWin32HandleKHR", name)) {
+    if (nameHash == 0xe7cfb8155a9ec7f4 /* vkGetSemaphoreWin32HandleKHR */) {
         *addr = (void *)GetSemaphoreWin32HandleKHR;
         return true;
     }
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_KHR_external_semaphore_fd extension commands
-    if (!strcmp("vkImportSemaphoreFdKHR", name)) {
+    if (nameHash == 0xebc09d555d9390f1 /* vkImportSemaphoreFdKHR */) {
         *addr = (void *)ImportSemaphoreFdKHR;
         return true;
     }
-    if (!strcmp("vkGetSemaphoreFdKHR", name)) {
+    if (nameHash == 0x140ab11fc9190c09 /* vkGetSemaphoreFdKHR */) {
         *addr = (void *)GetSemaphoreFdKHR;
         return true;
     }
 
     // ---- VK_KHR_push_descriptor extension commands
-    if (!strcmp("vkCmdPushDescriptorSetKHR", name)) {
+    if (nameHash == 0x2123cc5e1c438312 /* vkCmdPushDescriptorSetKHR */) {
         *addr = (void *)CmdPushDescriptorSetKHR;
         return true;
     }
-    if (!strcmp("vkCmdPushDescriptorSetWithTemplateKHR", name)) {
+    if (nameHash == 0xc0e77996431e14e7 /* vkCmdPushDescriptorSetWithTemplateKHR */) {
         *addr = (void *)CmdPushDescriptorSetWithTemplateKHR;
         return true;
     }
 
     // ---- VK_KHR_descriptor_update_template extension commands
-    if (!strcmp("vkCreateDescriptorUpdateTemplateKHR", name)) {
+    if (nameHash == 0xae196725993a5773 /* vkCreateDescriptorUpdateTemplateKHR */) {
         *addr = (void *)CreateDescriptorUpdateTemplateKHR;
         return true;
     }
-    if (!strcmp("vkDestroyDescriptorUpdateTemplateKHR", name)) {
+    if (nameHash == 0x36da6959c46b24dd /* vkDestroyDescriptorUpdateTemplateKHR */) {
         *addr = (void *)DestroyDescriptorUpdateTemplateKHR;
         return true;
     }
-    if (!strcmp("vkUpdateDescriptorSetWithTemplateKHR", name)) {
+    if (nameHash == 0x71b8cb2fd8159c3d /* vkUpdateDescriptorSetWithTemplateKHR */) {
         *addr = (void *)UpdateDescriptorSetWithTemplateKHR;
         return true;
     }
 
     // ---- VK_KHR_create_renderpass2 extension commands
-    if (!strcmp("vkCreateRenderPass2KHR", name)) {
+    if (nameHash == 0x7282c5dadf99206c /* vkCreateRenderPass2KHR */) {
         *addr = (void *)CreateRenderPass2KHR;
         return true;
     }
-    if (!strcmp("vkCmdBeginRenderPass2KHR", name)) {
+    if (nameHash == 0x953dd320a2f19033 /* vkCmdBeginRenderPass2KHR */) {
         *addr = (void *)CmdBeginRenderPass2KHR;
         return true;
     }
-    if (!strcmp("vkCmdNextSubpass2KHR", name)) {
+    if (nameHash == 0x599380d76631dbc9 /* vkCmdNextSubpass2KHR */) {
         *addr = (void *)CmdNextSubpass2KHR;
         return true;
     }
-    if (!strcmp("vkCmdEndRenderPass2KHR", name)) {
+    if (nameHash == 0xcf86c42d2695983a /* vkCmdEndRenderPass2KHR */) {
         *addr = (void *)CmdEndRenderPass2KHR;
         return true;
     }
 
     // ---- VK_KHR_shared_presentable_image extension commands
-    if (!strcmp("vkGetSwapchainStatusKHR", name)) {
+    if (nameHash == 0x5df941fbd5ee53ed /* vkGetSwapchainStatusKHR */) {
         *addr = (void *)GetSwapchainStatusKHR;
         return true;
     }
 
     // ---- VK_KHR_external_fence_capabilities extension commands
-    if (!strcmp("vkGetPhysicalDeviceExternalFencePropertiesKHR", name)) {
+    if (nameHash == 0x167106e03eb07e8d /* vkGetPhysicalDeviceExternalFencePropertiesKHR */) {
         *addr = (ptr_instance->enabled_known_extensions.khr_external_fence_capabilities == 1)
                      ? (void *)vkGetPhysicalDeviceExternalFenceProperties
                      : NULL;
@@ -10495,472 +10495,472 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
 
     // ---- VK_KHR_external_fence_win32 extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp("vkImportFenceWin32HandleKHR", name)) {
+    if (nameHash == 0x8aa9a6ca90bcc785 /* vkImportFenceWin32HandleKHR */) {
         *addr = (void *)ImportFenceWin32HandleKHR;
         return true;
     }
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp("vkGetFenceWin32HandleKHR", name)) {
+    if (nameHash == 0xd70928b0b99ddf51 /* vkGetFenceWin32HandleKHR */) {
         *addr = (void *)GetFenceWin32HandleKHR;
         return true;
     }
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_KHR_external_fence_fd extension commands
-    if (!strcmp("vkImportFenceFdKHR", name)) {
+    if (nameHash == 0xe753bab9908ecda8 /* vkImportFenceFdKHR */) {
         *addr = (void *)ImportFenceFdKHR;
         return true;
     }
-    if (!strcmp("vkGetFenceFdKHR", name)) {
+    if (nameHash == 0x7f028870dfbbd7cd /* vkGetFenceFdKHR */) {
         *addr = (void *)GetFenceFdKHR;
         return true;
     }
 
     // ---- VK_KHR_performance_query extension commands
-    if (!strcmp("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", name)) {
+    if (nameHash == 0x077270ba2023329b /* vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR */) {
         *addr = (void *)EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", name)) {
+    if (nameHash == 0xf38f3b03668798a8 /* vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR */) {
         *addr = (void *)GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR;
         return true;
     }
-    if (!strcmp("vkAcquireProfilingLockKHR", name)) {
+    if (nameHash == 0xaa4956312cfc8f69 /* vkAcquireProfilingLockKHR */) {
         *addr = (void *)AcquireProfilingLockKHR;
         return true;
     }
-    if (!strcmp("vkReleaseProfilingLockKHR", name)) {
+    if (nameHash == 0x0a9e4edad7617bf4 /* vkReleaseProfilingLockKHR */) {
         *addr = (void *)ReleaseProfilingLockKHR;
         return true;
     }
 
     // ---- VK_KHR_get_memory_requirements2 extension commands
-    if (!strcmp("vkGetImageMemoryRequirements2KHR", name)) {
+    if (nameHash == 0x3e094de8a08c3145 /* vkGetImageMemoryRequirements2KHR */) {
         *addr = (void *)GetImageMemoryRequirements2KHR;
         return true;
     }
-    if (!strcmp("vkGetBufferMemoryRequirements2KHR", name)) {
+    if (nameHash == 0x77ac813268762693 /* vkGetBufferMemoryRequirements2KHR */) {
         *addr = (void *)GetBufferMemoryRequirements2KHR;
         return true;
     }
-    if (!strcmp("vkGetImageSparseMemoryRequirements2KHR", name)) {
+    if (nameHash == 0x9cc130ca400434b7 /* vkGetImageSparseMemoryRequirements2KHR */) {
         *addr = (void *)GetImageSparseMemoryRequirements2KHR;
         return true;
     }
 
     // ---- VK_KHR_sampler_ycbcr_conversion extension commands
-    if (!strcmp("vkCreateSamplerYcbcrConversionKHR", name)) {
+    if (nameHash == 0xbaa71789dfb073b1 /* vkCreateSamplerYcbcrConversionKHR */) {
         *addr = (void *)CreateSamplerYcbcrConversionKHR;
         return true;
     }
-    if (!strcmp("vkDestroySamplerYcbcrConversionKHR", name)) {
+    if (nameHash == 0xb7d326eaca38da93 /* vkDestroySamplerYcbcrConversionKHR */) {
         *addr = (void *)DestroySamplerYcbcrConversionKHR;
         return true;
     }
 
     // ---- VK_KHR_bind_memory2 extension commands
-    if (!strcmp("vkBindBufferMemory2KHR", name)) {
+    if (nameHash == 0xc20b7cd3cdb4895d /* vkBindBufferMemory2KHR */) {
         *addr = (void *)BindBufferMemory2KHR;
         return true;
     }
-    if (!strcmp("vkBindImageMemory2KHR", name)) {
+    if (nameHash == 0xa17b9f5a286650f5 /* vkBindImageMemory2KHR */) {
         *addr = (void *)BindImageMemory2KHR;
         return true;
     }
 
     // ---- VK_KHR_maintenance3 extension commands
-    if (!strcmp("vkGetDescriptorSetLayoutSupportKHR", name)) {
+    if (nameHash == 0x0f7af59845222e9d /* vkGetDescriptorSetLayoutSupportKHR */) {
         *addr = (void *)GetDescriptorSetLayoutSupportKHR;
         return true;
     }
 
     // ---- VK_KHR_draw_indirect_count extension commands
-    if (!strcmp("vkCmdDrawIndirectCountKHR", name)) {
+    if (nameHash == 0xd2ada1f0fce0ebc9 /* vkCmdDrawIndirectCountKHR */) {
         *addr = (void *)CmdDrawIndirectCountKHR;
         return true;
     }
-    if (!strcmp("vkCmdDrawIndexedIndirectCountKHR", name)) {
+    if (nameHash == 0xa343558c3889eb3b /* vkCmdDrawIndexedIndirectCountKHR */) {
         *addr = (void *)CmdDrawIndexedIndirectCountKHR;
         return true;
     }
 
     // ---- VK_KHR_timeline_semaphore extension commands
-    if (!strcmp("vkGetSemaphoreCounterValueKHR", name)) {
+    if (nameHash == 0x4f323238bf52cee6 /* vkGetSemaphoreCounterValueKHR */) {
         *addr = (void *)GetSemaphoreCounterValueKHR;
         return true;
     }
-    if (!strcmp("vkWaitSemaphoresKHR", name)) {
+    if (nameHash == 0x90b98ea73daf2fc7 /* vkWaitSemaphoresKHR */) {
         *addr = (void *)WaitSemaphoresKHR;
         return true;
     }
-    if (!strcmp("vkSignalSemaphoreKHR", name)) {
+    if (nameHash == 0xb8f7f65305fa9c04 /* vkSignalSemaphoreKHR */) {
         *addr = (void *)SignalSemaphoreKHR;
         return true;
     }
 
     // ---- VK_KHR_fragment_shading_rate extension commands
-    if (!strcmp("vkGetPhysicalDeviceFragmentShadingRatesKHR", name)) {
+    if (nameHash == 0x0d649c4383ec7a89 /* vkGetPhysicalDeviceFragmentShadingRatesKHR */) {
         *addr = (void *)GetPhysicalDeviceFragmentShadingRatesKHR;
         return true;
     }
-    if (!strcmp("vkCmdSetFragmentShadingRateKHR", name)) {
+    if (nameHash == 0x8ed6523506902ceb /* vkCmdSetFragmentShadingRateKHR */) {
         *addr = (void *)CmdSetFragmentShadingRateKHR;
         return true;
     }
 
     // ---- VK_KHR_dynamic_rendering_local_read extension commands
-    if (!strcmp("vkCmdSetRenderingAttachmentLocationsKHR", name)) {
+    if (nameHash == 0xabb4da3669fa0607 /* vkCmdSetRenderingAttachmentLocationsKHR */) {
         *addr = (void *)CmdSetRenderingAttachmentLocationsKHR;
         return true;
     }
-    if (!strcmp("vkCmdSetRenderingInputAttachmentIndicesKHR", name)) {
+    if (nameHash == 0x8284d04d0f439b7f /* vkCmdSetRenderingInputAttachmentIndicesKHR */) {
         *addr = (void *)CmdSetRenderingInputAttachmentIndicesKHR;
         return true;
     }
 
     // ---- VK_KHR_present_wait extension commands
-    if (!strcmp("vkWaitForPresentKHR", name)) {
+    if (nameHash == 0x958f70568135c547 /* vkWaitForPresentKHR */) {
         *addr = (void *)WaitForPresentKHR;
         return true;
     }
 
     // ---- VK_KHR_buffer_device_address extension commands
-    if (!strcmp("vkGetBufferDeviceAddressKHR", name)) {
+    if (nameHash == 0x62692fbaea06e05d /* vkGetBufferDeviceAddressKHR */) {
         *addr = (void *)GetBufferDeviceAddressKHR;
         return true;
     }
-    if (!strcmp("vkGetBufferOpaqueCaptureAddressKHR", name)) {
+    if (nameHash == 0x5de8076ffb7af976 /* vkGetBufferOpaqueCaptureAddressKHR */) {
         *addr = (void *)GetBufferOpaqueCaptureAddressKHR;
         return true;
     }
-    if (!strcmp("vkGetDeviceMemoryOpaqueCaptureAddressKHR", name)) {
+    if (nameHash == 0x316bebcfe32855b8 /* vkGetDeviceMemoryOpaqueCaptureAddressKHR */) {
         *addr = (void *)GetDeviceMemoryOpaqueCaptureAddressKHR;
         return true;
     }
 
     // ---- VK_KHR_deferred_host_operations extension commands
-    if (!strcmp("vkCreateDeferredOperationKHR", name)) {
+    if (nameHash == 0xc53d00dd120cc028 /* vkCreateDeferredOperationKHR */) {
         *addr = (void *)CreateDeferredOperationKHR;
         return true;
     }
-    if (!strcmp("vkDestroyDeferredOperationKHR", name)) {
+    if (nameHash == 0x71bb8068c1edf85e /* vkDestroyDeferredOperationKHR */) {
         *addr = (void *)DestroyDeferredOperationKHR;
         return true;
     }
-    if (!strcmp("vkGetDeferredOperationMaxConcurrencyKHR", name)) {
+    if (nameHash == 0xe8ddcebfb8abfe62 /* vkGetDeferredOperationMaxConcurrencyKHR */) {
         *addr = (void *)GetDeferredOperationMaxConcurrencyKHR;
         return true;
     }
-    if (!strcmp("vkGetDeferredOperationResultKHR", name)) {
+    if (nameHash == 0xf325f660479c7872 /* vkGetDeferredOperationResultKHR */) {
         *addr = (void *)GetDeferredOperationResultKHR;
         return true;
     }
-    if (!strcmp("vkDeferredOperationJoinKHR", name)) {
+    if (nameHash == 0x7379abd10f3bfb5d /* vkDeferredOperationJoinKHR */) {
         *addr = (void *)DeferredOperationJoinKHR;
         return true;
     }
 
     // ---- VK_KHR_pipeline_executable_properties extension commands
-    if (!strcmp("vkGetPipelineExecutablePropertiesKHR", name)) {
+    if (nameHash == 0xf8010e878fa40163 /* vkGetPipelineExecutablePropertiesKHR */) {
         *addr = (void *)GetPipelineExecutablePropertiesKHR;
         return true;
     }
-    if (!strcmp("vkGetPipelineExecutableStatisticsKHR", name)) {
+    if (nameHash == 0x5001dcd798e4f3a8 /* vkGetPipelineExecutableStatisticsKHR */) {
         *addr = (void *)GetPipelineExecutableStatisticsKHR;
         return true;
     }
-    if (!strcmp("vkGetPipelineExecutableInternalRepresentationsKHR", name)) {
+    if (nameHash == 0x482cb3433b920f78 /* vkGetPipelineExecutableInternalRepresentationsKHR */) {
         *addr = (void *)GetPipelineExecutableInternalRepresentationsKHR;
         return true;
     }
 
     // ---- VK_KHR_map_memory2 extension commands
-    if (!strcmp("vkMapMemory2KHR", name)) {
+    if (nameHash == 0x34bfbbd6c34bac46 /* vkMapMemory2KHR */) {
         *addr = (void *)MapMemory2KHR;
         return true;
     }
-    if (!strcmp("vkUnmapMemory2KHR", name)) {
+    if (nameHash == 0x345a6d44742dd550 /* vkUnmapMemory2KHR */) {
         *addr = (void *)UnmapMemory2KHR;
         return true;
     }
 
     // ---- VK_KHR_video_encode_queue extension commands
-    if (!strcmp("vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR", name)) {
+    if (nameHash == 0xb5b7cd77fde2741a /* vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR */) {
         *addr = (void *)GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR;
         return true;
     }
-    if (!strcmp("vkGetEncodedVideoSessionParametersKHR", name)) {
+    if (nameHash == 0xd620ed53628cc23d /* vkGetEncodedVideoSessionParametersKHR */) {
         *addr = (void *)GetEncodedVideoSessionParametersKHR;
         return true;
     }
-    if (!strcmp("vkCmdEncodeVideoKHR", name)) {
+    if (nameHash == 0x68a8fbded268189e /* vkCmdEncodeVideoKHR */) {
         *addr = (void *)CmdEncodeVideoKHR;
         return true;
     }
 
     // ---- VK_KHR_synchronization2 extension commands
-    if (!strcmp("vkCmdSetEvent2KHR", name)) {
+    if (nameHash == 0x81a460bb5df2fb6c /* vkCmdSetEvent2KHR */) {
         *addr = (void *)CmdSetEvent2KHR;
         return true;
     }
-    if (!strcmp("vkCmdResetEvent2KHR", name)) {
+    if (nameHash == 0x8a862e62841ec082 /* vkCmdResetEvent2KHR */) {
         *addr = (void *)CmdResetEvent2KHR;
         return true;
     }
-    if (!strcmp("vkCmdWaitEvents2KHR", name)) {
+    if (nameHash == 0x1b8ec29acf8f9c34 /* vkCmdWaitEvents2KHR */) {
         *addr = (void *)CmdWaitEvents2KHR;
         return true;
     }
-    if (!strcmp("vkCmdPipelineBarrier2KHR", name)) {
+    if (nameHash == 0x47b5e34bc173355d /* vkCmdPipelineBarrier2KHR */) {
         *addr = (void *)CmdPipelineBarrier2KHR;
         return true;
     }
-    if (!strcmp("vkCmdWriteTimestamp2KHR", name)) {
+    if (nameHash == 0x2e9f27714c27c160 /* vkCmdWriteTimestamp2KHR */) {
         *addr = (void *)CmdWriteTimestamp2KHR;
         return true;
     }
-    if (!strcmp("vkQueueSubmit2KHR", name)) {
+    if (nameHash == 0x7eff5818fce6b445 /* vkQueueSubmit2KHR */) {
         *addr = (void *)QueueSubmit2KHR;
         return true;
     }
 
     // ---- VK_KHR_copy_commands2 extension commands
-    if (!strcmp("vkCmdCopyBuffer2KHR", name)) {
+    if (nameHash == 0x4d3f08ecfb5c4893 /* vkCmdCopyBuffer2KHR */) {
         *addr = (void *)CmdCopyBuffer2KHR;
         return true;
     }
-    if (!strcmp("vkCmdCopyImage2KHR", name)) {
+    if (nameHash == 0xb172c9f4537a3da8 /* vkCmdCopyImage2KHR */) {
         *addr = (void *)CmdCopyImage2KHR;
         return true;
     }
-    if (!strcmp("vkCmdCopyBufferToImage2KHR", name)) {
+    if (nameHash == 0xaae6e3e723f39a93 /* vkCmdCopyBufferToImage2KHR */) {
         *addr = (void *)CmdCopyBufferToImage2KHR;
         return true;
     }
-    if (!strcmp("vkCmdCopyImageToBuffer2KHR", name)) {
+    if (nameHash == 0x02eb4358362cbe5f /* vkCmdCopyImageToBuffer2KHR */) {
         *addr = (void *)CmdCopyImageToBuffer2KHR;
         return true;
     }
-    if (!strcmp("vkCmdBlitImage2KHR", name)) {
+    if (nameHash == 0xcdda04206e1c1dfe /* vkCmdBlitImage2KHR */) {
         *addr = (void *)CmdBlitImage2KHR;
         return true;
     }
-    if (!strcmp("vkCmdResolveImage2KHR", name)) {
+    if (nameHash == 0xda6d56b119c97568 /* vkCmdResolveImage2KHR */) {
         *addr = (void *)CmdResolveImage2KHR;
         return true;
     }
 
     // ---- VK_KHR_ray_tracing_maintenance1 extension commands
-    if (!strcmp("vkCmdTraceRaysIndirect2KHR", name)) {
+    if (nameHash == 0x40db28be40a6f866 /* vkCmdTraceRaysIndirect2KHR */) {
         *addr = (void *)CmdTraceRaysIndirect2KHR;
         return true;
     }
 
     // ---- VK_KHR_maintenance4 extension commands
-    if (!strcmp("vkGetDeviceBufferMemoryRequirementsKHR", name)) {
+    if (nameHash == 0x0e4eac678a76ed33 /* vkGetDeviceBufferMemoryRequirementsKHR */) {
         *addr = (void *)GetDeviceBufferMemoryRequirementsKHR;
         return true;
     }
-    if (!strcmp("vkGetDeviceImageMemoryRequirementsKHR", name)) {
+    if (nameHash == 0xb914845a146232bd /* vkGetDeviceImageMemoryRequirementsKHR */) {
         *addr = (void *)GetDeviceImageMemoryRequirementsKHR;
         return true;
     }
-    if (!strcmp("vkGetDeviceImageSparseMemoryRequirementsKHR", name)) {
+    if (nameHash == 0x423629691279d2c9 /* vkGetDeviceImageSparseMemoryRequirementsKHR */) {
         *addr = (void *)GetDeviceImageSparseMemoryRequirementsKHR;
         return true;
     }
 
     // ---- VK_KHR_maintenance5 extension commands
-    if (!strcmp("vkCmdBindIndexBuffer2KHR", name)) {
+    if (nameHash == 0x6fde01fd66c6087a /* vkCmdBindIndexBuffer2KHR */) {
         *addr = (void *)CmdBindIndexBuffer2KHR;
         return true;
     }
-    if (!strcmp("vkGetRenderingAreaGranularityKHR", name)) {
+    if (nameHash == 0xff17500f60079a4b /* vkGetRenderingAreaGranularityKHR */) {
         *addr = (void *)GetRenderingAreaGranularityKHR;
         return true;
     }
-    if (!strcmp("vkGetDeviceImageSubresourceLayoutKHR", name)) {
+    if (nameHash == 0xd1bfa4d3176b81a7 /* vkGetDeviceImageSubresourceLayoutKHR */) {
         *addr = (void *)GetDeviceImageSubresourceLayoutKHR;
         return true;
     }
-    if (!strcmp("vkGetImageSubresourceLayout2KHR", name)) {
+    if (nameHash == 0xfa88974bd2f1055c /* vkGetImageSubresourceLayout2KHR */) {
         *addr = (void *)GetImageSubresourceLayout2KHR;
         return true;
     }
 
     // ---- VK_KHR_pipeline_binary extension commands
-    if (!strcmp("vkCreatePipelineBinariesKHR", name)) {
+    if (nameHash == 0x7b8f5cb6ad62ff2c /* vkCreatePipelineBinariesKHR */) {
         *addr = (void *)CreatePipelineBinariesKHR;
         return true;
     }
-    if (!strcmp("vkDestroyPipelineBinaryKHR", name)) {
+    if (nameHash == 0x5e156baf498f5138 /* vkDestroyPipelineBinaryKHR */) {
         *addr = (void *)DestroyPipelineBinaryKHR;
         return true;
     }
-    if (!strcmp("vkGetPipelineKeyKHR", name)) {
+    if (nameHash == 0xe7ba2bcf3218ef91 /* vkGetPipelineKeyKHR */) {
         *addr = (void *)GetPipelineKeyKHR;
         return true;
     }
-    if (!strcmp("vkGetPipelineBinaryDataKHR", name)) {
+    if (nameHash == 0x3446c4b0e0ed13c7 /* vkGetPipelineBinaryDataKHR */) {
         *addr = (void *)GetPipelineBinaryDataKHR;
         return true;
     }
-    if (!strcmp("vkReleaseCapturedPipelineDataKHR", name)) {
+    if (nameHash == 0x8f433193cdb26798 /* vkReleaseCapturedPipelineDataKHR */) {
         *addr = (void *)ReleaseCapturedPipelineDataKHR;
         return true;
     }
 
     // ---- VK_KHR_cooperative_matrix extension commands
-    if (!strcmp("vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR", name)) {
+    if (nameHash == 0x875c67a6f6143fdd /* vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR */) {
         *addr = (void *)GetPhysicalDeviceCooperativeMatrixPropertiesKHR;
         return true;
     }
 
     // ---- VK_KHR_line_rasterization extension commands
-    if (!strcmp("vkCmdSetLineStippleKHR", name)) {
+    if (nameHash == 0x24f886fa5cebd7ed /* vkCmdSetLineStippleKHR */) {
         *addr = (void *)CmdSetLineStippleKHR;
         return true;
     }
 
     // ---- VK_KHR_calibrated_timestamps extension commands
-    if (!strcmp("vkGetPhysicalDeviceCalibrateableTimeDomainsKHR", name)) {
+    if (nameHash == 0x1a4224a14b693350 /* vkGetPhysicalDeviceCalibrateableTimeDomainsKHR */) {
         *addr = (void *)GetPhysicalDeviceCalibrateableTimeDomainsKHR;
         return true;
     }
-    if (!strcmp("vkGetCalibratedTimestampsKHR", name)) {
+    if (nameHash == 0x0c4f4995392e50ab /* vkGetCalibratedTimestampsKHR */) {
         *addr = (void *)GetCalibratedTimestampsKHR;
         return true;
     }
 
     // ---- VK_KHR_maintenance6 extension commands
-    if (!strcmp("vkCmdBindDescriptorSets2KHR", name)) {
+    if (nameHash == 0xbb625b5594f09b62 /* vkCmdBindDescriptorSets2KHR */) {
         *addr = (void *)CmdBindDescriptorSets2KHR;
         return true;
     }
-    if (!strcmp("vkCmdPushConstants2KHR", name)) {
+    if (nameHash == 0x844e6fc97d32338d /* vkCmdPushConstants2KHR */) {
         *addr = (void *)CmdPushConstants2KHR;
         return true;
     }
-    if (!strcmp("vkCmdPushDescriptorSet2KHR", name)) {
+    if (nameHash == 0xda9d391d34dd9078 /* vkCmdPushDescriptorSet2KHR */) {
         *addr = (void *)CmdPushDescriptorSet2KHR;
         return true;
     }
-    if (!strcmp("vkCmdPushDescriptorSetWithTemplate2KHR", name)) {
+    if (nameHash == 0xf42ac32ac7eb727c /* vkCmdPushDescriptorSetWithTemplate2KHR */) {
         *addr = (void *)CmdPushDescriptorSetWithTemplate2KHR;
         return true;
     }
-    if (!strcmp("vkCmdSetDescriptorBufferOffsets2EXT", name)) {
+    if (nameHash == 0x5d404fade6187f05 /* vkCmdSetDescriptorBufferOffsets2EXT */) {
         *addr = (void *)CmdSetDescriptorBufferOffsets2EXT;
         return true;
     }
-    if (!strcmp("vkCmdBindDescriptorBufferEmbeddedSamplers2EXT", name)) {
+    if (nameHash == 0x908be4be59b54bee /* vkCmdBindDescriptorBufferEmbeddedSamplers2EXT */) {
         *addr = (void *)CmdBindDescriptorBufferEmbeddedSamplers2EXT;
         return true;
     }
 
     // ---- VK_EXT_debug_marker extension commands
-    if (!strcmp("vkDebugMarkerSetObjectTagEXT", name)) {
+    if (nameHash == 0xa739034f864fc640 /* vkDebugMarkerSetObjectTagEXT */) {
         *addr = (void *)DebugMarkerSetObjectTagEXT;
         return true;
     }
-    if (!strcmp("vkDebugMarkerSetObjectNameEXT", name)) {
+    if (nameHash == 0xb1c51323a9aecd49 /* vkDebugMarkerSetObjectNameEXT */) {
         *addr = (void *)DebugMarkerSetObjectNameEXT;
         return true;
     }
-    if (!strcmp("vkCmdDebugMarkerBeginEXT", name)) {
+    if (nameHash == 0xba7d020dda50aee4 /* vkCmdDebugMarkerBeginEXT */) {
         *addr = (void *)CmdDebugMarkerBeginEXT;
         return true;
     }
-    if (!strcmp("vkCmdDebugMarkerEndEXT", name)) {
+    if (nameHash == 0x96d500101d2c0cfc /* vkCmdDebugMarkerEndEXT */) {
         *addr = (void *)CmdDebugMarkerEndEXT;
         return true;
     }
-    if (!strcmp("vkCmdDebugMarkerInsertEXT", name)) {
+    if (nameHash == 0x09da53bc6b918573 /* vkCmdDebugMarkerInsertEXT */) {
         *addr = (void *)CmdDebugMarkerInsertEXT;
         return true;
     }
 
     // ---- VK_EXT_transform_feedback extension commands
-    if (!strcmp("vkCmdBindTransformFeedbackBuffersEXT", name)) {
+    if (nameHash == 0x24975600fb49fd73 /* vkCmdBindTransformFeedbackBuffersEXT */) {
         *addr = (void *)CmdBindTransformFeedbackBuffersEXT;
         return true;
     }
-    if (!strcmp("vkCmdBeginTransformFeedbackEXT", name)) {
+    if (nameHash == 0xae000b2715cd085c /* vkCmdBeginTransformFeedbackEXT */) {
         *addr = (void *)CmdBeginTransformFeedbackEXT;
         return true;
     }
-    if (!strcmp("vkCmdEndTransformFeedbackEXT", name)) {
+    if (nameHash == 0x20681e0c6bf30380 /* vkCmdEndTransformFeedbackEXT */) {
         *addr = (void *)CmdEndTransformFeedbackEXT;
         return true;
     }
-    if (!strcmp("vkCmdBeginQueryIndexedEXT", name)) {
+    if (nameHash == 0xa3c120c4c081785a /* vkCmdBeginQueryIndexedEXT */) {
         *addr = (void *)CmdBeginQueryIndexedEXT;
         return true;
     }
-    if (!strcmp("vkCmdEndQueryIndexedEXT", name)) {
+    if (nameHash == 0xcb5126a43f13e1de /* vkCmdEndQueryIndexedEXT */) {
         *addr = (void *)CmdEndQueryIndexedEXT;
         return true;
     }
-    if (!strcmp("vkCmdDrawIndirectByteCountEXT", name)) {
+    if (nameHash == 0x1028e41b255d6802 /* vkCmdDrawIndirectByteCountEXT */) {
         *addr = (void *)CmdDrawIndirectByteCountEXT;
         return true;
     }
 
     // ---- VK_NVX_binary_import extension commands
-    if (!strcmp("vkCreateCuModuleNVX", name)) {
+    if (nameHash == 0x70f16cd080e5a1e1 /* vkCreateCuModuleNVX */) {
         *addr = (void *)CreateCuModuleNVX;
         return true;
     }
-    if (!strcmp("vkCreateCuFunctionNVX", name)) {
+    if (nameHash == 0x9df40d3bb19dc7f0 /* vkCreateCuFunctionNVX */) {
         *addr = (void *)CreateCuFunctionNVX;
         return true;
     }
-    if (!strcmp("vkDestroyCuModuleNVX", name)) {
+    if (nameHash == 0xa47abcf416f45e13 /* vkDestroyCuModuleNVX */) {
         *addr = (void *)DestroyCuModuleNVX;
         return true;
     }
-    if (!strcmp("vkDestroyCuFunctionNVX", name)) {
+    if (nameHash == 0xe9321def2e9912ac /* vkDestroyCuFunctionNVX */) {
         *addr = (void *)DestroyCuFunctionNVX;
         return true;
     }
-    if (!strcmp("vkCmdCuLaunchKernelNVX", name)) {
+    if (nameHash == 0xc8ce9307051f9bc4 /* vkCmdCuLaunchKernelNVX */) {
         *addr = (void *)CmdCuLaunchKernelNVX;
         return true;
     }
 
     // ---- VK_NVX_image_view_handle extension commands
-    if (!strcmp("vkGetImageViewHandleNVX", name)) {
+    if (nameHash == 0x1b250d8529b8c649 /* vkGetImageViewHandleNVX */) {
         *addr = (void *)GetImageViewHandleNVX;
         return true;
     }
-    if (!strcmp("vkGetImageViewHandle64NVX", name)) {
+    if (nameHash == 0x45e8058b548405ce /* vkGetImageViewHandle64NVX */) {
         *addr = (void *)GetImageViewHandle64NVX;
         return true;
     }
-    if (!strcmp("vkGetImageViewAddressNVX", name)) {
+    if (nameHash == 0x2c6e7da8d69f6259 /* vkGetImageViewAddressNVX */) {
         *addr = (void *)GetImageViewAddressNVX;
         return true;
     }
 
     // ---- VK_AMD_draw_indirect_count extension commands
-    if (!strcmp("vkCmdDrawIndirectCountAMD", name)) {
+    if (nameHash == 0x658b77dd8968ff3b /* vkCmdDrawIndirectCountAMD */) {
         *addr = (void *)CmdDrawIndirectCountAMD;
         return true;
     }
-    if (!strcmp("vkCmdDrawIndexedIndirectCountAMD", name)) {
+    if (nameHash == 0x95e478a17bd017c9 /* vkCmdDrawIndexedIndirectCountAMD */) {
         *addr = (void *)CmdDrawIndexedIndirectCountAMD;
         return true;
     }
 
     // ---- VK_AMD_shader_info extension commands
-    if (!strcmp("vkGetShaderInfoAMD", name)) {
+    if (nameHash == 0x899487a9c9bfa851 /* vkGetShaderInfoAMD */) {
         *addr = (void *)GetShaderInfoAMD;
         return true;
     }
 
     // ---- VK_NV_external_memory_capabilities extension commands
-    if (!strcmp("vkGetPhysicalDeviceExternalImageFormatPropertiesNV", name)) {
+    if (nameHash == 0x47ac80818c4e0a8a /* vkGetPhysicalDeviceExternalImageFormatPropertiesNV */) {
         *addr = (ptr_instance->enabled_known_extensions.nv_external_memory_capabilities == 1)
                      ? (void *)GetPhysicalDeviceExternalImageFormatPropertiesNV
                      : NULL;
@@ -10969,30 +10969,30 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
 
     // ---- VK_NV_external_memory_win32 extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp("vkGetMemoryWin32HandleNV", name)) {
+    if (nameHash == 0xc21c28ddac3fbec3 /* vkGetMemoryWin32HandleNV */) {
         *addr = (void *)GetMemoryWin32HandleNV;
         return true;
     }
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_EXT_conditional_rendering extension commands
-    if (!strcmp("vkCmdBeginConditionalRenderingEXT", name)) {
+    if (nameHash == 0x73bc2739d085085f /* vkCmdBeginConditionalRenderingEXT */) {
         *addr = (void *)CmdBeginConditionalRenderingEXT;
         return true;
     }
-    if (!strcmp("vkCmdEndConditionalRenderingEXT", name)) {
+    if (nameHash == 0x1812390287e35f0c /* vkCmdEndConditionalRenderingEXT */) {
         *addr = (void *)CmdEndConditionalRenderingEXT;
         return true;
     }
 
     // ---- VK_NV_clip_space_w_scaling extension commands
-    if (!strcmp("vkCmdSetViewportWScalingNV", name)) {
+    if (nameHash == 0xb67ff6e303d3c4fb /* vkCmdSetViewportWScalingNV */) {
         *addr = (void *)CmdSetViewportWScalingNV;
         return true;
     }
 
     // ---- VK_EXT_direct_mode_display extension commands
-    if (!strcmp("vkReleaseDisplayEXT", name)) {
+    if (nameHash == 0x07d7f65f9502b047 /* vkReleaseDisplayEXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_direct_mode_display == 1)
                      ? (void *)ReleaseDisplayEXT
                      : NULL;
@@ -11001,7 +11001,7 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
 
     // ---- VK_EXT_acquire_xlib_display extension commands
 #if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
-    if (!strcmp("vkAcquireXlibDisplayEXT", name)) {
+    if (nameHash == 0xd07a635e04a59475 /* vkAcquireXlibDisplayEXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_acquire_xlib_display == 1)
                      ? (void *)AcquireXlibDisplayEXT
                      : NULL;
@@ -11009,7 +11009,7 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
     }
 #endif // VK_USE_PLATFORM_XLIB_XRANDR_EXT
 #if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
-    if (!strcmp("vkGetRandROutputDisplayEXT", name)) {
+    if (nameHash == 0x3d31a6a7bedfba51 /* vkGetRandROutputDisplayEXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_acquire_xlib_display == 1)
                      ? (void *)GetRandROutputDisplayEXT
                      : NULL;
@@ -11018,7 +11018,7 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
 #endif // VK_USE_PLATFORM_XLIB_XRANDR_EXT
 
     // ---- VK_EXT_display_surface_counter extension commands
-    if (!strcmp("vkGetPhysicalDeviceSurfaceCapabilities2EXT", name)) {
+    if (nameHash == 0xdc45f87f50da94d9 /* vkGetPhysicalDeviceSurfaceCapabilities2EXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_display_surface_counter == 1)
                      ? (void *)GetPhysicalDeviceSurfaceCapabilities2EXT
                      : NULL;
@@ -11026,97 +11026,97 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
     }
 
     // ---- VK_EXT_display_control extension commands
-    if (!strcmp("vkDisplayPowerControlEXT", name)) {
+    if (nameHash == 0x2bd217fc8713bb23 /* vkDisplayPowerControlEXT */) {
         *addr = (void *)DisplayPowerControlEXT;
         return true;
     }
-    if (!strcmp("vkRegisterDeviceEventEXT", name)) {
+    if (nameHash == 0x8a4301ac1aeca958 /* vkRegisterDeviceEventEXT */) {
         *addr = (void *)RegisterDeviceEventEXT;
         return true;
     }
-    if (!strcmp("vkRegisterDisplayEventEXT", name)) {
+    if (nameHash == 0x21f4e40d1b10ea20 /* vkRegisterDisplayEventEXT */) {
         *addr = (void *)RegisterDisplayEventEXT;
         return true;
     }
-    if (!strcmp("vkGetSwapchainCounterEXT", name)) {
+    if (nameHash == 0x04134f0c5694394f /* vkGetSwapchainCounterEXT */) {
         *addr = (void *)GetSwapchainCounterEXT;
         return true;
     }
 
     // ---- VK_GOOGLE_display_timing extension commands
-    if (!strcmp("vkGetRefreshCycleDurationGOOGLE", name)) {
+    if (nameHash == 0x9fd2d4176909d303 /* vkGetRefreshCycleDurationGOOGLE */) {
         *addr = (void *)GetRefreshCycleDurationGOOGLE;
         return true;
     }
-    if (!strcmp("vkGetPastPresentationTimingGOOGLE", name)) {
+    if (nameHash == 0x5dcda38c668184b8 /* vkGetPastPresentationTimingGOOGLE */) {
         *addr = (void *)GetPastPresentationTimingGOOGLE;
         return true;
     }
 
     // ---- VK_EXT_discard_rectangles extension commands
-    if (!strcmp("vkCmdSetDiscardRectangleEXT", name)) {
+    if (nameHash == 0x92bb34229e07c467 /* vkCmdSetDiscardRectangleEXT */) {
         *addr = (void *)CmdSetDiscardRectangleEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetDiscardRectangleEnableEXT", name)) {
+    if (nameHash == 0xae74bca0714f1b3b /* vkCmdSetDiscardRectangleEnableEXT */) {
         *addr = (void *)CmdSetDiscardRectangleEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetDiscardRectangleModeEXT", name)) {
+    if (nameHash == 0xe5686168ac2e1c2a /* vkCmdSetDiscardRectangleModeEXT */) {
         *addr = (void *)CmdSetDiscardRectangleModeEXT;
         return true;
     }
 
     // ---- VK_EXT_hdr_metadata extension commands
-    if (!strcmp("vkSetHdrMetadataEXT", name)) {
+    if (nameHash == 0x35a324447b0101e4 /* vkSetHdrMetadataEXT */) {
         *addr = (void *)SetHdrMetadataEXT;
         return true;
     }
 
     // ---- VK_EXT_debug_utils extension commands
-    if (!strcmp("vkSetDebugUtilsObjectNameEXT", name)) {
+    if (nameHash == 0xfccd697bc5cf4494 /* vkSetDebugUtilsObjectNameEXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_debug_utils == 1)
                      ? (void *)SetDebugUtilsObjectNameEXT
                      : NULL;
         return true;
     }
-    if (!strcmp("vkSetDebugUtilsObjectTagEXT", name)) {
+    if (nameHash == 0x7fd35824391d47a4 /* vkSetDebugUtilsObjectTagEXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_debug_utils == 1)
                      ? (void *)SetDebugUtilsObjectTagEXT
                      : NULL;
         return true;
     }
-    if (!strcmp("vkQueueBeginDebugUtilsLabelEXT", name)) {
+    if (nameHash == 0xd88e4fe9c0329771 /* vkQueueBeginDebugUtilsLabelEXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_debug_utils == 1)
                      ? (void *)QueueBeginDebugUtilsLabelEXT
                      : NULL;
         return true;
     }
-    if (!strcmp("vkQueueEndDebugUtilsLabelEXT", name)) {
+    if (nameHash == 0x6756af5e610d6533 /* vkQueueEndDebugUtilsLabelEXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_debug_utils == 1)
                      ? (void *)QueueEndDebugUtilsLabelEXT
                      : NULL;
         return true;
     }
-    if (!strcmp("vkQueueInsertDebugUtilsLabelEXT", name)) {
+    if (nameHash == 0xe2b6c462d682d0aa /* vkQueueInsertDebugUtilsLabelEXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_debug_utils == 1)
                      ? (void *)QueueInsertDebugUtilsLabelEXT
                      : NULL;
         return true;
     }
-    if (!strcmp("vkCmdBeginDebugUtilsLabelEXT", name)) {
+    if (nameHash == 0xa53a9028f9deee27 /* vkCmdBeginDebugUtilsLabelEXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_debug_utils == 1)
                      ? (void *)CmdBeginDebugUtilsLabelEXT
                      : NULL;
         return true;
     }
-    if (!strcmp("vkCmdEndDebugUtilsLabelEXT", name)) {
+    if (nameHash == 0xb70a1f7b0d640472 /* vkCmdEndDebugUtilsLabelEXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_debug_utils == 1)
                      ? (void *)CmdEndDebugUtilsLabelEXT
                      : NULL;
         return true;
     }
-    if (!strcmp("vkCmdInsertDebugUtilsLabelEXT", name)) {
+    if (nameHash == 0x0f70146a40b73eaf /* vkCmdInsertDebugUtilsLabelEXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_debug_utils == 1)
                      ? (void *)CmdInsertDebugUtilsLabelEXT
                      : NULL;
@@ -11125,13 +11125,13 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
 
     // ---- VK_ANDROID_external_memory_android_hardware_buffer extension commands
 #if defined(VK_USE_PLATFORM_ANDROID_KHR)
-    if (!strcmp("vkGetAndroidHardwareBufferPropertiesANDROID", name)) {
+    if (nameHash == 0x0e2e5dfee87cb6bc /* vkGetAndroidHardwareBufferPropertiesANDROID */) {
         *addr = (void *)GetAndroidHardwareBufferPropertiesANDROID;
         return true;
     }
 #endif // VK_USE_PLATFORM_ANDROID_KHR
 #if defined(VK_USE_PLATFORM_ANDROID_KHR)
-    if (!strcmp("vkGetMemoryAndroidHardwareBufferANDROID", name)) {
+    if (nameHash == 0x821ae6559b48f066 /* vkGetMemoryAndroidHardwareBufferANDROID */) {
         *addr = (void *)GetMemoryAndroidHardwareBufferANDROID;
         return true;
     }
@@ -11139,438 +11139,438 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
 
     // ---- VK_AMDX_shader_enqueue extension commands
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp("vkCreateExecutionGraphPipelinesAMDX", name)) {
+    if (nameHash == 0x714129686c9da431 /* vkCreateExecutionGraphPipelinesAMDX */) {
         *addr = (void *)CreateExecutionGraphPipelinesAMDX;
         return true;
     }
 #endif // VK_ENABLE_BETA_EXTENSIONS
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp("vkGetExecutionGraphPipelineScratchSizeAMDX", name)) {
+    if (nameHash == 0x272dc15f9cab3de4 /* vkGetExecutionGraphPipelineScratchSizeAMDX */) {
         *addr = (void *)GetExecutionGraphPipelineScratchSizeAMDX;
         return true;
     }
 #endif // VK_ENABLE_BETA_EXTENSIONS
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp("vkGetExecutionGraphPipelineNodeIndexAMDX", name)) {
+    if (nameHash == 0x9c10b26ceb8d7cd4 /* vkGetExecutionGraphPipelineNodeIndexAMDX */) {
         *addr = (void *)GetExecutionGraphPipelineNodeIndexAMDX;
         return true;
     }
 #endif // VK_ENABLE_BETA_EXTENSIONS
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp("vkCmdInitializeGraphScratchMemoryAMDX", name)) {
+    if (nameHash == 0xa143601d567d78a8 /* vkCmdInitializeGraphScratchMemoryAMDX */) {
         *addr = (void *)CmdInitializeGraphScratchMemoryAMDX;
         return true;
     }
 #endif // VK_ENABLE_BETA_EXTENSIONS
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp("vkCmdDispatchGraphAMDX", name)) {
+    if (nameHash == 0xf31eeaf76f0b6dca /* vkCmdDispatchGraphAMDX */) {
         *addr = (void *)CmdDispatchGraphAMDX;
         return true;
     }
 #endif // VK_ENABLE_BETA_EXTENSIONS
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp("vkCmdDispatchGraphIndirectAMDX", name)) {
+    if (nameHash == 0x4e7d037aae3a3033 /* vkCmdDispatchGraphIndirectAMDX */) {
         *addr = (void *)CmdDispatchGraphIndirectAMDX;
         return true;
     }
 #endif // VK_ENABLE_BETA_EXTENSIONS
 #if defined(VK_ENABLE_BETA_EXTENSIONS)
-    if (!strcmp("vkCmdDispatchGraphIndirectCountAMDX", name)) {
+    if (nameHash == 0xd8c4bb7f3586d513 /* vkCmdDispatchGraphIndirectCountAMDX */) {
         *addr = (void *)CmdDispatchGraphIndirectCountAMDX;
         return true;
     }
 #endif // VK_ENABLE_BETA_EXTENSIONS
 
     // ---- VK_EXT_sample_locations extension commands
-    if (!strcmp("vkCmdSetSampleLocationsEXT", name)) {
+    if (nameHash == 0xfa5d78b1a973792e /* vkCmdSetSampleLocationsEXT */) {
         *addr = (void *)CmdSetSampleLocationsEXT;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceMultisamplePropertiesEXT", name)) {
+    if (nameHash == 0x57fddf2e7905b565 /* vkGetPhysicalDeviceMultisamplePropertiesEXT */) {
         *addr = (void *)GetPhysicalDeviceMultisamplePropertiesEXT;
         return true;
     }
 
     // ---- VK_EXT_image_drm_format_modifier extension commands
-    if (!strcmp("vkGetImageDrmFormatModifierPropertiesEXT", name)) {
+    if (nameHash == 0x85f72ff33d09f9fc /* vkGetImageDrmFormatModifierPropertiesEXT */) {
         *addr = (void *)GetImageDrmFormatModifierPropertiesEXT;
         return true;
     }
 
     // ---- VK_EXT_validation_cache extension commands
-    if (!strcmp("vkCreateValidationCacheEXT", name)) {
+    if (nameHash == 0x80ad81694be917a9 /* vkCreateValidationCacheEXT */) {
         *addr = (void *)CreateValidationCacheEXT;
         return true;
     }
-    if (!strcmp("vkDestroyValidationCacheEXT", name)) {
+    if (nameHash == 0xc522092927d98161 /* vkDestroyValidationCacheEXT */) {
         *addr = (void *)DestroyValidationCacheEXT;
         return true;
     }
-    if (!strcmp("vkMergeValidationCachesEXT", name)) {
+    if (nameHash == 0x91b293db19f39ca5 /* vkMergeValidationCachesEXT */) {
         *addr = (void *)MergeValidationCachesEXT;
         return true;
     }
-    if (!strcmp("vkGetValidationCacheDataEXT", name)) {
+    if (nameHash == 0x10635a7a4fcc2c76 /* vkGetValidationCacheDataEXT */) {
         *addr = (void *)GetValidationCacheDataEXT;
         return true;
     }
 
     // ---- VK_NV_shading_rate_image extension commands
-    if (!strcmp("vkCmdBindShadingRateImageNV", name)) {
+    if (nameHash == 0x36135fe5c54d3b34 /* vkCmdBindShadingRateImageNV */) {
         *addr = (void *)CmdBindShadingRateImageNV;
         return true;
     }
-    if (!strcmp("vkCmdSetViewportShadingRatePaletteNV", name)) {
+    if (nameHash == 0x26c37395ff9739bc /* vkCmdSetViewportShadingRatePaletteNV */) {
         *addr = (void *)CmdSetViewportShadingRatePaletteNV;
         return true;
     }
-    if (!strcmp("vkCmdSetCoarseSampleOrderNV", name)) {
+    if (nameHash == 0x12ca3f3ec96315f3 /* vkCmdSetCoarseSampleOrderNV */) {
         *addr = (void *)CmdSetCoarseSampleOrderNV;
         return true;
     }
 
     // ---- VK_NV_ray_tracing extension commands
-    if (!strcmp("vkCreateAccelerationStructureNV", name)) {
+    if (nameHash == 0x3ce0faf5d18dc25b /* vkCreateAccelerationStructureNV */) {
         *addr = (void *)CreateAccelerationStructureNV;
         return true;
     }
-    if (!strcmp("vkDestroyAccelerationStructureNV", name)) {
+    if (nameHash == 0xfe4be9de353f2023 /* vkDestroyAccelerationStructureNV */) {
         *addr = (void *)DestroyAccelerationStructureNV;
         return true;
     }
-    if (!strcmp("vkGetAccelerationStructureMemoryRequirementsNV", name)) {
+    if (nameHash == 0x5c965829c780d9f3 /* vkGetAccelerationStructureMemoryRequirementsNV */) {
         *addr = (void *)GetAccelerationStructureMemoryRequirementsNV;
         return true;
     }
-    if (!strcmp("vkBindAccelerationStructureMemoryNV", name)) {
+    if (nameHash == 0x6e0d98ae9ace40d5 /* vkBindAccelerationStructureMemoryNV */) {
         *addr = (void *)BindAccelerationStructureMemoryNV;
         return true;
     }
-    if (!strcmp("vkCmdBuildAccelerationStructureNV", name)) {
+    if (nameHash == 0x4092cc86b9e7806e /* vkCmdBuildAccelerationStructureNV */) {
         *addr = (void *)CmdBuildAccelerationStructureNV;
         return true;
     }
-    if (!strcmp("vkCmdCopyAccelerationStructureNV", name)) {
+    if (nameHash == 0x1d7e628cb67db142 /* vkCmdCopyAccelerationStructureNV */) {
         *addr = (void *)CmdCopyAccelerationStructureNV;
         return true;
     }
-    if (!strcmp("vkCmdTraceRaysNV", name)) {
+    if (nameHash == 0x877be98356e2a511 /* vkCmdTraceRaysNV */) {
         *addr = (void *)CmdTraceRaysNV;
         return true;
     }
-    if (!strcmp("vkCreateRayTracingPipelinesNV", name)) {
+    if (nameHash == 0x4d0e89b321a6faef /* vkCreateRayTracingPipelinesNV */) {
         *addr = (void *)CreateRayTracingPipelinesNV;
         return true;
     }
-    if (!strcmp("vkGetRayTracingShaderGroupHandlesKHR", name)) {
+    if (nameHash == 0x0802604e7494d3a4 /* vkGetRayTracingShaderGroupHandlesKHR */) {
         *addr = (void *)GetRayTracingShaderGroupHandlesKHR;
         return true;
     }
-    if (!strcmp("vkGetRayTracingShaderGroupHandlesNV", name)) {
+    if (nameHash == 0x8bd0b4949f3f2aa3 /* vkGetRayTracingShaderGroupHandlesNV */) {
         *addr = (void *)GetRayTracingShaderGroupHandlesNV;
         return true;
     }
-    if (!strcmp("vkGetAccelerationStructureHandleNV", name)) {
+    if (nameHash == 0x9e1cf02c5780b2d6 /* vkGetAccelerationStructureHandleNV */) {
         *addr = (void *)GetAccelerationStructureHandleNV;
         return true;
     }
-    if (!strcmp("vkCmdWriteAccelerationStructuresPropertiesNV", name)) {
+    if (nameHash == 0x9f690b963d6e97a7 /* vkCmdWriteAccelerationStructuresPropertiesNV */) {
         *addr = (void *)CmdWriteAccelerationStructuresPropertiesNV;
         return true;
     }
-    if (!strcmp("vkCompileDeferredNV", name)) {
+    if (nameHash == 0xe7b1ed7ad6f748f7 /* vkCompileDeferredNV */) {
         *addr = (void *)CompileDeferredNV;
         return true;
     }
 
     // ---- VK_EXT_external_memory_host extension commands
-    if (!strcmp("vkGetMemoryHostPointerPropertiesEXT", name)) {
+    if (nameHash == 0x70cfd8006341080a /* vkGetMemoryHostPointerPropertiesEXT */) {
         *addr = (void *)GetMemoryHostPointerPropertiesEXT;
         return true;
     }
 
     // ---- VK_AMD_buffer_marker extension commands
-    if (!strcmp("vkCmdWriteBufferMarkerAMD", name)) {
+    if (nameHash == 0x75e32a36acf72579 /* vkCmdWriteBufferMarkerAMD */) {
         *addr = (void *)CmdWriteBufferMarkerAMD;
         return true;
     }
-    if (!strcmp("vkCmdWriteBufferMarker2AMD", name)) {
+    if (nameHash == 0xb523ea07e8e7d77f /* vkCmdWriteBufferMarker2AMD */) {
         *addr = (void *)CmdWriteBufferMarker2AMD;
         return true;
     }
 
     // ---- VK_EXT_calibrated_timestamps extension commands
-    if (!strcmp("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", name)) {
+    if (nameHash == 0x5cd180715ec81628 /* vkGetPhysicalDeviceCalibrateableTimeDomainsEXT */) {
         *addr = (void *)GetPhysicalDeviceCalibrateableTimeDomainsEXT;
         return true;
     }
-    if (!strcmp("vkGetCalibratedTimestampsEXT", name)) {
+    if (nameHash == 0x49a74d66be4fce8b /* vkGetCalibratedTimestampsEXT */) {
         *addr = (void *)GetCalibratedTimestampsEXT;
         return true;
     }
 
     // ---- VK_NV_mesh_shader extension commands
-    if (!strcmp("vkCmdDrawMeshTasksNV", name)) {
+    if (nameHash == 0xb0aeacfa9fc521aa /* vkCmdDrawMeshTasksNV */) {
         *addr = (void *)CmdDrawMeshTasksNV;
         return true;
     }
-    if (!strcmp("vkCmdDrawMeshTasksIndirectNV", name)) {
+    if (nameHash == 0x56698661adbb7534 /* vkCmdDrawMeshTasksIndirectNV */) {
         *addr = (void *)CmdDrawMeshTasksIndirectNV;
         return true;
     }
-    if (!strcmp("vkCmdDrawMeshTasksIndirectCountNV", name)) {
+    if (nameHash == 0xae68bbafa60e1bfd /* vkCmdDrawMeshTasksIndirectCountNV */) {
         *addr = (void *)CmdDrawMeshTasksIndirectCountNV;
         return true;
     }
 
     // ---- VK_NV_scissor_exclusive extension commands
-    if (!strcmp("vkCmdSetExclusiveScissorEnableNV", name)) {
+    if (nameHash == 0x085d172fa3bb5527 /* vkCmdSetExclusiveScissorEnableNV */) {
         *addr = (void *)CmdSetExclusiveScissorEnableNV;
         return true;
     }
-    if (!strcmp("vkCmdSetExclusiveScissorNV", name)) {
+    if (nameHash == 0x429417467467b909 /* vkCmdSetExclusiveScissorNV */) {
         *addr = (void *)CmdSetExclusiveScissorNV;
         return true;
     }
 
     // ---- VK_NV_device_diagnostic_checkpoints extension commands
-    if (!strcmp("vkCmdSetCheckpointNV", name)) {
+    if (nameHash == 0x35ddb5f0819f35bf /* vkCmdSetCheckpointNV */) {
         *addr = (void *)CmdSetCheckpointNV;
         return true;
     }
-    if (!strcmp("vkGetQueueCheckpointDataNV", name)) {
+    if (nameHash == 0x3d8f82b873097a02 /* vkGetQueueCheckpointDataNV */) {
         *addr = (void *)GetQueueCheckpointDataNV;
         return true;
     }
-    if (!strcmp("vkGetQueueCheckpointData2NV", name)) {
+    if (nameHash == 0x66d07f2af74e8d8b /* vkGetQueueCheckpointData2NV */) {
         *addr = (void *)GetQueueCheckpointData2NV;
         return true;
     }
 
     // ---- VK_INTEL_performance_query extension commands
-    if (!strcmp("vkInitializePerformanceApiINTEL", name)) {
+    if (nameHash == 0xaaee8606a2f000f3 /* vkInitializePerformanceApiINTEL */) {
         *addr = (void *)InitializePerformanceApiINTEL;
         return true;
     }
-    if (!strcmp("vkUninitializePerformanceApiINTEL", name)) {
+    if (nameHash == 0xef99360f052b923d /* vkUninitializePerformanceApiINTEL */) {
         *addr = (void *)UninitializePerformanceApiINTEL;
         return true;
     }
-    if (!strcmp("vkCmdSetPerformanceMarkerINTEL", name)) {
+    if (nameHash == 0x4888445b33d1d1a9 /* vkCmdSetPerformanceMarkerINTEL */) {
         *addr = (void *)CmdSetPerformanceMarkerINTEL;
         return true;
     }
-    if (!strcmp("vkCmdSetPerformanceStreamMarkerINTEL", name)) {
+    if (nameHash == 0xc0b67df33e46a5f0 /* vkCmdSetPerformanceStreamMarkerINTEL */) {
         *addr = (void *)CmdSetPerformanceStreamMarkerINTEL;
         return true;
     }
-    if (!strcmp("vkCmdSetPerformanceOverrideINTEL", name)) {
+    if (nameHash == 0x81a2503b2e89f09e /* vkCmdSetPerformanceOverrideINTEL */) {
         *addr = (void *)CmdSetPerformanceOverrideINTEL;
         return true;
     }
-    if (!strcmp("vkAcquirePerformanceConfigurationINTEL", name)) {
+    if (nameHash == 0x1173dfede1e58b0e /* vkAcquirePerformanceConfigurationINTEL */) {
         *addr = (void *)AcquirePerformanceConfigurationINTEL;
         return true;
     }
-    if (!strcmp("vkReleasePerformanceConfigurationINTEL", name)) {
+    if (nameHash == 0x480770881849ff9e /* vkReleasePerformanceConfigurationINTEL */) {
         *addr = (void *)ReleasePerformanceConfigurationINTEL;
         return true;
     }
-    if (!strcmp("vkQueueSetPerformanceConfigurationINTEL", name)) {
+    if (nameHash == 0x22611ab44638175f /* vkQueueSetPerformanceConfigurationINTEL */) {
         *addr = (void *)QueueSetPerformanceConfigurationINTEL;
         return true;
     }
-    if (!strcmp("vkGetPerformanceParameterINTEL", name)) {
+    if (nameHash == 0x49bda364217fc34a /* vkGetPerformanceParameterINTEL */) {
         *addr = (void *)GetPerformanceParameterINTEL;
         return true;
     }
 
     // ---- VK_AMD_display_native_hdr extension commands
-    if (!strcmp("vkSetLocalDimmingAMD", name)) {
+    if (nameHash == 0x7629dff55e4d0af3 /* vkSetLocalDimmingAMD */) {
         *addr = (void *)SetLocalDimmingAMD;
         return true;
     }
 
     // ---- VK_EXT_buffer_device_address extension commands
-    if (!strcmp("vkGetBufferDeviceAddressEXT", name)) {
+    if (nameHash == 0x399268bd1fae323b /* vkGetBufferDeviceAddressEXT */) {
         *addr = (void *)GetBufferDeviceAddressEXT;
         return true;
     }
 
     // ---- VK_EXT_tooling_info extension commands
-    if (!strcmp("vkGetPhysicalDeviceToolPropertiesEXT", name)) {
+    if (nameHash == 0x537299821dbd504f /* vkGetPhysicalDeviceToolPropertiesEXT */) {
         *addr = (void *)GetPhysicalDeviceToolPropertiesEXT;
         return true;
     }
 
     // ---- VK_NV_cooperative_matrix extension commands
-    if (!strcmp("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", name)) {
+    if (nameHash == 0xbd9b598956c7366a /* vkGetPhysicalDeviceCooperativeMatrixPropertiesNV */) {
         *addr = (void *)GetPhysicalDeviceCooperativeMatrixPropertiesNV;
         return true;
     }
 
     // ---- VK_NV_coverage_reduction_mode extension commands
-    if (!strcmp("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", name)) {
+    if (nameHash == 0xf43459aa9a0dd505 /* vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV */) {
         *addr = (void *)GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV;
         return true;
     }
 
     // ---- VK_EXT_full_screen_exclusive extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp("vkGetPhysicalDeviceSurfacePresentModes2EXT", name)) {
+    if (nameHash == 0xb4e2ff145e115a30 /* vkGetPhysicalDeviceSurfacePresentModes2EXT */) {
         *addr = (void *)GetPhysicalDeviceSurfacePresentModes2EXT;
         return true;
     }
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp("vkAcquireFullScreenExclusiveModeEXT", name)) {
+    if (nameHash == 0x269c5788bd9937d1 /* vkAcquireFullScreenExclusiveModeEXT */) {
         *addr = (void *)AcquireFullScreenExclusiveModeEXT;
         return true;
     }
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp("vkReleaseFullScreenExclusiveModeEXT", name)) {
+    if (nameHash == 0xdad4b40f2b59becc /* vkReleaseFullScreenExclusiveModeEXT */) {
         *addr = (void *)ReleaseFullScreenExclusiveModeEXT;
         return true;
     }
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp("vkGetDeviceGroupSurfacePresentModes2EXT", name)) {
+    if (nameHash == 0x9166d9b745afd8af /* vkGetDeviceGroupSurfacePresentModes2EXT */) {
         *addr = (void *)GetDeviceGroupSurfacePresentModes2EXT;
         return true;
     }
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_EXT_line_rasterization extension commands
-    if (!strcmp("vkCmdSetLineStippleEXT", name)) {
+    if (nameHash == 0x10cb3a8400778673 /* vkCmdSetLineStippleEXT */) {
         *addr = (void *)CmdSetLineStippleEXT;
         return true;
     }
 
     // ---- VK_EXT_host_query_reset extension commands
-    if (!strcmp("vkResetQueryPoolEXT", name)) {
+    if (nameHash == 0x40648ed2af7eecdd /* vkResetQueryPoolEXT */) {
         *addr = (void *)ResetQueryPoolEXT;
         return true;
     }
 
     // ---- VK_EXT_extended_dynamic_state extension commands
-    if (!strcmp("vkCmdSetCullModeEXT", name)) {
+    if (nameHash == 0x8ad52c133e5fcc89 /* vkCmdSetCullModeEXT */) {
         *addr = (void *)CmdSetCullModeEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetFrontFaceEXT", name)) {
+    if (nameHash == 0x335573b897d8b48c /* vkCmdSetFrontFaceEXT */) {
         *addr = (void *)CmdSetFrontFaceEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetPrimitiveTopologyEXT", name)) {
+    if (nameHash == 0xf991ab3939955de5 /* vkCmdSetPrimitiveTopologyEXT */) {
         *addr = (void *)CmdSetPrimitiveTopologyEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetViewportWithCountEXT", name)) {
+    if (nameHash == 0xffa40d4e01bf3cc0 /* vkCmdSetViewportWithCountEXT */) {
         *addr = (void *)CmdSetViewportWithCountEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetScissorWithCountEXT", name)) {
+    if (nameHash == 0x6aa7b18e001aa3e3 /* vkCmdSetScissorWithCountEXT */) {
         *addr = (void *)CmdSetScissorWithCountEXT;
         return true;
     }
-    if (!strcmp("vkCmdBindVertexBuffers2EXT", name)) {
+    if (nameHash == 0x95e7e04ef3cf5655 /* vkCmdBindVertexBuffers2EXT */) {
         *addr = (void *)CmdBindVertexBuffers2EXT;
         return true;
     }
-    if (!strcmp("vkCmdSetDepthTestEnableEXT", name)) {
+    if (nameHash == 0xae8baaf2908ad9f8 /* vkCmdSetDepthTestEnableEXT */) {
         *addr = (void *)CmdSetDepthTestEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetDepthWriteEnableEXT", name)) {
+    if (nameHash == 0x25e2c1a1ae2efd24 /* vkCmdSetDepthWriteEnableEXT */) {
         *addr = (void *)CmdSetDepthWriteEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetDepthCompareOpEXT", name)) {
+    if (nameHash == 0xbf39cf164d4f3b71 /* vkCmdSetDepthCompareOpEXT */) {
         *addr = (void *)CmdSetDepthCompareOpEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetDepthBoundsTestEnableEXT", name)) {
+    if (nameHash == 0x09f73ab4947aa834 /* vkCmdSetDepthBoundsTestEnableEXT */) {
         *addr = (void *)CmdSetDepthBoundsTestEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetStencilTestEnableEXT", name)) {
+    if (nameHash == 0xcb818f46817e8697 /* vkCmdSetStencilTestEnableEXT */) {
         *addr = (void *)CmdSetStencilTestEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetStencilOpEXT", name)) {
+    if (nameHash == 0x0c7a936d63d4b37e /* vkCmdSetStencilOpEXT */) {
         *addr = (void *)CmdSetStencilOpEXT;
         return true;
     }
 
     // ---- VK_EXT_host_image_copy extension commands
-    if (!strcmp("vkCopyMemoryToImageEXT", name)) {
+    if (nameHash == 0x95a0cae5a6723961 /* vkCopyMemoryToImageEXT */) {
         *addr = (void *)CopyMemoryToImageEXT;
         return true;
     }
-    if (!strcmp("vkCopyImageToMemoryEXT", name)) {
+    if (nameHash == 0xb1f1669ee2dd4847 /* vkCopyImageToMemoryEXT */) {
         *addr = (void *)CopyImageToMemoryEXT;
         return true;
     }
-    if (!strcmp("vkCopyImageToImageEXT", name)) {
+    if (nameHash == 0x238991922eb2dc5f /* vkCopyImageToImageEXT */) {
         *addr = (void *)CopyImageToImageEXT;
         return true;
     }
-    if (!strcmp("vkTransitionImageLayoutEXT", name)) {
+    if (nameHash == 0x233da64d987f39c6 /* vkTransitionImageLayoutEXT */) {
         *addr = (void *)TransitionImageLayoutEXT;
         return true;
     }
-    if (!strcmp("vkGetImageSubresourceLayout2EXT", name)) {
+    if (nameHash == 0x724faacf94fc9fe1 /* vkGetImageSubresourceLayout2EXT */) {
         *addr = (void *)GetImageSubresourceLayout2EXT;
         return true;
     }
 
     // ---- VK_EXT_swapchain_maintenance1 extension commands
-    if (!strcmp("vkReleaseSwapchainImagesEXT", name)) {
+    if (nameHash == 0x09e9bc32d119dd75 /* vkReleaseSwapchainImagesEXT */) {
         *addr = (void *)ReleaseSwapchainImagesEXT;
         return true;
     }
 
     // ---- VK_NV_device_generated_commands extension commands
-    if (!strcmp("vkGetGeneratedCommandsMemoryRequirementsNV", name)) {
+    if (nameHash == 0x45568382cd976a58 /* vkGetGeneratedCommandsMemoryRequirementsNV */) {
         *addr = (void *)GetGeneratedCommandsMemoryRequirementsNV;
         return true;
     }
-    if (!strcmp("vkCmdPreprocessGeneratedCommandsNV", name)) {
+    if (nameHash == 0xbbb204c332bf3b26 /* vkCmdPreprocessGeneratedCommandsNV */) {
         *addr = (void *)CmdPreprocessGeneratedCommandsNV;
         return true;
     }
-    if (!strcmp("vkCmdExecuteGeneratedCommandsNV", name)) {
+    if (nameHash == 0xc7e4fe21b7623076 /* vkCmdExecuteGeneratedCommandsNV */) {
         *addr = (void *)CmdExecuteGeneratedCommandsNV;
         return true;
     }
-    if (!strcmp("vkCmdBindPipelineShaderGroupNV", name)) {
+    if (nameHash == 0xfb6168e88a9522ee /* vkCmdBindPipelineShaderGroupNV */) {
         *addr = (void *)CmdBindPipelineShaderGroupNV;
         return true;
     }
-    if (!strcmp("vkCreateIndirectCommandsLayoutNV", name)) {
+    if (nameHash == 0x8977eb367d2cc188 /* vkCreateIndirectCommandsLayoutNV */) {
         *addr = (void *)CreateIndirectCommandsLayoutNV;
         return true;
     }
-    if (!strcmp("vkDestroyIndirectCommandsLayoutNV", name)) {
+    if (nameHash == 0x67d5c823a6e5f838 /* vkDestroyIndirectCommandsLayoutNV */) {
         *addr = (void *)DestroyIndirectCommandsLayoutNV;
         return true;
     }
 
     // ---- VK_EXT_depth_bias_control extension commands
-    if (!strcmp("vkCmdSetDepthBias2EXT", name)) {
+    if (nameHash == 0xf1159d930e7b7f9b /* vkCmdSetDepthBias2EXT */) {
         *addr = (void *)CmdSetDepthBias2EXT;
         return true;
     }
 
     // ---- VK_EXT_acquire_drm_display extension commands
-    if (!strcmp("vkAcquireDrmDisplayEXT", name)) {
+    if (nameHash == 0x07c6f662a8afbdcd /* vkAcquireDrmDisplayEXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_acquire_drm_display == 1)
                      ? (void *)AcquireDrmDisplayEXT
                      : NULL;
         return true;
     }
-    if (!strcmp("vkGetDrmDisplayEXT", name)) {
+    if (nameHash == 0x7ad0a59b02543fcd /* vkGetDrmDisplayEXT */) {
         *addr = (ptr_instance->enabled_known_extensions.ext_acquire_drm_display == 1)
                      ? (void *)GetDrmDisplayEXT
                      : NULL;
@@ -11578,144 +11578,144 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
     }
 
     // ---- VK_EXT_private_data extension commands
-    if (!strcmp("vkCreatePrivateDataSlotEXT", name)) {
+    if (nameHash == 0x914ccba5ef3134d3 /* vkCreatePrivateDataSlotEXT */) {
         *addr = (void *)CreatePrivateDataSlotEXT;
         return true;
     }
-    if (!strcmp("vkDestroyPrivateDataSlotEXT", name)) {
+    if (nameHash == 0xdce67e01cb34aa72 /* vkDestroyPrivateDataSlotEXT */) {
         *addr = (void *)DestroyPrivateDataSlotEXT;
         return true;
     }
-    if (!strcmp("vkSetPrivateDataEXT", name)) {
+    if (nameHash == 0xc2f02663a1a88208 /* vkSetPrivateDataEXT */) {
         *addr = (void *)SetPrivateDataEXT;
         return true;
     }
-    if (!strcmp("vkGetPrivateDataEXT", name)) {
+    if (nameHash == 0x8da528a7d8e71c4a /* vkGetPrivateDataEXT */) {
         *addr = (void *)GetPrivateDataEXT;
         return true;
     }
 
     // ---- VK_NV_cuda_kernel_launch extension commands
-    if (!strcmp("vkCreateCudaModuleNV", name)) {
+    if (nameHash == 0x5f79fd00863c735c /* vkCreateCudaModuleNV */) {
         *addr = (void *)CreateCudaModuleNV;
         return true;
     }
-    if (!strcmp("vkGetCudaModuleCacheNV", name)) {
+    if (nameHash == 0x568b92e4b678bc0d /* vkGetCudaModuleCacheNV */) {
         *addr = (void *)GetCudaModuleCacheNV;
         return true;
     }
-    if (!strcmp("vkCreateCudaFunctionNV", name)) {
+    if (nameHash == 0x2959ea9ac9517bb5 /* vkCreateCudaFunctionNV */) {
         *addr = (void *)CreateCudaFunctionNV;
         return true;
     }
-    if (!strcmp("vkDestroyCudaModuleNV", name)) {
+    if (nameHash == 0x46bd70f746f4073f /* vkDestroyCudaModuleNV */) {
         *addr = (void *)DestroyCudaModuleNV;
         return true;
     }
-    if (!strcmp("vkDestroyCudaFunctionNV", name)) {
+    if (nameHash == 0xb811d13ae8ba8698 /* vkDestroyCudaFunctionNV */) {
         *addr = (void *)DestroyCudaFunctionNV;
         return true;
     }
-    if (!strcmp("vkCmdCudaLaunchKernelNV", name)) {
+    if (nameHash == 0x9508bfb817e18156 /* vkCmdCudaLaunchKernelNV */) {
         *addr = (void *)CmdCudaLaunchKernelNV;
         return true;
     }
 
     // ---- VK_EXT_metal_objects extension commands
 #if defined(VK_USE_PLATFORM_METAL_EXT)
-    if (!strcmp("vkExportMetalObjectsEXT", name)) {
+    if (nameHash == 0xcf18436e233f62fe /* vkExportMetalObjectsEXT */) {
         *addr = (void *)ExportMetalObjectsEXT;
         return true;
     }
 #endif // VK_USE_PLATFORM_METAL_EXT
 
     // ---- VK_EXT_descriptor_buffer extension commands
-    if (!strcmp("vkGetDescriptorSetLayoutSizeEXT", name)) {
+    if (nameHash == 0xb615047d05c91282 /* vkGetDescriptorSetLayoutSizeEXT */) {
         *addr = (void *)GetDescriptorSetLayoutSizeEXT;
         return true;
     }
-    if (!strcmp("vkGetDescriptorSetLayoutBindingOffsetEXT", name)) {
+    if (nameHash == 0x6688394878be035e /* vkGetDescriptorSetLayoutBindingOffsetEXT */) {
         *addr = (void *)GetDescriptorSetLayoutBindingOffsetEXT;
         return true;
     }
-    if (!strcmp("vkGetDescriptorEXT", name)) {
+    if (nameHash == 0x99dfcdbeb70620f3 /* vkGetDescriptorEXT */) {
         *addr = (void *)GetDescriptorEXT;
         return true;
     }
-    if (!strcmp("vkCmdBindDescriptorBuffersEXT", name)) {
+    if (nameHash == 0xd3d8cd8814a0cdd8 /* vkCmdBindDescriptorBuffersEXT */) {
         *addr = (void *)CmdBindDescriptorBuffersEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetDescriptorBufferOffsetsEXT", name)) {
+    if (nameHash == 0x3cb127add67d0963 /* vkCmdSetDescriptorBufferOffsetsEXT */) {
         *addr = (void *)CmdSetDescriptorBufferOffsetsEXT;
         return true;
     }
-    if (!strcmp("vkCmdBindDescriptorBufferEmbeddedSamplersEXT", name)) {
+    if (nameHash == 0xc5d77b727d806ce6 /* vkCmdBindDescriptorBufferEmbeddedSamplersEXT */) {
         *addr = (void *)CmdBindDescriptorBufferEmbeddedSamplersEXT;
         return true;
     }
-    if (!strcmp("vkGetBufferOpaqueCaptureDescriptorDataEXT", name)) {
+    if (nameHash == 0x2f2449681e594992 /* vkGetBufferOpaqueCaptureDescriptorDataEXT */) {
         *addr = (void *)GetBufferOpaqueCaptureDescriptorDataEXT;
         return true;
     }
-    if (!strcmp("vkGetImageOpaqueCaptureDescriptorDataEXT", name)) {
+    if (nameHash == 0x4852117a823da29e /* vkGetImageOpaqueCaptureDescriptorDataEXT */) {
         *addr = (void *)GetImageOpaqueCaptureDescriptorDataEXT;
         return true;
     }
-    if (!strcmp("vkGetImageViewOpaqueCaptureDescriptorDataEXT", name)) {
+    if (nameHash == 0x26037ce5b636f47f /* vkGetImageViewOpaqueCaptureDescriptorDataEXT */) {
         *addr = (void *)GetImageViewOpaqueCaptureDescriptorDataEXT;
         return true;
     }
-    if (!strcmp("vkGetSamplerOpaqueCaptureDescriptorDataEXT", name)) {
+    if (nameHash == 0x5d99174ab12822bd /* vkGetSamplerOpaqueCaptureDescriptorDataEXT */) {
         *addr = (void *)GetSamplerOpaqueCaptureDescriptorDataEXT;
         return true;
     }
-    if (!strcmp("vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT", name)) {
+    if (nameHash == 0x6d4934759c97e7a4 /* vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT */) {
         *addr = (void *)GetAccelerationStructureOpaqueCaptureDescriptorDataEXT;
         return true;
     }
 
     // ---- VK_NV_fragment_shading_rate_enums extension commands
-    if (!strcmp("vkCmdSetFragmentShadingRateEnumNV", name)) {
+    if (nameHash == 0x86a35fcb0cd25838 /* vkCmdSetFragmentShadingRateEnumNV */) {
         *addr = (void *)CmdSetFragmentShadingRateEnumNV;
         return true;
     }
 
     // ---- VK_EXT_device_fault extension commands
-    if (!strcmp("vkGetDeviceFaultInfoEXT", name)) {
+    if (nameHash == 0x166f6358bfe0fce0 /* vkGetDeviceFaultInfoEXT */) {
         *addr = (void *)GetDeviceFaultInfoEXT;
         return true;
     }
 
     // ---- VK_NV_acquire_winrt_display extension commands
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp("vkAcquireWinrtDisplayNV", name)) {
+    if (nameHash == 0xad319e2c95c14175 /* vkAcquireWinrtDisplayNV */) {
         *addr = (void *)AcquireWinrtDisplayNV;
         return true;
     }
 #endif // VK_USE_PLATFORM_WIN32_KHR
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
-    if (!strcmp("vkGetWinrtDisplayNV", name)) {
+    if (nameHash == 0x61c13e84ce5c483b /* vkGetWinrtDisplayNV */) {
         *addr = (void *)GetWinrtDisplayNV;
         return true;
     }
 #endif // VK_USE_PLATFORM_WIN32_KHR
 
     // ---- VK_EXT_vertex_input_dynamic_state extension commands
-    if (!strcmp("vkCmdSetVertexInputEXT", name)) {
+    if (nameHash == 0x54f4e0d0a5c3dbbf /* vkCmdSetVertexInputEXT */) {
         *addr = (void *)CmdSetVertexInputEXT;
         return true;
     }
 
     // ---- VK_FUCHSIA_external_memory extension commands
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp("vkGetMemoryZirconHandleFUCHSIA", name)) {
+    if (nameHash == 0xbde4c14636640d82 /* vkGetMemoryZirconHandleFUCHSIA */) {
         *addr = (void *)GetMemoryZirconHandleFUCHSIA;
         return true;
     }
 #endif // VK_USE_PLATFORM_FUCHSIA
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp("vkGetMemoryZirconHandlePropertiesFUCHSIA", name)) {
+    if (nameHash == 0xc77b0aec1b685e42 /* vkGetMemoryZirconHandlePropertiesFUCHSIA */) {
         *addr = (void *)GetMemoryZirconHandlePropertiesFUCHSIA;
         return true;
     }
@@ -11723,13 +11723,13 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
 
     // ---- VK_FUCHSIA_external_semaphore extension commands
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp("vkImportSemaphoreZirconHandleFUCHSIA", name)) {
+    if (nameHash == 0x334314efb11c7144 /* vkImportSemaphoreZirconHandleFUCHSIA */) {
         *addr = (void *)ImportSemaphoreZirconHandleFUCHSIA;
         return true;
     }
 #endif // VK_USE_PLATFORM_FUCHSIA
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp("vkGetSemaphoreZirconHandleFUCHSIA", name)) {
+    if (nameHash == 0xb3fc6ad1eebe5d90 /* vkGetSemaphoreZirconHandleFUCHSIA */) {
         *addr = (void *)GetSemaphoreZirconHandleFUCHSIA;
         return true;
     }
@@ -11737,598 +11737,598 @@ bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *na
 
     // ---- VK_FUCHSIA_buffer_collection extension commands
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp("vkCreateBufferCollectionFUCHSIA", name)) {
+    if (nameHash == 0xce653760953e9106 /* vkCreateBufferCollectionFUCHSIA */) {
         *addr = (void *)CreateBufferCollectionFUCHSIA;
         return true;
     }
 #endif // VK_USE_PLATFORM_FUCHSIA
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp("vkSetBufferCollectionImageConstraintsFUCHSIA", name)) {
+    if (nameHash == 0xd10afc8461e339f2 /* vkSetBufferCollectionImageConstraintsFUCHSIA */) {
         *addr = (void *)SetBufferCollectionImageConstraintsFUCHSIA;
         return true;
     }
 #endif // VK_USE_PLATFORM_FUCHSIA
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp("vkSetBufferCollectionBufferConstraintsFUCHSIA", name)) {
+    if (nameHash == 0x36d94ea1570378f7 /* vkSetBufferCollectionBufferConstraintsFUCHSIA */) {
         *addr = (void *)SetBufferCollectionBufferConstraintsFUCHSIA;
         return true;
     }
 #endif // VK_USE_PLATFORM_FUCHSIA
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp("vkDestroyBufferCollectionFUCHSIA", name)) {
+    if (nameHash == 0xb055e21eec61f87e /* vkDestroyBufferCollectionFUCHSIA */) {
         *addr = (void *)DestroyBufferCollectionFUCHSIA;
         return true;
     }
 #endif // VK_USE_PLATFORM_FUCHSIA
 #if defined(VK_USE_PLATFORM_FUCHSIA)
-    if (!strcmp("vkGetBufferCollectionPropertiesFUCHSIA", name)) {
+    if (nameHash == 0x2c457bf2268490e8 /* vkGetBufferCollectionPropertiesFUCHSIA */) {
         *addr = (void *)GetBufferCollectionPropertiesFUCHSIA;
         return true;
     }
 #endif // VK_USE_PLATFORM_FUCHSIA
 
     // ---- VK_HUAWEI_subpass_shading extension commands
-    if (!strcmp("vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI", name)) {
+    if (nameHash == 0xcc38e899cdc6433c /* vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI */) {
         *addr = (void *)GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI;
         return true;
     }
-    if (!strcmp("vkCmdSubpassShadingHUAWEI", name)) {
+    if (nameHash == 0x149123ece151c923 /* vkCmdSubpassShadingHUAWEI */) {
         *addr = (void *)CmdSubpassShadingHUAWEI;
         return true;
     }
 
     // ---- VK_HUAWEI_invocation_mask extension commands
-    if (!strcmp("vkCmdBindInvocationMaskHUAWEI", name)) {
+    if (nameHash == 0x5dd077e15ef82882 /* vkCmdBindInvocationMaskHUAWEI */) {
         *addr = (void *)CmdBindInvocationMaskHUAWEI;
         return true;
     }
 
     // ---- VK_NV_external_memory_rdma extension commands
-    if (!strcmp("vkGetMemoryRemoteAddressNV", name)) {
+    if (nameHash == 0x5ee3413a16ecc62a /* vkGetMemoryRemoteAddressNV */) {
         *addr = (void *)GetMemoryRemoteAddressNV;
         return true;
     }
 
     // ---- VK_EXT_pipeline_properties extension commands
-    if (!strcmp("vkGetPipelinePropertiesEXT", name)) {
+    if (nameHash == 0x6987d1107990db8b /* vkGetPipelinePropertiesEXT */) {
         *addr = (void *)GetPipelinePropertiesEXT;
         return true;
     }
 
     // ---- VK_EXT_extended_dynamic_state2 extension commands
-    if (!strcmp("vkCmdSetPatchControlPointsEXT", name)) {
+    if (nameHash == 0x77298a207cf7470a /* vkCmdSetPatchControlPointsEXT */) {
         *addr = (void *)CmdSetPatchControlPointsEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetRasterizerDiscardEnableEXT", name)) {
+    if (nameHash == 0x20e538050b42f767 /* vkCmdSetRasterizerDiscardEnableEXT */) {
         *addr = (void *)CmdSetRasterizerDiscardEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetDepthBiasEnableEXT", name)) {
+    if (nameHash == 0xafe12b5c094c8aeb /* vkCmdSetDepthBiasEnableEXT */) {
         *addr = (void *)CmdSetDepthBiasEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetLogicOpEXT", name)) {
+    if (nameHash == 0x4fdb2f0ce0346b73 /* vkCmdSetLogicOpEXT */) {
         *addr = (void *)CmdSetLogicOpEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetPrimitiveRestartEnableEXT", name)) {
+    if (nameHash == 0x8debabeca0bc6dd7 /* vkCmdSetPrimitiveRestartEnableEXT */) {
         *addr = (void *)CmdSetPrimitiveRestartEnableEXT;
         return true;
     }
 
     // ---- VK_EXT_color_write_enable extension commands
-    if (!strcmp("vkCmdSetColorWriteEnableEXT", name)) {
+    if (nameHash == 0xee0c987fe12167e5 /* vkCmdSetColorWriteEnableEXT */) {
         *addr = (void *)CmdSetColorWriteEnableEXT;
         return true;
     }
 
     // ---- VK_EXT_multi_draw extension commands
-    if (!strcmp("vkCmdDrawMultiEXT", name)) {
+    if (nameHash == 0x13672ea08d07fa9d /* vkCmdDrawMultiEXT */) {
         *addr = (void *)CmdDrawMultiEXT;
         return true;
     }
-    if (!strcmp("vkCmdDrawMultiIndexedEXT", name)) {
+    if (nameHash == 0x15b0ebcd4268ceb0 /* vkCmdDrawMultiIndexedEXT */) {
         *addr = (void *)CmdDrawMultiIndexedEXT;
         return true;
     }
 
     // ---- VK_EXT_opacity_micromap extension commands
-    if (!strcmp("vkCreateMicromapEXT", name)) {
+    if (nameHash == 0xb6e8dcebebd08436 /* vkCreateMicromapEXT */) {
         *addr = (void *)CreateMicromapEXT;
         return true;
     }
-    if (!strcmp("vkDestroyMicromapEXT", name)) {
+    if (nameHash == 0x3a88835e421d53cd /* vkDestroyMicromapEXT */) {
         *addr = (void *)DestroyMicromapEXT;
         return true;
     }
-    if (!strcmp("vkCmdBuildMicromapsEXT", name)) {
+    if (nameHash == 0xdad7d425257f2349 /* vkCmdBuildMicromapsEXT */) {
         *addr = (void *)CmdBuildMicromapsEXT;
         return true;
     }
-    if (!strcmp("vkBuildMicromapsEXT", name)) {
+    if (nameHash == 0x31070cdf29394f00 /* vkBuildMicromapsEXT */) {
         *addr = (void *)BuildMicromapsEXT;
         return true;
     }
-    if (!strcmp("vkCopyMicromapEXT", name)) {
+    if (nameHash == 0xf39873088d0d505a /* vkCopyMicromapEXT */) {
         *addr = (void *)CopyMicromapEXT;
         return true;
     }
-    if (!strcmp("vkCopyMicromapToMemoryEXT", name)) {
+    if (nameHash == 0x0b4161174ca14c67 /* vkCopyMicromapToMemoryEXT */) {
         *addr = (void *)CopyMicromapToMemoryEXT;
         return true;
     }
-    if (!strcmp("vkCopyMemoryToMicromapEXT", name)) {
+    if (nameHash == 0x19f19eb801eb4fea /* vkCopyMemoryToMicromapEXT */) {
         *addr = (void *)CopyMemoryToMicromapEXT;
         return true;
     }
-    if (!strcmp("vkWriteMicromapsPropertiesEXT", name)) {
+    if (nameHash == 0x11a78b6266b8d57c /* vkWriteMicromapsPropertiesEXT */) {
         *addr = (void *)WriteMicromapsPropertiesEXT;
         return true;
     }
-    if (!strcmp("vkCmdCopyMicromapEXT", name)) {
+    if (nameHash == 0x07982f27d5cc9e3d /* vkCmdCopyMicromapEXT */) {
         *addr = (void *)CmdCopyMicromapEXT;
         return true;
     }
-    if (!strcmp("vkCmdCopyMicromapToMemoryEXT", name)) {
+    if (nameHash == 0x31241535b9bc3b52 /* vkCmdCopyMicromapToMemoryEXT */) {
         *addr = (void *)CmdCopyMicromapToMemoryEXT;
         return true;
     }
-    if (!strcmp("vkCmdCopyMemoryToMicromapEXT", name)) {
+    if (nameHash == 0x09bcf6218bf7a7cc /* vkCmdCopyMemoryToMicromapEXT */) {
         *addr = (void *)CmdCopyMemoryToMicromapEXT;
         return true;
     }
-    if (!strcmp("vkCmdWriteMicromapsPropertiesEXT", name)) {
+    if (nameHash == 0xa966bf46df7237f0 /* vkCmdWriteMicromapsPropertiesEXT */) {
         *addr = (void *)CmdWriteMicromapsPropertiesEXT;
         return true;
     }
-    if (!strcmp("vkGetDeviceMicromapCompatibilityEXT", name)) {
+    if (nameHash == 0x4067528a7c46d3d1 /* vkGetDeviceMicromapCompatibilityEXT */) {
         *addr = (void *)GetDeviceMicromapCompatibilityEXT;
         return true;
     }
-    if (!strcmp("vkGetMicromapBuildSizesEXT", name)) {
+    if (nameHash == 0x3683952ff1e39c69 /* vkGetMicromapBuildSizesEXT */) {
         *addr = (void *)GetMicromapBuildSizesEXT;
         return true;
     }
 
     // ---- VK_HUAWEI_cluster_culling_shader extension commands
-    if (!strcmp("vkCmdDrawClusterHUAWEI", name)) {
+    if (nameHash == 0xcd3579faa9244fe8 /* vkCmdDrawClusterHUAWEI */) {
         *addr = (void *)CmdDrawClusterHUAWEI;
         return true;
     }
-    if (!strcmp("vkCmdDrawClusterIndirectHUAWEI", name)) {
+    if (nameHash == 0x753af4a2035f5325 /* vkCmdDrawClusterIndirectHUAWEI */) {
         *addr = (void *)CmdDrawClusterIndirectHUAWEI;
         return true;
     }
 
     // ---- VK_EXT_pageable_device_local_memory extension commands
-    if (!strcmp("vkSetDeviceMemoryPriorityEXT", name)) {
+    if (nameHash == 0x6124012503a7634c /* vkSetDeviceMemoryPriorityEXT */) {
         *addr = (void *)SetDeviceMemoryPriorityEXT;
         return true;
     }
 
     // ---- VK_VALVE_descriptor_set_host_mapping extension commands
-    if (!strcmp("vkGetDescriptorSetLayoutHostMappingInfoVALVE", name)) {
+    if (nameHash == 0xe67ea7bf4305edd8 /* vkGetDescriptorSetLayoutHostMappingInfoVALVE */) {
         *addr = (void *)GetDescriptorSetLayoutHostMappingInfoVALVE;
         return true;
     }
-    if (!strcmp("vkGetDescriptorSetHostMappingVALVE", name)) {
+    if (nameHash == 0x9d134d5d5df51d6b /* vkGetDescriptorSetHostMappingVALVE */) {
         *addr = (void *)GetDescriptorSetHostMappingVALVE;
         return true;
     }
 
     // ---- VK_NV_copy_memory_indirect extension commands
-    if (!strcmp("vkCmdCopyMemoryIndirectNV", name)) {
+    if (nameHash == 0xea1cabf280ef8b04 /* vkCmdCopyMemoryIndirectNV */) {
         *addr = (void *)CmdCopyMemoryIndirectNV;
         return true;
     }
-    if (!strcmp("vkCmdCopyMemoryToImageIndirectNV", name)) {
+    if (nameHash == 0x41a01ed27bc041f2 /* vkCmdCopyMemoryToImageIndirectNV */) {
         *addr = (void *)CmdCopyMemoryToImageIndirectNV;
         return true;
     }
 
     // ---- VK_NV_memory_decompression extension commands
-    if (!strcmp("vkCmdDecompressMemoryNV", name)) {
+    if (nameHash == 0x1c4feae5ecde76d9 /* vkCmdDecompressMemoryNV */) {
         *addr = (void *)CmdDecompressMemoryNV;
         return true;
     }
-    if (!strcmp("vkCmdDecompressMemoryIndirectCountNV", name)) {
+    if (nameHash == 0xa9a55fd0d9b55eda /* vkCmdDecompressMemoryIndirectCountNV */) {
         *addr = (void *)CmdDecompressMemoryIndirectCountNV;
         return true;
     }
 
     // ---- VK_NV_device_generated_commands_compute extension commands
-    if (!strcmp("vkGetPipelineIndirectMemoryRequirementsNV", name)) {
+    if (nameHash == 0xd8b91a19d2c84eba /* vkGetPipelineIndirectMemoryRequirementsNV */) {
         *addr = (void *)GetPipelineIndirectMemoryRequirementsNV;
         return true;
     }
-    if (!strcmp("vkCmdUpdatePipelineIndirectBufferNV", name)) {
+    if (nameHash == 0x59e3b39cfad2a148 /* vkCmdUpdatePipelineIndirectBufferNV */) {
         *addr = (void *)CmdUpdatePipelineIndirectBufferNV;
         return true;
     }
-    if (!strcmp("vkGetPipelineIndirectDeviceAddressNV", name)) {
+    if (nameHash == 0x076d9ee8752c3cd2 /* vkGetPipelineIndirectDeviceAddressNV */) {
         *addr = (void *)GetPipelineIndirectDeviceAddressNV;
         return true;
     }
 
     // ---- VK_EXT_extended_dynamic_state3 extension commands
-    if (!strcmp("vkCmdSetDepthClampEnableEXT", name)) {
+    if (nameHash == 0x52bc0c7023b88e90 /* vkCmdSetDepthClampEnableEXT */) {
         *addr = (void *)CmdSetDepthClampEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetPolygonModeEXT", name)) {
+    if (nameHash == 0x48e9ce5a58c1c252 /* vkCmdSetPolygonModeEXT */) {
         *addr = (void *)CmdSetPolygonModeEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetRasterizationSamplesEXT", name)) {
+    if (nameHash == 0xf02843786e3933f8 /* vkCmdSetRasterizationSamplesEXT */) {
         *addr = (void *)CmdSetRasterizationSamplesEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetSampleMaskEXT", name)) {
+    if (nameHash == 0x79bbe5a8a2c19b65 /* vkCmdSetSampleMaskEXT */) {
         *addr = (void *)CmdSetSampleMaskEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetAlphaToCoverageEnableEXT", name)) {
+    if (nameHash == 0x4c351cfa990e9dce /* vkCmdSetAlphaToCoverageEnableEXT */) {
         *addr = (void *)CmdSetAlphaToCoverageEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetAlphaToOneEnableEXT", name)) {
+    if (nameHash == 0x983f1d9254a0a363 /* vkCmdSetAlphaToOneEnableEXT */) {
         *addr = (void *)CmdSetAlphaToOneEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetLogicOpEnableEXT", name)) {
+    if (nameHash == 0x735a3459f80339e7 /* vkCmdSetLogicOpEnableEXT */) {
         *addr = (void *)CmdSetLogicOpEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetColorBlendEnableEXT", name)) {
+    if (nameHash == 0x17f9a371c7111a63 /* vkCmdSetColorBlendEnableEXT */) {
         *addr = (void *)CmdSetColorBlendEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetColorBlendEquationEXT", name)) {
+    if (nameHash == 0x8ada4cd22e8a735c /* vkCmdSetColorBlendEquationEXT */) {
         *addr = (void *)CmdSetColorBlendEquationEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetColorWriteMaskEXT", name)) {
+    if (nameHash == 0xe6b91e7965ee4a9f /* vkCmdSetColorWriteMaskEXT */) {
         *addr = (void *)CmdSetColorWriteMaskEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetTessellationDomainOriginEXT", name)) {
+    if (nameHash == 0x4b963cb16d7a5ad8 /* vkCmdSetTessellationDomainOriginEXT */) {
         *addr = (void *)CmdSetTessellationDomainOriginEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetRasterizationStreamEXT", name)) {
+    if (nameHash == 0x7b3f73b0c28b9ac0 /* vkCmdSetRasterizationStreamEXT */) {
         *addr = (void *)CmdSetRasterizationStreamEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetConservativeRasterizationModeEXT", name)) {
+    if (nameHash == 0x659cd4a0990430f6 /* vkCmdSetConservativeRasterizationModeEXT */) {
         *addr = (void *)CmdSetConservativeRasterizationModeEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetExtraPrimitiveOverestimationSizeEXT", name)) {
+    if (nameHash == 0x538223e2090de1df /* vkCmdSetExtraPrimitiveOverestimationSizeEXT */) {
         *addr = (void *)CmdSetExtraPrimitiveOverestimationSizeEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetDepthClipEnableEXT", name)) {
+    if (nameHash == 0x172c55dd5dc1bc3a /* vkCmdSetDepthClipEnableEXT */) {
         *addr = (void *)CmdSetDepthClipEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetSampleLocationsEnableEXT", name)) {
+    if (nameHash == 0xcc661f1aee937b88 /* vkCmdSetSampleLocationsEnableEXT */) {
         *addr = (void *)CmdSetSampleLocationsEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetColorBlendAdvancedEXT", name)) {
+    if (nameHash == 0xa0f10e474c7a0e0d /* vkCmdSetColorBlendAdvancedEXT */) {
         *addr = (void *)CmdSetColorBlendAdvancedEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetProvokingVertexModeEXT", name)) {
+    if (nameHash == 0xadd175019f7d316f /* vkCmdSetProvokingVertexModeEXT */) {
         *addr = (void *)CmdSetProvokingVertexModeEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetLineRasterizationModeEXT", name)) {
+    if (nameHash == 0xe86e1a671a40b3b7 /* vkCmdSetLineRasterizationModeEXT */) {
         *addr = (void *)CmdSetLineRasterizationModeEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetLineStippleEnableEXT", name)) {
+    if (nameHash == 0xa664321f63cd904a /* vkCmdSetLineStippleEnableEXT */) {
         *addr = (void *)CmdSetLineStippleEnableEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetDepthClipNegativeOneToOneEXT", name)) {
+    if (nameHash == 0x1def9e89a041b817 /* vkCmdSetDepthClipNegativeOneToOneEXT */) {
         *addr = (void *)CmdSetDepthClipNegativeOneToOneEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetViewportWScalingEnableNV", name)) {
+    if (nameHash == 0xd35e353760f41c6f /* vkCmdSetViewportWScalingEnableNV */) {
         *addr = (void *)CmdSetViewportWScalingEnableNV;
         return true;
     }
-    if (!strcmp("vkCmdSetViewportSwizzleNV", name)) {
+    if (nameHash == 0xb449b51a1fdae15f /* vkCmdSetViewportSwizzleNV */) {
         *addr = (void *)CmdSetViewportSwizzleNV;
         return true;
     }
-    if (!strcmp("vkCmdSetCoverageToColorEnableNV", name)) {
+    if (nameHash == 0xe0f1d5482a04901c /* vkCmdSetCoverageToColorEnableNV */) {
         *addr = (void *)CmdSetCoverageToColorEnableNV;
         return true;
     }
-    if (!strcmp("vkCmdSetCoverageToColorLocationNV", name)) {
+    if (nameHash == 0xfe8be5739d1d70ae /* vkCmdSetCoverageToColorLocationNV */) {
         *addr = (void *)CmdSetCoverageToColorLocationNV;
         return true;
     }
-    if (!strcmp("vkCmdSetCoverageModulationModeNV", name)) {
+    if (nameHash == 0x1e31e79e5158a92a /* vkCmdSetCoverageModulationModeNV */) {
         *addr = (void *)CmdSetCoverageModulationModeNV;
         return true;
     }
-    if (!strcmp("vkCmdSetCoverageModulationTableEnableNV", name)) {
+    if (nameHash == 0x9b7c9ebe9b147cf1 /* vkCmdSetCoverageModulationTableEnableNV */) {
         *addr = (void *)CmdSetCoverageModulationTableEnableNV;
         return true;
     }
-    if (!strcmp("vkCmdSetCoverageModulationTableNV", name)) {
+    if (nameHash == 0xa34e1bfd05275463 /* vkCmdSetCoverageModulationTableNV */) {
         *addr = (void *)CmdSetCoverageModulationTableNV;
         return true;
     }
-    if (!strcmp("vkCmdSetShadingRateImageEnableNV", name)) {
+    if (nameHash == 0x2ca882d31d4721ba /* vkCmdSetShadingRateImageEnableNV */) {
         *addr = (void *)CmdSetShadingRateImageEnableNV;
         return true;
     }
-    if (!strcmp("vkCmdSetRepresentativeFragmentTestEnableNV", name)) {
+    if (nameHash == 0x2b78093ae32cb916 /* vkCmdSetRepresentativeFragmentTestEnableNV */) {
         *addr = (void *)CmdSetRepresentativeFragmentTestEnableNV;
         return true;
     }
-    if (!strcmp("vkCmdSetCoverageReductionModeNV", name)) {
+    if (nameHash == 0xc1fb12d42b3f2d2c /* vkCmdSetCoverageReductionModeNV */) {
         *addr = (void *)CmdSetCoverageReductionModeNV;
         return true;
     }
 
     // ---- VK_EXT_shader_module_identifier extension commands
-    if (!strcmp("vkGetShaderModuleIdentifierEXT", name)) {
+    if (nameHash == 0x0602c29db03eb8ab /* vkGetShaderModuleIdentifierEXT */) {
         *addr = (void *)GetShaderModuleIdentifierEXT;
         return true;
     }
-    if (!strcmp("vkGetShaderModuleCreateInfoIdentifierEXT", name)) {
+    if (nameHash == 0x2ad0e3cb5f37720f /* vkGetShaderModuleCreateInfoIdentifierEXT */) {
         *addr = (void *)GetShaderModuleCreateInfoIdentifierEXT;
         return true;
     }
 
     // ---- VK_NV_optical_flow extension commands
-    if (!strcmp("vkGetPhysicalDeviceOpticalFlowImageFormatsNV", name)) {
+    if (nameHash == 0x06f2fe22a6f73ea9 /* vkGetPhysicalDeviceOpticalFlowImageFormatsNV */) {
         *addr = (void *)GetPhysicalDeviceOpticalFlowImageFormatsNV;
         return true;
     }
-    if (!strcmp("vkCreateOpticalFlowSessionNV", name)) {
+    if (nameHash == 0x990606475b0662c9 /* vkCreateOpticalFlowSessionNV */) {
         *addr = (void *)CreateOpticalFlowSessionNV;
         return true;
     }
-    if (!strcmp("vkDestroyOpticalFlowSessionNV", name)) {
+    if (nameHash == 0x8eaf0b3e0a85d3bc /* vkDestroyOpticalFlowSessionNV */) {
         *addr = (void *)DestroyOpticalFlowSessionNV;
         return true;
     }
-    if (!strcmp("vkBindOpticalFlowSessionImageNV", name)) {
+    if (nameHash == 0x611ba0d146ed962c /* vkBindOpticalFlowSessionImageNV */) {
         *addr = (void *)BindOpticalFlowSessionImageNV;
         return true;
     }
-    if (!strcmp("vkCmdOpticalFlowExecuteNV", name)) {
+    if (nameHash == 0xc0130a682397781c /* vkCmdOpticalFlowExecuteNV */) {
         *addr = (void *)CmdOpticalFlowExecuteNV;
         return true;
     }
 
     // ---- VK_AMD_anti_lag extension commands
-    if (!strcmp("vkAntiLagUpdateAMD", name)) {
+    if (nameHash == 0xe06aa3b9e8eeba91 /* vkAntiLagUpdateAMD */) {
         *addr = (void *)AntiLagUpdateAMD;
         return true;
     }
 
     // ---- VK_EXT_shader_object extension commands
-    if (!strcmp("vkCreateShadersEXT", name)) {
+    if (nameHash == 0x5736d06f9f7521f5 /* vkCreateShadersEXT */) {
         *addr = (void *)CreateShadersEXT;
         return true;
     }
-    if (!strcmp("vkDestroyShaderEXT", name)) {
+    if (nameHash == 0xb32de6d8d29abe22 /* vkDestroyShaderEXT */) {
         *addr = (void *)DestroyShaderEXT;
         return true;
     }
-    if (!strcmp("vkGetShaderBinaryDataEXT", name)) {
+    if (nameHash == 0x8b087bf937ffd567 /* vkGetShaderBinaryDataEXT */) {
         *addr = (void *)GetShaderBinaryDataEXT;
         return true;
     }
-    if (!strcmp("vkCmdBindShadersEXT", name)) {
+    if (nameHash == 0x213f8b33c25f4ec9 /* vkCmdBindShadersEXT */) {
         *addr = (void *)CmdBindShadersEXT;
         return true;
     }
-    if (!strcmp("vkCmdSetDepthClampRangeEXT", name)) {
+    if (nameHash == 0x7937cbd95db509a9 /* vkCmdSetDepthClampRangeEXT */) {
         *addr = (void *)CmdSetDepthClampRangeEXT;
         return true;
     }
 
     // ---- VK_QCOM_tile_properties extension commands
-    if (!strcmp("vkGetFramebufferTilePropertiesQCOM", name)) {
+    if (nameHash == 0xbb471ca7efa2efd6 /* vkGetFramebufferTilePropertiesQCOM */) {
         *addr = (void *)GetFramebufferTilePropertiesQCOM;
         return true;
     }
-    if (!strcmp("vkGetDynamicRenderingTilePropertiesQCOM", name)) {
+    if (nameHash == 0xc3d161a58a0be001 /* vkGetDynamicRenderingTilePropertiesQCOM */) {
         *addr = (void *)GetDynamicRenderingTilePropertiesQCOM;
         return true;
     }
 
     // ---- VK_NV_low_latency2 extension commands
-    if (!strcmp("vkSetLatencySleepModeNV", name)) {
+    if (nameHash == 0xc3167c9cdfe12247 /* vkSetLatencySleepModeNV */) {
         *addr = (void *)SetLatencySleepModeNV;
         return true;
     }
-    if (!strcmp("vkLatencySleepNV", name)) {
+    if (nameHash == 0x7f231d810d3308b5 /* vkLatencySleepNV */) {
         *addr = (void *)LatencySleepNV;
         return true;
     }
-    if (!strcmp("vkSetLatencyMarkerNV", name)) {
+    if (nameHash == 0x5e82c425367c6366 /* vkSetLatencyMarkerNV */) {
         *addr = (void *)SetLatencyMarkerNV;
         return true;
     }
-    if (!strcmp("vkGetLatencyTimingsNV", name)) {
+    if (nameHash == 0xf1696abc2816c1f0 /* vkGetLatencyTimingsNV */) {
         *addr = (void *)GetLatencyTimingsNV;
         return true;
     }
-    if (!strcmp("vkQueueNotifyOutOfBandNV", name)) {
+    if (nameHash == 0x43962ea5cc322bab /* vkQueueNotifyOutOfBandNV */) {
         *addr = (void *)QueueNotifyOutOfBandNV;
         return true;
     }
 
     // ---- VK_EXT_attachment_feedback_loop_dynamic_state extension commands
-    if (!strcmp("vkCmdSetAttachmentFeedbackLoopEnableEXT", name)) {
+    if (nameHash == 0xd31d2bb517a75484 /* vkCmdSetAttachmentFeedbackLoopEnableEXT */) {
         *addr = (void *)CmdSetAttachmentFeedbackLoopEnableEXT;
         return true;
     }
 
     // ---- VK_QNX_external_memory_screen_buffer extension commands
 #if defined(VK_USE_PLATFORM_SCREEN_QNX)
-    if (!strcmp("vkGetScreenBufferPropertiesQNX", name)) {
+    if (nameHash == 0xe2152f86c3e27268 /* vkGetScreenBufferPropertiesQNX */) {
         *addr = (void *)GetScreenBufferPropertiesQNX;
         return true;
     }
 #endif // VK_USE_PLATFORM_SCREEN_QNX
 
     // ---- VK_EXT_device_generated_commands extension commands
-    if (!strcmp("vkGetGeneratedCommandsMemoryRequirementsEXT", name)) {
+    if (nameHash == 0x0d4c393e3bfb6e8f /* vkGetGeneratedCommandsMemoryRequirementsEXT */) {
         *addr = (void *)GetGeneratedCommandsMemoryRequirementsEXT;
         return true;
     }
-    if (!strcmp("vkCmdPreprocessGeneratedCommandsEXT", name)) {
+    if (nameHash == 0x37569a6dd4dad322 /* vkCmdPreprocessGeneratedCommandsEXT */) {
         *addr = (void *)CmdPreprocessGeneratedCommandsEXT;
         return true;
     }
-    if (!strcmp("vkCmdExecuteGeneratedCommandsEXT", name)) {
+    if (nameHash == 0x95035412cfab2a57 /* vkCmdExecuteGeneratedCommandsEXT */) {
         *addr = (void *)CmdExecuteGeneratedCommandsEXT;
         return true;
     }
-    if (!strcmp("vkCreateIndirectCommandsLayoutEXT", name)) {
+    if (nameHash == 0x8130a83ccd423f02 /* vkCreateIndirectCommandsLayoutEXT */) {
         *addr = (void *)CreateIndirectCommandsLayoutEXT;
         return true;
     }
-    if (!strcmp("vkDestroyIndirectCommandsLayoutEXT", name)) {
+    if (nameHash == 0xf9a65ae9b4a10e79 /* vkDestroyIndirectCommandsLayoutEXT */) {
         *addr = (void *)DestroyIndirectCommandsLayoutEXT;
         return true;
     }
-    if (!strcmp("vkCreateIndirectExecutionSetEXT", name)) {
+    if (nameHash == 0xb57d926305bc8ed4 /* vkCreateIndirectExecutionSetEXT */) {
         *addr = (void *)CreateIndirectExecutionSetEXT;
         return true;
     }
-    if (!strcmp("vkDestroyIndirectExecutionSetEXT", name)) {
+    if (nameHash == 0x9cbf04885cb0f4c1 /* vkDestroyIndirectExecutionSetEXT */) {
         *addr = (void *)DestroyIndirectExecutionSetEXT;
         return true;
     }
-    if (!strcmp("vkUpdateIndirectExecutionSetPipelineEXT", name)) {
+    if (nameHash == 0xd74792cfb5d068ce /* vkUpdateIndirectExecutionSetPipelineEXT */) {
         *addr = (void *)UpdateIndirectExecutionSetPipelineEXT;
         return true;
     }
-    if (!strcmp("vkUpdateIndirectExecutionSetShaderEXT", name)) {
+    if (nameHash == 0xf9df59021b7985d5 /* vkUpdateIndirectExecutionSetShaderEXT */) {
         *addr = (void *)UpdateIndirectExecutionSetShaderEXT;
         return true;
     }
 
     // ---- VK_NV_cooperative_matrix2 extension commands
-    if (!strcmp("vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV", name)) {
+    if (nameHash == 0x0d056d30f5678b25 /* vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV */) {
         *addr = (void *)GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV;
         return true;
     }
 
     // ---- VK_KHR_acceleration_structure extension commands
-    if (!strcmp("vkCreateAccelerationStructureKHR", name)) {
+    if (nameHash == 0x452970172a23c174 /* vkCreateAccelerationStructureKHR */) {
         *addr = (void *)CreateAccelerationStructureKHR;
         return true;
     }
-    if (!strcmp("vkDestroyAccelerationStructureKHR", name)) {
+    if (nameHash == 0xd536d860a73cf116 /* vkDestroyAccelerationStructureKHR */) {
         *addr = (void *)DestroyAccelerationStructureKHR;
         return true;
     }
-    if (!strcmp("vkCmdBuildAccelerationStructuresKHR", name)) {
+    if (nameHash == 0x56e0a0791533454f /* vkCmdBuildAccelerationStructuresKHR */) {
         *addr = (void *)CmdBuildAccelerationStructuresKHR;
         return true;
     }
-    if (!strcmp("vkCmdBuildAccelerationStructuresIndirectKHR", name)) {
+    if (nameHash == 0xa99627a28d359157 /* vkCmdBuildAccelerationStructuresIndirectKHR */) {
         *addr = (void *)CmdBuildAccelerationStructuresIndirectKHR;
         return true;
     }
-    if (!strcmp("vkBuildAccelerationStructuresKHR", name)) {
+    if (nameHash == 0x2d831a042e0d1b62 /* vkBuildAccelerationStructuresKHR */) {
         *addr = (void *)BuildAccelerationStructuresKHR;
         return true;
     }
-    if (!strcmp("vkCopyAccelerationStructureKHR", name)) {
+    if (nameHash == 0x5ad7e13a5109c73a /* vkCopyAccelerationStructureKHR */) {
         *addr = (void *)CopyAccelerationStructureKHR;
         return true;
     }
-    if (!strcmp("vkCopyAccelerationStructureToMemoryKHR", name)) {
+    if (nameHash == 0xe43e1298ce6a3bfe /* vkCopyAccelerationStructureToMemoryKHR */) {
         *addr = (void *)CopyAccelerationStructureToMemoryKHR;
         return true;
     }
-    if (!strcmp("vkCopyMemoryToAccelerationStructureKHR", name)) {
+    if (nameHash == 0x2ed27a2c09707e8c /* vkCopyMemoryToAccelerationStructureKHR */) {
         *addr = (void *)CopyMemoryToAccelerationStructureKHR;
         return true;
     }
-    if (!strcmp("vkWriteAccelerationStructuresPropertiesKHR", name)) {
+    if (nameHash == 0xbe6ba58fe9b83a9f /* vkWriteAccelerationStructuresPropertiesKHR */) {
         *addr = (void *)WriteAccelerationStructuresPropertiesKHR;
         return true;
     }
-    if (!strcmp("vkCmdCopyAccelerationStructureKHR", name)) {
+    if (nameHash == 0x338a1ed4b2ca0c7a /* vkCmdCopyAccelerationStructureKHR */) {
         *addr = (void *)CmdCopyAccelerationStructureKHR;
         return true;
     }
-    if (!strcmp("vkCmdCopyAccelerationStructureToMemoryKHR", name)) {
+    if (nameHash == 0xc73b61c79b859a21 /* vkCmdCopyAccelerationStructureToMemoryKHR */) {
         *addr = (void *)CmdCopyAccelerationStructureToMemoryKHR;
         return true;
     }
-    if (!strcmp("vkCmdCopyMemoryToAccelerationStructureKHR", name)) {
+    if (nameHash == 0xc24235cf58916cb3 /* vkCmdCopyMemoryToAccelerationStructureKHR */) {
         *addr = (void *)CmdCopyMemoryToAccelerationStructureKHR;
         return true;
     }
-    if (!strcmp("vkGetAccelerationStructureDeviceAddressKHR", name)) {
+    if (nameHash == 0x85a37e4af2a5d369 /* vkGetAccelerationStructureDeviceAddressKHR */) {
         *addr = (void *)GetAccelerationStructureDeviceAddressKHR;
         return true;
     }
-    if (!strcmp("vkCmdWriteAccelerationStructuresPropertiesKHR", name)) {
+    if (nameHash == 0xe9afc748cd05801d /* vkCmdWriteAccelerationStructuresPropertiesKHR */) {
         *addr = (void *)CmdWriteAccelerationStructuresPropertiesKHR;
         return true;
     }
-    if (!strcmp("vkGetDeviceAccelerationStructureCompatibilityKHR", name)) {
+    if (nameHash == 0xf88aec90a89de0da /* vkGetDeviceAccelerationStructureCompatibilityKHR */) {
         *addr = (void *)GetDeviceAccelerationStructureCompatibilityKHR;
         return true;
     }
-    if (!strcmp("vkGetAccelerationStructureBuildSizesKHR", name)) {
+    if (nameHash == 0x6c52ced389956a1d /* vkGetAccelerationStructureBuildSizesKHR */) {
         *addr = (void *)GetAccelerationStructureBuildSizesKHR;
         return true;
     }
 
     // ---- VK_KHR_ray_tracing_pipeline extension commands
-    if (!strcmp("vkCmdTraceRaysKHR", name)) {
+    if (nameHash == 0x71d79d686f22d526 /* vkCmdTraceRaysKHR */) {
         *addr = (void *)CmdTraceRaysKHR;
         return true;
     }
-    if (!strcmp("vkCreateRayTracingPipelinesKHR", name)) {
+    if (nameHash == 0x1be0142d7b82c8c3 /* vkCreateRayTracingPipelinesKHR */) {
         *addr = (void *)CreateRayTracingPipelinesKHR;
         return true;
     }
-    if (!strcmp("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR", name)) {
+    if (nameHash == 0x860a89bcaf7d40af /* vkGetRayTracingCaptureReplayShaderGroupHandlesKHR */) {
         *addr = (void *)GetRayTracingCaptureReplayShaderGroupHandlesKHR;
         return true;
     }
-    if (!strcmp("vkCmdTraceRaysIndirectKHR", name)) {
+    if (nameHash == 0xc1239f4d94d0ccd5 /* vkCmdTraceRaysIndirectKHR */) {
         *addr = (void *)CmdTraceRaysIndirectKHR;
         return true;
     }
-    if (!strcmp("vkGetRayTracingShaderGroupStackSizeKHR", name)) {
+    if (nameHash == 0xdd609c8b8fed0093 /* vkGetRayTracingShaderGroupStackSizeKHR */) {
         *addr = (void *)GetRayTracingShaderGroupStackSizeKHR;
         return true;
     }
-    if (!strcmp("vkCmdSetRayTracingPipelineStackSizeKHR", name)) {
+    if (nameHash == 0x20e1f9030911f404 /* vkCmdSetRayTracingPipelineStackSizeKHR */) {
         *addr = (void *)CmdSetRayTracingPipelineStackSizeKHR;
         return true;
     }
 
     // ---- VK_EXT_mesh_shader extension commands
-    if (!strcmp("vkCmdDrawMeshTasksEXT", name)) {
+    if (nameHash == 0x1660d6d65602a1e2 /* vkCmdDrawMeshTasksEXT */) {
         *addr = (void *)CmdDrawMeshTasksEXT;
         return true;
     }
-    if (!strcmp("vkCmdDrawMeshTasksIndirectEXT", name)) {
+    if (nameHash == 0x94400ae778a5a963 /* vkCmdDrawMeshTasksIndirectEXT */) {
         *addr = (void *)CmdDrawMeshTasksIndirectEXT;
         return true;
     }
-    if (!strcmp("vkCmdDrawMeshTasksIndirectCountEXT", name)) {
+    if (nameHash == 0x3ac504ab87b15a1d /* vkCmdDrawMeshTasksIndirectCountEXT */) {
         *addr = (void *)CmdDrawMeshTasksIndirectCountEXT;
         return true;
     }
diff --git a/loader/generated/vk_loader_extensions.h b/loader/generated/vk_loader_extensions.h
index 689a3ae90..b2bc2cadf 100644
--- a/loader/generated/vk_loader_extensions.h
+++ b/loader/generated/vk_loader_extensions.h
@@ -44,7 +44,7 @@ VKAPI_ATTR VkResult VKAPI_CALL vkDevExtError(VkDevice dev);
 
 // Extension interception for vkGetInstanceProcAddr function, so we can return
 // the appropriate information for any instance extensions we know about.
-bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *name, void **addr);
+bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *name, uint64_t nameHash, void **addr);
 
 // Extension interception for vkCreateInstance function, so we can properly
 // detect and enable any instance extension information for extensions we know
@@ -85,11 +85,12 @@ VKAPI_ATTR void VKAPI_CALL loader_init_instance_extension_dispatch_table(VkLayer
                                                                          VkInstance inst);
 
 // Device command lookup function
-VKAPI_ATTR void* VKAPI_CALL loader_lookup_device_dispatch_table(const VkLayerDispatchTable *table, const char *name, bool* name_found);
+VKAPI_ATTR void* VKAPI_CALL loader_lookup_device_dispatch_table(const VkLayerDispatchTable *table, const char *name, uint64_t nameHash,
+                                                                bool* name_found);
 
 // Instance command lookup function
 VKAPI_ATTR void* VKAPI_CALL loader_lookup_instance_dispatch_table(const VkLayerInstanceDispatchTable *table, const char *name,
-                                                                  bool *found_name);
+                                                                  uint64_t nameHash, bool *found_name);
 
 // Loader core instance terminators
 VKAPI_ATTR VkResult VKAPI_CALL terminator_CreateInstance(
diff --git a/loader/gpa_helper.c b/loader/gpa_helper.c
index 09e7ede63..f8a89d1d4 100644
--- a/loader/gpa_helper.c
+++ b/loader/gpa_helper.c
@@ -27,256 +27,259 @@
 #include "debug_utils.h"
 #include "unknown_function_handling.h"
 #include "wsi.h"
+#define XXH_INLINE_ALL
+#include <xxhash.h>
 
 void *trampoline_get_proc_addr(struct loader_instance *inst, const char *funcName) {
+    uint64_t funcNameHash = XXH3_64bits(funcName, strlen(funcName));
+
     // Don't include or check global functions
-    if (!strcmp(funcName, "vkGetInstanceProcAddr")) return vkGetInstanceProcAddr;
-    if (!strcmp(funcName, "vkDestroyInstance")) return vkDestroyInstance;
-    if (!strcmp(funcName, "vkEnumeratePhysicalDevices")) return vkEnumeratePhysicalDevices;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceFeatures")) return vkGetPhysicalDeviceFeatures;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceFormatProperties")) return vkGetPhysicalDeviceFormatProperties;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceImageFormatProperties")) return vkGetPhysicalDeviceImageFormatProperties;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceSparseImageFormatProperties")) return vkGetPhysicalDeviceSparseImageFormatProperties;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceProperties")) return vkGetPhysicalDeviceProperties;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceQueueFamilyProperties")) return vkGetPhysicalDeviceQueueFamilyProperties;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceMemoryProperties")) return vkGetPhysicalDeviceMemoryProperties;
-    if (!strcmp(funcName, "vkEnumerateDeviceLayerProperties")) return vkEnumerateDeviceLayerProperties;
-    if (!strcmp(funcName, "vkEnumerateDeviceExtensionProperties")) return vkEnumerateDeviceExtensionProperties;
-    if (!strcmp(funcName, "vkCreateDevice")) return vkCreateDevice;
-    if (!strcmp(funcName, "vkGetDeviceProcAddr")) return vkGetDeviceProcAddr;
-    if (!strcmp(funcName, "vkDestroyDevice")) return vkDestroyDevice;
-    if (!strcmp(funcName, "vkGetDeviceQueue")) return vkGetDeviceQueue;
-    if (!strcmp(funcName, "vkQueueSubmit")) return vkQueueSubmit;
-    if (!strcmp(funcName, "vkQueueWaitIdle")) return vkQueueWaitIdle;
-    if (!strcmp(funcName, "vkDeviceWaitIdle")) return vkDeviceWaitIdle;
-    if (!strcmp(funcName, "vkAllocateMemory")) return vkAllocateMemory;
-    if (!strcmp(funcName, "vkFreeMemory")) return vkFreeMemory;
-    if (!strcmp(funcName, "vkMapMemory")) return vkMapMemory;
-    if (!strcmp(funcName, "vkUnmapMemory")) return vkUnmapMemory;
-    if (!strcmp(funcName, "vkFlushMappedMemoryRanges")) return vkFlushMappedMemoryRanges;
-    if (!strcmp(funcName, "vkInvalidateMappedMemoryRanges")) return vkInvalidateMappedMemoryRanges;
-    if (!strcmp(funcName, "vkGetDeviceMemoryCommitment")) return vkGetDeviceMemoryCommitment;
-    if (!strcmp(funcName, "vkGetImageSparseMemoryRequirements")) return vkGetImageSparseMemoryRequirements;
-    if (!strcmp(funcName, "vkGetImageMemoryRequirements")) return vkGetImageMemoryRequirements;
-    if (!strcmp(funcName, "vkGetBufferMemoryRequirements")) return vkGetBufferMemoryRequirements;
-    if (!strcmp(funcName, "vkBindImageMemory")) return vkBindImageMemory;
-    if (!strcmp(funcName, "vkBindBufferMemory")) return vkBindBufferMemory;
-    if (!strcmp(funcName, "vkQueueBindSparse")) return vkQueueBindSparse;
-    if (!strcmp(funcName, "vkCreateFence")) return vkCreateFence;
-    if (!strcmp(funcName, "vkDestroyFence")) return vkDestroyFence;
-    if (!strcmp(funcName, "vkGetFenceStatus")) return vkGetFenceStatus;
-    if (!strcmp(funcName, "vkResetFences")) return vkResetFences;
-    if (!strcmp(funcName, "vkWaitForFences")) return vkWaitForFences;
-    if (!strcmp(funcName, "vkCreateSemaphore")) return vkCreateSemaphore;
-    if (!strcmp(funcName, "vkDestroySemaphore")) return vkDestroySemaphore;
-    if (!strcmp(funcName, "vkCreateEvent")) return vkCreateEvent;
-    if (!strcmp(funcName, "vkDestroyEvent")) return vkDestroyEvent;
-    if (!strcmp(funcName, "vkGetEventStatus")) return vkGetEventStatus;
-    if (!strcmp(funcName, "vkSetEvent")) return vkSetEvent;
-    if (!strcmp(funcName, "vkResetEvent")) return vkResetEvent;
-    if (!strcmp(funcName, "vkCreateQueryPool")) return vkCreateQueryPool;
-    if (!strcmp(funcName, "vkDestroyQueryPool")) return vkDestroyQueryPool;
-    if (!strcmp(funcName, "vkGetQueryPoolResults")) return vkGetQueryPoolResults;
-    if (!strcmp(funcName, "vkCreateBuffer")) return vkCreateBuffer;
-    if (!strcmp(funcName, "vkDestroyBuffer")) return vkDestroyBuffer;
-    if (!strcmp(funcName, "vkCreateBufferView")) return vkCreateBufferView;
-    if (!strcmp(funcName, "vkDestroyBufferView")) return vkDestroyBufferView;
-    if (!strcmp(funcName, "vkCreateImage")) return vkCreateImage;
-    if (!strcmp(funcName, "vkDestroyImage")) return vkDestroyImage;
-    if (!strcmp(funcName, "vkGetImageSubresourceLayout")) return vkGetImageSubresourceLayout;
-    if (!strcmp(funcName, "vkCreateImageView")) return vkCreateImageView;
-    if (!strcmp(funcName, "vkDestroyImageView")) return vkDestroyImageView;
-    if (!strcmp(funcName, "vkCreateShaderModule")) return vkCreateShaderModule;
-    if (!strcmp(funcName, "vkDestroyShaderModule")) return vkDestroyShaderModule;
-    if (!strcmp(funcName, "vkCreatePipelineCache")) return vkCreatePipelineCache;
-    if (!strcmp(funcName, "vkDestroyPipelineCache")) return vkDestroyPipelineCache;
-    if (!strcmp(funcName, "vkGetPipelineCacheData")) return vkGetPipelineCacheData;
-    if (!strcmp(funcName, "vkMergePipelineCaches")) return vkMergePipelineCaches;
-    if (!strcmp(funcName, "vkCreateGraphicsPipelines")) return vkCreateGraphicsPipelines;
-    if (!strcmp(funcName, "vkCreateComputePipelines")) return vkCreateComputePipelines;
-    if (!strcmp(funcName, "vkDestroyPipeline")) return vkDestroyPipeline;
-    if (!strcmp(funcName, "vkCreatePipelineLayout")) return vkCreatePipelineLayout;
-    if (!strcmp(funcName, "vkDestroyPipelineLayout")) return vkDestroyPipelineLayout;
-    if (!strcmp(funcName, "vkCreateSampler")) return vkCreateSampler;
-    if (!strcmp(funcName, "vkDestroySampler")) return vkDestroySampler;
-    if (!strcmp(funcName, "vkCreateDescriptorSetLayout")) return vkCreateDescriptorSetLayout;
-    if (!strcmp(funcName, "vkDestroyDescriptorSetLayout")) return vkDestroyDescriptorSetLayout;
-    if (!strcmp(funcName, "vkCreateDescriptorPool")) return vkCreateDescriptorPool;
-    if (!strcmp(funcName, "vkDestroyDescriptorPool")) return vkDestroyDescriptorPool;
-    if (!strcmp(funcName, "vkResetDescriptorPool")) return vkResetDescriptorPool;
-    if (!strcmp(funcName, "vkAllocateDescriptorSets")) return vkAllocateDescriptorSets;
-    if (!strcmp(funcName, "vkFreeDescriptorSets")) return vkFreeDescriptorSets;
-    if (!strcmp(funcName, "vkUpdateDescriptorSets")) return vkUpdateDescriptorSets;
-    if (!strcmp(funcName, "vkCreateFramebuffer")) return vkCreateFramebuffer;
-    if (!strcmp(funcName, "vkDestroyFramebuffer")) return vkDestroyFramebuffer;
-    if (!strcmp(funcName, "vkCreateRenderPass")) return vkCreateRenderPass;
-    if (!strcmp(funcName, "vkDestroyRenderPass")) return vkDestroyRenderPass;
-    if (!strcmp(funcName, "vkGetRenderAreaGranularity")) return vkGetRenderAreaGranularity;
-    if (!strcmp(funcName, "vkCreateCommandPool")) return vkCreateCommandPool;
-    if (!strcmp(funcName, "vkDestroyCommandPool")) return vkDestroyCommandPool;
-    if (!strcmp(funcName, "vkResetCommandPool")) return vkResetCommandPool;
-    if (!strcmp(funcName, "vkAllocateCommandBuffers")) return vkAllocateCommandBuffers;
-    if (!strcmp(funcName, "vkFreeCommandBuffers")) return vkFreeCommandBuffers;
-    if (!strcmp(funcName, "vkBeginCommandBuffer")) return vkBeginCommandBuffer;
-    if (!strcmp(funcName, "vkEndCommandBuffer")) return vkEndCommandBuffer;
-    if (!strcmp(funcName, "vkResetCommandBuffer")) return vkResetCommandBuffer;
-    if (!strcmp(funcName, "vkCmdBindPipeline")) return vkCmdBindPipeline;
-    if (!strcmp(funcName, "vkCmdBindDescriptorSets")) return vkCmdBindDescriptorSets;
-    if (!strcmp(funcName, "vkCmdBindVertexBuffers")) return vkCmdBindVertexBuffers;
-    if (!strcmp(funcName, "vkCmdBindIndexBuffer")) return vkCmdBindIndexBuffer;
-    if (!strcmp(funcName, "vkCmdSetViewport")) return vkCmdSetViewport;
-    if (!strcmp(funcName, "vkCmdSetScissor")) return vkCmdSetScissor;
-    if (!strcmp(funcName, "vkCmdSetLineWidth")) return vkCmdSetLineWidth;
-    if (!strcmp(funcName, "vkCmdSetDepthBias")) return vkCmdSetDepthBias;
-    if (!strcmp(funcName, "vkCmdSetBlendConstants")) return vkCmdSetBlendConstants;
-    if (!strcmp(funcName, "vkCmdSetDepthBounds")) return vkCmdSetDepthBounds;
-    if (!strcmp(funcName, "vkCmdSetStencilCompareMask")) return vkCmdSetStencilCompareMask;
-    if (!strcmp(funcName, "vkCmdSetStencilWriteMask")) return vkCmdSetStencilWriteMask;
-    if (!strcmp(funcName, "vkCmdSetStencilReference")) return vkCmdSetStencilReference;
-    if (!strcmp(funcName, "vkCmdDraw")) return vkCmdDraw;
-    if (!strcmp(funcName, "vkCmdDrawIndexed")) return vkCmdDrawIndexed;
-    if (!strcmp(funcName, "vkCmdDrawIndirect")) return vkCmdDrawIndirect;
-    if (!strcmp(funcName, "vkCmdDrawIndexedIndirect")) return vkCmdDrawIndexedIndirect;
-    if (!strcmp(funcName, "vkCmdDispatch")) return vkCmdDispatch;
-    if (!strcmp(funcName, "vkCmdDispatchIndirect")) return vkCmdDispatchIndirect;
-    if (!strcmp(funcName, "vkCmdCopyBuffer")) return vkCmdCopyBuffer;
-    if (!strcmp(funcName, "vkCmdCopyImage")) return vkCmdCopyImage;
-    if (!strcmp(funcName, "vkCmdBlitImage")) return vkCmdBlitImage;
-    if (!strcmp(funcName, "vkCmdCopyBufferToImage")) return vkCmdCopyBufferToImage;
-    if (!strcmp(funcName, "vkCmdCopyImageToBuffer")) return vkCmdCopyImageToBuffer;
-    if (!strcmp(funcName, "vkCmdUpdateBuffer")) return vkCmdUpdateBuffer;
-    if (!strcmp(funcName, "vkCmdFillBuffer")) return vkCmdFillBuffer;
-    if (!strcmp(funcName, "vkCmdClearColorImage")) return vkCmdClearColorImage;
-    if (!strcmp(funcName, "vkCmdClearDepthStencilImage")) return vkCmdClearDepthStencilImage;
-    if (!strcmp(funcName, "vkCmdClearAttachments")) return vkCmdClearAttachments;
-    if (!strcmp(funcName, "vkCmdResolveImage")) return vkCmdResolveImage;
-    if (!strcmp(funcName, "vkCmdSetEvent")) return vkCmdSetEvent;
-    if (!strcmp(funcName, "vkCmdResetEvent")) return vkCmdResetEvent;
-    if (!strcmp(funcName, "vkCmdWaitEvents")) return vkCmdWaitEvents;
-    if (!strcmp(funcName, "vkCmdPipelineBarrier")) return vkCmdPipelineBarrier;
-    if (!strcmp(funcName, "vkCmdBeginQuery")) return vkCmdBeginQuery;
-    if (!strcmp(funcName, "vkCmdEndQuery")) return vkCmdEndQuery;
-    if (!strcmp(funcName, "vkCmdResetQueryPool")) return vkCmdResetQueryPool;
-    if (!strcmp(funcName, "vkCmdWriteTimestamp")) return vkCmdWriteTimestamp;
-    if (!strcmp(funcName, "vkCmdCopyQueryPoolResults")) return vkCmdCopyQueryPoolResults;
-    if (!strcmp(funcName, "vkCmdPushConstants")) return vkCmdPushConstants;
-    if (!strcmp(funcName, "vkCmdBeginRenderPass")) return vkCmdBeginRenderPass;
-    if (!strcmp(funcName, "vkCmdNextSubpass")) return vkCmdNextSubpass;
-    if (!strcmp(funcName, "vkCmdEndRenderPass")) return vkCmdEndRenderPass;
-    if (!strcmp(funcName, "vkCmdExecuteCommands")) return vkCmdExecuteCommands;
+    if (funcNameHash == 0xbdf594b7ae4af921) return vkGetInstanceProcAddr;
+    if (funcNameHash == 0x698f41e6299f30d2) return vkDestroyInstance;
+    if (funcNameHash == 0x18d0a02e3ba007fe) return vkEnumeratePhysicalDevices;
+    if (funcNameHash == 0xaf9743132d216c3f) return vkGetPhysicalDeviceFeatures;
+    if (funcNameHash == 0x39eec9d5f829fd31) return vkGetPhysicalDeviceFormatProperties;
+    if (funcNameHash == 0x4a1ca0b582a457c0) return vkGetPhysicalDeviceImageFormatProperties;
+    if (funcNameHash == 0x9ce9a534a3acc808) return vkGetPhysicalDeviceSparseImageFormatProperties;
+    if (funcNameHash == 0xdf1e5a19dae9208b) return vkGetPhysicalDeviceProperties;
+    if (funcNameHash == 0x736479d9aaecd06e) return vkGetPhysicalDeviceQueueFamilyProperties;
+    if (funcNameHash == 0x80666bfa24dd996f) return vkGetPhysicalDeviceMemoryProperties;
+    if (funcNameHash == 0x0d1d0e6ec5e20528) return vkEnumerateDeviceLayerProperties;
+    if (funcNameHash == 0x38ad6b820ca1b604) return vkEnumerateDeviceExtensionProperties;
+    if (funcNameHash == 0x45b2086251116f99) return vkCreateDevice;
+    if (funcNameHash == 0x39595c56305c625a) return vkGetDeviceProcAddr;
+    if (funcNameHash == 0x9ef6b4cec6a221f8) return vkDestroyDevice;
+    if (funcNameHash == 0x24683f73b0e5e597) return vkGetDeviceQueue;
+    if (funcNameHash == 0x0c3e489641018fd0) return vkQueueSubmit;
+    if (funcNameHash == 0x1fce1bdecaf06b52) return vkQueueWaitIdle;
+    if (funcNameHash == 0x1de9fd31feb0f22f) return vkDeviceWaitIdle;
+    if (funcNameHash == 0x3339f46d399c78c5) return vkAllocateMemory;
+    if (funcNameHash == 0xf2c5ad0d9aa4acf3) return vkFreeMemory;
+    if (funcNameHash == 0x808f7434b0596604) return vkMapMemory;
+    if (funcNameHash == 0xf51a3c7f77277e37) return vkUnmapMemory;
+    if (funcNameHash == 0xcdd7843304775055) return vkFlushMappedMemoryRanges;
+    if (funcNameHash == 0x3a0a07834723853e) return vkInvalidateMappedMemoryRanges;
+    if (funcNameHash == 0x40f65d68942eb094) return vkGetDeviceMemoryCommitment;
+    if (funcNameHash == 0x21e4a7d810574ab7) return vkGetImageSparseMemoryRequirements;
+    if (funcNameHash == 0x31f122b7cfd4bda7) return vkGetImageMemoryRequirements;
+    if (funcNameHash == 0xc18ca303430c5030) return vkGetBufferMemoryRequirements;
+    if (funcNameHash == 0x3fab09299e5024e6) return vkBindImageMemory;
+    if (funcNameHash == 0x75dc79c2cde7708a) return vkBindBufferMemory;
+    if (funcNameHash == 0x814945b3834b2f13) return vkQueueBindSparse;
+    if (funcNameHash == 0xb51bc46c54af21f6) return vkCreateFence;
+    if (funcNameHash == 0x865bc9e531e492a5) return vkDestroyFence;
+    if (funcNameHash == 0xddc1b3a9e007be5a) return vkGetFenceStatus;
+    if (funcNameHash == 0x234a880591facce1) return vkResetFences;
+    if (funcNameHash == 0x7c1238295eaa98e9) return vkWaitForFences;
+    if (funcNameHash == 0xb23c3f52093e01ee) return vkCreateSemaphore;
+    if (funcNameHash == 0xa90d9c4553e96cbe) return vkDestroySemaphore;
+    if (funcNameHash == 0xfc42afaa1bbc54a8) return vkCreateEvent;
+    if (funcNameHash == 0x6400678c24bf7d34) return vkDestroyEvent;
+    if (funcNameHash == 0x4e9ad990677f931c) return vkGetEventStatus;
+    if (funcNameHash == 0xd0df5f67ee24e975) return vkSetEvent;
+    if (funcNameHash == 0x2e0b5702efb33535) return vkResetEvent;
+    if (funcNameHash == 0x509b9755d54a9a1e) return vkCreateQueryPool;
+    if (funcNameHash == 0x352e0ca38b5e29c0) return vkDestroyQueryPool;
+    if (funcNameHash == 0x6b902433192f7f5d) return vkGetQueryPoolResults;
+    if (funcNameHash == 0x47176b0b432286d1) return vkCreateBuffer;
+    if (funcNameHash == 0x8ffccda86549f286) return vkDestroyBuffer;
+    if (funcNameHash == 0xf2fafc3e54bde6da) return vkCreateBufferView;
+    if (funcNameHash == 0xf56a44bbdebd81c5) return vkDestroyBufferView;
+    if (funcNameHash == 0x16a20753b1174318) return vkCreateImage;
+    if (funcNameHash == 0xc7d428e344b14ca8) return vkDestroyImage;
+    if (funcNameHash == 0x23d7885b70c5f681) return vkGetImageSubresourceLayout;
+    if (funcNameHash == 0xb2f2d8afec7a88a4) return vkCreateImageView;
+    if (funcNameHash == 0x76b72b76ccef2958) return vkDestroyImageView;
+    if (funcNameHash == 0xa3fdcfe5e638f01f) return vkCreateShaderModule;
+    if (funcNameHash == 0x7cb7f1711b397e5f) return vkDestroyShaderModule;
+    if (funcNameHash == 0x6474b3f3a4539ee3) return vkCreatePipelineCache;
+    if (funcNameHash == 0x1ae7324660591b8f) return vkDestroyPipelineCache;
+    if (funcNameHash == 0x17bb294acabe6a88) return vkGetPipelineCacheData;
+    if (funcNameHash == 0xcfbd6aad8345b609) return vkMergePipelineCaches;
+    if (funcNameHash == 0x5a4a030363a95dd6) return vkCreateGraphicsPipelines;
+    if (funcNameHash == 0xa8ab2a7a72d37501) return vkCreateComputePipelines;
+    if (funcNameHash == 0xc6158137c93c542a) return vkDestroyPipeline;
+    if (funcNameHash == 0x76e7d06d87565b38) return vkCreatePipelineLayout;
+    if (funcNameHash == 0x9022d31d32c4a419) return vkDestroyPipelineLayout;
+    if (funcNameHash == 0xcce224e583312a27) return vkCreateSampler;
+    if (funcNameHash == 0x1c9c24ff8ad40bf7) return vkDestroySampler;
+    if (funcNameHash == 0xabbbfebcb5e50ddf) return vkCreateDescriptorSetLayout;
+    if (funcNameHash == 0x44fcf619d29aa8fa) return vkDestroyDescriptorSetLayout;
+    if (funcNameHash == 0xfa53afc7b202a4cc) return vkCreateDescriptorPool;
+    if (funcNameHash == 0x928a039a45864345) return vkDestroyDescriptorPool;
+    if (funcNameHash == 0xa6007e58158aed7d) return vkResetDescriptorPool;
+    if (funcNameHash == 0x6f91a0562614466e) return vkAllocateDescriptorSets;
+    if (funcNameHash == 0x80bb22834c81711a) return vkFreeDescriptorSets;
+    if (funcNameHash == 0xaac33dd01204ea6d) return vkUpdateDescriptorSets;
+    if (funcNameHash == 0x38512bbacb368b24) return vkCreateFramebuffer;
+    if (funcNameHash == 0xc0faf7a0688b9961) return vkDestroyFramebuffer;
+    if (funcNameHash == 0x8b778f59be50c419) return vkCreateRenderPass;
+    if (funcNameHash == 0x87a7866d1df23f2b) return vkDestroyRenderPass;
+    if (funcNameHash == 0xcfd90dd84e50b6e2) return vkGetRenderAreaGranularity;
+    if (funcNameHash == 0xc7fb7a8e9fc178bf) return vkCreateCommandPool;
+    if (funcNameHash == 0x8ddf999c6ee753db) return vkDestroyCommandPool;
+    if (funcNameHash == 0x1e931402fc057014) return vkResetCommandPool;
+    if (funcNameHash == 0x03c070149bc4adcf) return vkAllocateCommandBuffers;
+    if (funcNameHash == 0x7ecb7451a7e045ed) return vkFreeCommandBuffers;
+    if (funcNameHash == 0x47d826cf3a236677) return vkBeginCommandBuffer;
+    if (funcNameHash == 0x3e52d6e9d1662eb2) return vkEndCommandBuffer;
+    if (funcNameHash == 0xc6fee3fca12fb11e) return vkResetCommandBuffer;
+    if (funcNameHash == 0x093d8596adfdb576) return vkCmdBindPipeline;
+    if (funcNameHash == 0xada92dcad41eaf98) return vkCmdBindDescriptorSets;
+    if (funcNameHash == 0x9beb233b5b7ad768) return vkCmdBindVertexBuffers;
+    if (funcNameHash == 0x668f24a3147926db) return vkCmdBindIndexBuffer;
+    if (funcNameHash == 0x33f6b7087e67dab4) return vkCmdSetViewport;
+    if (funcNameHash == 0xc746d971c6158609) return vkCmdSetScissor;
+    if (funcNameHash == 0xb7ddef653b0f7932) return vkCmdSetLineWidth;
+    if (funcNameHash == 0x74655211ce6abb4b) return vkCmdSetDepthBias;
+    if (funcNameHash == 0x9b6913d4f956684e) return vkCmdSetBlendConstants;
+    if (funcNameHash == 0x79cca6cf07ff9d67) return vkCmdSetDepthBounds;
+    if (funcNameHash == 0x371cc0f681367e4d) return vkCmdSetStencilCompareMask;
+    if (funcNameHash == 0x7ce4de962da7bc16) return vkCmdSetStencilWriteMask;
+    if (funcNameHash == 0xf6a1a179eb200ea3) return vkCmdSetStencilReference;
+    if (funcNameHash == 0x6b0e217ae8f0f1ac) return vkCmdDraw;
+    if (funcNameHash == 0xf9b2570c3144fc75) return vkCmdDrawIndexed;
+    if (funcNameHash == 0xf9cc9eb6cea6c9cb) return vkCmdDrawIndirect;
+    if (funcNameHash == 0x75ffe5f7fd486bdd) return vkCmdDrawIndexedIndirect;
+    if (funcNameHash == 0x9303bbd56b6cd187) return vkCmdDispatch;
+    if (funcNameHash == 0xdac55f445397e484) return vkCmdDispatchIndirect;
+    if (funcNameHash == 0x204df3e556149586) return vkCmdCopyBuffer;
+    if (funcNameHash == 0x438e5b6a754df791) return vkCmdCopyImage;
+    if (funcNameHash == 0x38f59a81a499abec) return vkCmdBlitImage;
+    if (funcNameHash == 0x4afe44fc10e34214) return vkCmdCopyBufferToImage;
+    if (funcNameHash == 0x88c098a6d45aa827) return vkCmdCopyImageToBuffer;
+    if (funcNameHash == 0xa1e0bb08c1850958) return vkCmdUpdateBuffer;
+    if (funcNameHash == 0x203c934aa0f948fc) return vkCmdFillBuffer;
+    if (funcNameHash == 0x900de63b0b6f0ca2) return vkCmdClearColorImage;
+    if (funcNameHash == 0x387f685e13e513fa) return vkCmdClearDepthStencilImage;
+    if (funcNameHash == 0x484c4c652a1f9c0e) return vkCmdClearAttachments;
+    if (funcNameHash == 0x22aa0793e66f037d) return vkCmdResolveImage;
+    if (funcNameHash == 0x5c738ec563b80923) return vkCmdSetEvent;
+    if (funcNameHash == 0x6ac16d77f8579056) return vkCmdResetEvent;
+    if (funcNameHash == 0x1441dbc95c1af085) return vkCmdWaitEvents;
+    if (funcNameHash == 0xb2063ddd597a6ad7) return vkCmdPipelineBarrier;
+    if (funcNameHash == 0x997ea78db49c8c69) return vkCmdBeginQuery;
+    if (funcNameHash == 0x99d50d423e66f60a) return vkCmdEndQuery;
+    if (funcNameHash == 0x1965935ee47e88e6) return vkCmdResetQueryPool;
+    if (funcNameHash == 0xee397d978e3960d4) return vkCmdWriteTimestamp;
+    if (funcNameHash == 0xe133357d099609f5) return vkCmdCopyQueryPoolResults;
+    if (funcNameHash == 0xf0bf149eb20282af) return vkCmdPushConstants;
+    if (funcNameHash == 0xc8c90b647a8c1688) return vkCmdBeginRenderPass;
+    if (funcNameHash == 0xf8a5e079575f045d) return vkCmdNextSubpass;
+    if (funcNameHash == 0x03e8b953ae4cc537) return vkCmdEndRenderPass;
+    if (funcNameHash == 0x1ce083dfe13eae46) return vkCmdExecuteCommands;
 
     // Core 1.1 functions
-    if (!strcmp(funcName, "vkEnumeratePhysicalDeviceGroups")) return vkEnumeratePhysicalDeviceGroups;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceFeatures2")) return vkGetPhysicalDeviceFeatures2;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceProperties2")) return vkGetPhysicalDeviceProperties2;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceFormatProperties2")) return vkGetPhysicalDeviceFormatProperties2;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceImageFormatProperties2")) return vkGetPhysicalDeviceImageFormatProperties2;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceQueueFamilyProperties2")) return vkGetPhysicalDeviceQueueFamilyProperties2;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceMemoryProperties2")) return vkGetPhysicalDeviceMemoryProperties2;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceSparseImageFormatProperties2"))
-        return vkGetPhysicalDeviceSparseImageFormatProperties2;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceExternalBufferProperties")) return vkGetPhysicalDeviceExternalBufferProperties;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceExternalSemaphoreProperties")) return vkGetPhysicalDeviceExternalSemaphoreProperties;
-    if (!strcmp(funcName, "vkGetPhysicalDeviceExternalFenceProperties")) return vkGetPhysicalDeviceExternalFenceProperties;
-    if (!strcmp(funcName, "vkBindBufferMemory2")) return vkBindBufferMemory2;
-    if (!strcmp(funcName, "vkBindImageMemory2")) return vkBindImageMemory2;
-    if (!strcmp(funcName, "vkGetDeviceGroupPeerMemoryFeatures")) return vkGetDeviceGroupPeerMemoryFeatures;
-    if (!strcmp(funcName, "vkCmdSetDeviceMask")) return vkCmdSetDeviceMask;
-    if (!strcmp(funcName, "vkCmdDispatchBase")) return vkCmdDispatchBase;
-    if (!strcmp(funcName, "vkGetImageMemoryRequirements2")) return vkGetImageMemoryRequirements2;
-    if (!strcmp(funcName, "vkTrimCommandPool")) return vkTrimCommandPool;
-    if (!strcmp(funcName, "vkGetDeviceQueue2")) return vkGetDeviceQueue2;
-    if (!strcmp(funcName, "vkCreateSamplerYcbcrConversion")) return vkCreateSamplerYcbcrConversion;
-    if (!strcmp(funcName, "vkDestroySamplerYcbcrConversion")) return vkDestroySamplerYcbcrConversion;
-    if (!strcmp(funcName, "vkGetDescriptorSetLayoutSupport")) return vkGetDescriptorSetLayoutSupport;
-    if (!strcmp(funcName, "vkCreateDescriptorUpdateTemplate")) return vkCreateDescriptorUpdateTemplate;
-    if (!strcmp(funcName, "vkDestroyDescriptorUpdateTemplate")) return vkDestroyDescriptorUpdateTemplate;
-    if (!strcmp(funcName, "vkUpdateDescriptorSetWithTemplate")) return vkUpdateDescriptorSetWithTemplate;
-    if (!strcmp(funcName, "vkGetImageSparseMemoryRequirements2")) return vkGetImageSparseMemoryRequirements2;
-    if (!strcmp(funcName, "vkGetBufferMemoryRequirements2")) return vkGetBufferMemoryRequirements2;
+    if (funcNameHash == 0x606f8ae1aaacec90) return vkEnumeratePhysicalDeviceGroups;
+    if (funcNameHash == 0x5dca2dd1ea6654ee) return vkGetPhysicalDeviceFeatures2;
+    if (funcNameHash == 0xd36fa6a24fe70f58) return vkGetPhysicalDeviceProperties2;
+    if (funcNameHash == 0x53d1f58fd7e7558c) return vkGetPhysicalDeviceFormatProperties2;
+    if (funcNameHash == 0xdfeb05796ee61f38) return vkGetPhysicalDeviceImageFormatProperties2;
+    if (funcNameHash == 0x5e3c48604b7158a4) return vkGetPhysicalDeviceQueueFamilyProperties2;
+    if (funcNameHash == 0xc92b2f5a154a828d) return vkGetPhysicalDeviceMemoryProperties2;
+    if (funcNameHash == 0x9338d10ef240c729) return vkGetPhysicalDeviceSparseImageFormatProperties2;
+    if (funcNameHash == 0x9d45d6ceeb54540f) return vkGetPhysicalDeviceExternalBufferProperties;
+    if (funcNameHash == 0xd7c941518fd0e818) return vkGetPhysicalDeviceExternalSemaphoreProperties;
+    if (funcNameHash == 0xdf03aa8b036d5b06) return vkGetPhysicalDeviceExternalFenceProperties;
+    if (funcNameHash == 0x1e001d1f829f257b) return vkBindBufferMemory2;
+    if (funcNameHash == 0xfd4ef6a737d2546d) return vkBindImageMemory2;
+    if (funcNameHash == 0xaf494d1294356cc7) return vkGetDeviceGroupPeerMemoryFeatures;
+    if (funcNameHash == 0x0b635494ffc80076) return vkCmdSetDeviceMask;
+    if (funcNameHash == 0xcff95583fb6ffa3f) return vkCmdDispatchBase;
+    if (funcNameHash == 0xb69a959653538c19) return vkGetImageMemoryRequirements2;
+    if (funcNameHash == 0x620e4a899bc7e882) return vkTrimCommandPool;
+    if (funcNameHash == 0x37cec3d3b8dc3838) return vkGetDeviceQueue2;
+    if (funcNameHash == 0xa1ba141ce2a9627b) return vkCreateSamplerYcbcrConversion;
+    if (funcNameHash == 0x2c685c0a5e9fbef2) return vkDestroySamplerYcbcrConversion;
+    if (funcNameHash == 0x25f6d470c53abf71) return vkGetDescriptorSetLayoutSupport;
+    if (funcNameHash == 0xe77fae71b009ad05) return vkCreateDescriptorUpdateTemplate;
+    if (funcNameHash == 0x410043fbd97c4c0d) return vkDestroyDescriptorUpdateTemplate;
+    if (funcNameHash == 0x1ebd0c97c69da82b) return vkUpdateDescriptorSetWithTemplate;
+    if (funcNameHash == 0xa43291af959e4044) return vkGetImageSparseMemoryRequirements2;
+    if (funcNameHash == 0x146940f88e38657b) return vkGetBufferMemoryRequirements2;
 
     // Core 1.2 functions
-    if (!strcmp(funcName, "vkCreateRenderPass2")) return vkCreateRenderPass2;
-    if (!strcmp(funcName, "vkCmdBeginRenderPass2")) return vkCmdBeginRenderPass2;
-    if (!strcmp(funcName, "vkCmdNextSubpass2")) return vkCmdNextSubpass2;
-    if (!strcmp(funcName, "vkCmdEndRenderPass2")) return vkCmdEndRenderPass2;
-    if (!strcmp(funcName, "vkCmdDrawIndirectCount")) return vkCmdDrawIndirectCount;
-    if (!strcmp(funcName, "vkCmdDrawIndexedIndirectCount")) return vkCmdDrawIndexedIndirectCount;
-    if (!strcmp(funcName, "vkGetSemaphoreCounterValue")) return vkGetSemaphoreCounterValue;
-    if (!strcmp(funcName, "vkWaitSemaphores")) return vkWaitSemaphores;
-    if (!strcmp(funcName, "vkSignalSemaphore")) return vkSignalSemaphore;
-    if (!strcmp(funcName, "vkGetBufferDeviceAddress")) return vkGetBufferDeviceAddress;
-    if (!strcmp(funcName, "vkGetBufferOpaqueCaptureAddress")) return vkGetBufferOpaqueCaptureAddress;
-    if (!strcmp(funcName, "vkGetDeviceMemoryOpaqueCaptureAddress")) return vkGetDeviceMemoryOpaqueCaptureAddress;
-    if (!strcmp(funcName, "vkResetQueryPool")) return vkResetQueryPool;
+    if (funcNameHash == 0xfd2a746603a13f60) return vkCreateRenderPass2;
+    if (funcNameHash == 0xf763fd5a051145b3) return vkCmdBeginRenderPass2;
+    if (funcNameHash == 0x09d5feddc371e187) return vkCmdNextSubpass2;
+    if (funcNameHash == 0xd271ad249d3a5d1d) return vkCmdEndRenderPass2;
+    if (funcNameHash == 0x1b435983eb84abaa) return vkCmdDrawIndirectCount;
+    if (funcNameHash == 0x1d4114fa0cce1718) return vkCmdDrawIndexedIndirectCount;
+    if (funcNameHash == 0xd60ca89f1c84b347) return vkGetSemaphoreCounterValue;
+    if (funcNameHash == 0x464cdf5591d873eb) return vkWaitSemaphores;
+    if (funcNameHash == 0x6a0ad52ae1fd239d) return vkSignalSemaphore;
+    if (funcNameHash == 0x44fbf4ea4b060b61) return vkGetBufferDeviceAddress;
+    if (funcNameHash == 0x5639c874fc9132f4) return vkGetBufferOpaqueCaptureAddress;
+    if (funcNameHash == 0x9666a70591f64892) return vkGetDeviceMemoryOpaqueCaptureAddress;
+    if (funcNameHash == 0xd34524d6520a5733) return vkResetQueryPool;
 
     // Core 1.3 functions
-    if (!strcmp(funcName, "vkGetPhysicalDeviceToolProperties")) return vkGetPhysicalDeviceToolProperties;
-    if (!strcmp(funcName, "vkCreatePrivateDataSlot")) return vkCreatePrivateDataSlot;
-    if (!strcmp(funcName, "vkDestroyPrivateDataSlot")) return vkDestroyPrivateDataSlot;
-    if (!strcmp(funcName, "vkSetPrivateData")) return vkSetPrivateData;
-    if (!strcmp(funcName, "vkGetPrivateData")) return vkGetPrivateData;
-    if (!strcmp(funcName, "vkCmdSetEvent2")) return vkCmdSetEvent2;
-    if (!strcmp(funcName, "vkCmdResetEvent2")) return vkCmdResetEvent2;
-    if (!strcmp(funcName, "vkCmdWaitEvents2")) return vkCmdWaitEvents2;
-    if (!strcmp(funcName, "vkCmdPipelineBarrier2")) return vkCmdPipelineBarrier2;
-    if (!strcmp(funcName, "vkCmdWriteTimestamp2")) return vkCmdWriteTimestamp2;
-    if (!strcmp(funcName, "vkQueueSubmit2")) return vkQueueSubmit2;
-    if (!strcmp(funcName, "vkCmdCopyBuffer2")) return vkCmdCopyBuffer2;
-    if (!strcmp(funcName, "vkCmdCopyImage2")) return vkCmdCopyImage2;
-    if (!strcmp(funcName, "vkCmdCopyBufferToImage2")) return vkCmdCopyBufferToImage2;
-    if (!strcmp(funcName, "vkCmdCopyImageToBuffer2")) return vkCmdCopyImageToBuffer2;
-    if (!strcmp(funcName, "vkCmdBlitImage2")) return vkCmdBlitImage2;
-    if (!strcmp(funcName, "vkCmdResolveImage2")) return vkCmdResolveImage2;
-    if (!strcmp(funcName, "vkCmdBeginRendering")) return vkCmdBeginRendering;
-    if (!strcmp(funcName, "vkCmdEndRendering")) return vkCmdEndRendering;
-    if (!strcmp(funcName, "vkCmdSetCullMode")) return vkCmdSetCullMode;
-    if (!strcmp(funcName, "vkCmdSetFrontFace")) return vkCmdSetFrontFace;
-    if (!strcmp(funcName, "vkCmdSetPrimitiveTopology")) return vkCmdSetPrimitiveTopology;
-    if (!strcmp(funcName, "vkCmdSetViewportWithCount")) return vkCmdSetViewportWithCount;
-    if (!strcmp(funcName, "vkCmdSetScissorWithCount")) return vkCmdSetScissorWithCount;
-    if (!strcmp(funcName, "vkCmdBindVertexBuffers2")) return vkCmdBindVertexBuffers2;
-    if (!strcmp(funcName, "vkCmdSetDepthTestEnable")) return vkCmdSetDepthTestEnable;
-    if (!strcmp(funcName, "vkCmdSetDepthWriteEnable")) return vkCmdSetDepthWriteEnable;
-    if (!strcmp(funcName, "vkCmdSetDepthCompareOp")) return vkCmdSetDepthCompareOp;
-    if (!strcmp(funcName, "vkCmdSetDepthBoundsTestEnable")) return vkCmdSetDepthBoundsTestEnable;
-    if (!strcmp(funcName, "vkCmdSetStencilTestEnable")) return vkCmdSetStencilTestEnable;
-    if (!strcmp(funcName, "vkCmdSetStencilOp")) return vkCmdSetStencilOp;
-    if (!strcmp(funcName, "vkCmdSetRasterizerDiscardEnable")) return vkCmdSetRasterizerDiscardEnable;
-    if (!strcmp(funcName, "vkCmdSetDepthBiasEnable")) return vkCmdSetDepthBiasEnable;
-    if (!strcmp(funcName, "vkCmdSetPrimitiveRestartEnable")) return vkCmdSetPrimitiveRestartEnable;
-    if (!strcmp(funcName, "vkGetDeviceBufferMemoryRequirements")) return vkGetDeviceBufferMemoryRequirements;
-    if (!strcmp(funcName, "vkGetDeviceImageMemoryRequirements")) return vkGetDeviceImageMemoryRequirements;
-    if (!strcmp(funcName, "vkGetDeviceImageSparseMemoryRequirements")) return vkGetDeviceImageSparseMemoryRequirements;
+    if (funcNameHash == 0xf14ce64102b8eced) return vkGetPhysicalDeviceToolProperties;
+    if (funcNameHash == 0x126d3121c5d14c5f) return vkCreatePrivateDataSlot;
+    if (funcNameHash == 0xe8fbd5bb4e925208) return vkDestroyPrivateDataSlot;
+    if (funcNameHash == 0x2384403e82f430b9) return vkSetPrivateData;
+    if (funcNameHash == 0xe43a4f01acf5a1b6) return vkGetPrivateData;
+    if (funcNameHash == 0x358c26001c7dea62) return vkCmdSetEvent2;
+    if (funcNameHash == 0x75fdc7101f295d5d) return vkCmdResetEvent2;
+    if (funcNameHash == 0xba764f7da1952e81) return vkCmdWaitEvents2;
+    if (funcNameHash == 0x5365aba2c3922f6a) return vkCmdPipelineBarrier2;
+    if (funcNameHash == 0x6172f26a7ff5e461) return vkCmdWriteTimestamp2;
+    if (funcNameHash == 0x60464991fe32093e) return vkQueueSubmit2;
+    if (funcNameHash == 0x6af432892c9a71c2) return vkCmdCopyBuffer2;
+    if (funcNameHash == 0xfbe9454065432dfa) return vkCmdCopyImage2;
+    if (funcNameHash == 0xdab35189cc70375d) return vkCmdCopyBufferToImage2;
+    if (funcNameHash == 0x07b8ecf11f0a147a) return vkCmdCopyImageToBuffer2;
+    if (funcNameHash == 0xfb75695f0deb8eb6) return vkCmdBlitImage2;
+    if (funcNameHash == 0x110bf15d39ef5684) return vkCmdResolveImage2;
+    if (funcNameHash == 0x950906daed043635) return vkCmdBeginRendering;
+    if (funcNameHash == 0xc261491c6f3eb73a) return vkCmdEndRendering;
+    if (funcNameHash == 0xef3c02c6a6557f67) return vkCmdSetCullMode;
+    if (funcNameHash == 0xb90a1a834aa8c307) return vkCmdSetFrontFace;
+    if (funcNameHash == 0xc4a32c157b57c919) return vkCmdSetPrimitiveTopology;
+    if (funcNameHash == 0x0198a65d97d8c9de) return vkCmdSetViewportWithCount;
+    if (funcNameHash == 0xb9dc146482b98eab) return vkCmdSetScissorWithCount;
+    if (funcNameHash == 0xf5dd10901cd99b7e) return vkCmdBindVertexBuffers2;
+    if (funcNameHash == 0xefff832805016a4e) return vkCmdSetDepthTestEnable;
+    if (funcNameHash == 0xa52ec7d995ba8bd0) return vkCmdSetDepthWriteEnable;
+    if (funcNameHash == 0x97fb69a7181762a0) return vkCmdSetDepthCompareOp;
+    if (funcNameHash == 0xc282ec2fb0ff4a7f) return vkCmdSetDepthBoundsTestEnable;
+    if (funcNameHash == 0x7d12fe073f7c9462) return vkCmdSetStencilTestEnable;
+    if (funcNameHash == 0x1ce7a67a576268eb) return vkCmdSetStencilOp;
+    if (funcNameHash == 0x5ee0b29b506c2241) return vkCmdSetRasterizerDiscardEnable;
+    if (funcNameHash == 0x1de7b0458bd04513) return vkCmdSetDepthBiasEnable;
+    if (funcNameHash == 0x5a7b2addceb670c9) return vkCmdSetPrimitiveRestartEnable;
+    if (funcNameHash == 0x15aae27a7223ea5e) return vkGetDeviceBufferMemoryRequirements;
+    if (funcNameHash == 0x3f4274cc71793a20) return vkGetDeviceImageMemoryRequirements;
+    if (funcNameHash == 0x987ef1c05cbaa5d8) return vkGetDeviceImageSparseMemoryRequirements;
 
     // Core 1.4 functions
-    if (!strcmp(funcName, "vkCmdSetLineStipple")) return vkCmdSetLineStipple;
-    if (!strcmp(funcName, "vkMapMemory2")) return vkMapMemory2;
-    if (!strcmp(funcName, "vkUnmapMemory2")) return vkUnmapMemory2;
-    if (!strcmp(funcName, "vkCmdBindIndexBuffer2")) return vkCmdBindIndexBuffer2;
-    if (!strcmp(funcName, "vkGetRenderingAreaGranularity")) return vkGetRenderingAreaGranularity;
-    if (!strcmp(funcName, "vkGetDeviceImageSubresourceLayout")) return vkGetDeviceImageSubresourceLayout;
-    if (!strcmp(funcName, "vkGetImageSubresourceLayout2")) return vkGetImageSubresourceLayout2;
-    if (!strcmp(funcName, "vkCmdPushDescriptorSet")) return vkCmdPushDescriptorSet;
-    if (!strcmp(funcName, "vkCmdPushDescriptorSetWithTemplate")) return vkCmdPushDescriptorSetWithTemplate;
-    if (!strcmp(funcName, "vkCmdSetRenderingAttachmentLocations")) return vkCmdSetRenderingAttachmentLocations;
-    if (!strcmp(funcName, "vkCmdSetRenderingInputAttachmentIndices")) return vkCmdSetRenderingInputAttachmentIndices;
-    if (!strcmp(funcName, "vkCmdBindDescriptorSets2")) return vkCmdBindDescriptorSets2;
-    if (!strcmp(funcName, "vkCmdPushConstants2")) return vkCmdPushConstants2;
-    if (!strcmp(funcName, "vkCmdPushDescriptorSet2")) return vkCmdPushDescriptorSet2;
-    if (!strcmp(funcName, "vkCmdPushDescriptorSetWithTemplate2")) return vkCmdPushDescriptorSetWithTemplate2;
-    if (!strcmp(funcName, "vkCopyMemoryToImage")) return vkCopyMemoryToImage;
-    if (!strcmp(funcName, "vkCopyImageToMemory")) return vkCopyImageToMemory;
-    if (!strcmp(funcName, "vkCopyImageToImage")) return vkCopyImageToImage;
-    if (!strcmp(funcName, "vkTransitionImageLayout")) return vkTransitionImageLayout;
+    if (funcNameHash == 0xf738ab31f5c4808a) return vkCmdSetLineStipple;
+    if (funcNameHash == 0xaf2b917e19ff90c6) return vkMapMemory2;
+    if (funcNameHash == 0xd75ed866d33442a9) return vkUnmapMemory2;
+    if (funcNameHash == 0x540370e7058dd6ac) return vkCmdBindIndexBuffer2;
+    if (funcNameHash == 0xf7190fead13f236c) return vkGetRenderingAreaGranularity;
+    if (funcNameHash == 0xe47d87648c47352c) return vkGetDeviceImageSubresourceLayout;
+    if (funcNameHash == 0x656d8617bf4a33fc) return vkGetImageSubresourceLayout2;
+    if (funcNameHash == 0xf0560464399d1a5d) return vkCmdPushDescriptorSet;
+    if (funcNameHash == 0x6cd2fae1ab9c9a75) return vkCmdPushDescriptorSetWithTemplate;
+    if (funcNameHash == 0x3a28620bd767d9f5) return vkCmdSetRenderingAttachmentLocations;
+    if (funcNameHash == 0xc3b0dc0e29037a73) return vkCmdSetRenderingInputAttachmentIndices;
+    if (funcNameHash == 0x1d81583e5255fa64) return vkCmdBindDescriptorSets2;
+    if (funcNameHash == 0x7b5bca3ce9a7ccca) return vkCmdPushConstants2;
+    if (funcNameHash == 0x4c2e756549427154) return vkCmdPushDescriptorSet2;
+    if (funcNameHash == 0x333e4270d99c5326) return vkCmdPushDescriptorSetWithTemplate2;
+    if (funcNameHash == 0x6333940945f764eb) return vkCopyMemoryToImage;
+    if (funcNameHash == 0x25cbce2cf01ae221) return vkCopyImageToMemory;
+    if (funcNameHash == 0xa0e05031ca80b190) return vkCopyImageToImage;
+    if (funcNameHash == 0x34455b16a968d1f7) return vkTransitionImageLayout;
 
     // Instance extensions
     void *addr;
-    if (debug_extensions_InstanceGpa(inst, funcName, &addr)) return addr;
+    if (debug_extensions_InstanceGpa(inst, funcName, funcNameHash, &addr)) return addr;
 
-    if (wsi_swapchain_instance_gpa(inst, funcName, &addr)) return addr;
+    if (wsi_swapchain_instance_gpa(inst, funcName, funcNameHash, &addr)) return addr;
 
-    if (extension_instance_gpa(inst, funcName, &addr)) return addr;
+    if (extension_instance_gpa(inst, funcName, funcNameHash, &addr)) return addr;
 
     // Unknown physical device extensions
     addr = loader_phys_dev_ext_gpa_tramp(inst, funcName);
@@ -289,12 +292,14 @@ void *trampoline_get_proc_addr(struct loader_instance *inst, const char *funcNam
 
 void *globalGetProcAddr(const char *name) {
     if (!name || name[0] != 'v' || name[1] != 'k') return NULL;
-
     name += 2;
-    if (!strcmp(name, "CreateInstance")) return vkCreateInstance;
-    if (!strcmp(name, "EnumerateInstanceExtensionProperties")) return vkEnumerateInstanceExtensionProperties;
-    if (!strcmp(name, "EnumerateInstanceLayerProperties")) return vkEnumerateInstanceLayerProperties;
-    if (!strcmp(name, "EnumerateInstanceVersion")) return vkEnumerateInstanceVersion;
+
+    uint64_t funcNameHash = XXH3_64bits(name, strlen(name));
+
+	if (funcNameHash == 0x651984a64d6e399c) return vkCreateInstance;
+	if (funcNameHash == 0x421ce1009b113c5e) return vkEnumerateInstanceExtensionProperties;
+	if (funcNameHash == 0x867c0fbe7b241372) return vkEnumerateInstanceLayerProperties;
+	if (funcNameHash == 0x6b10d06b8249a243) return vkEnumerateInstanceVersion;
 
     return NULL;
 }
diff --git a/loader/loader.c b/loader/loader.c
index 9deff6881..2ac8f4db1 100644
--- a/loader/loader.c
+++ b/loader/loader.c
@@ -4115,8 +4115,10 @@ VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL loader_gpdpa_instance_terminator(VkInst
         disp_table = &loader_inst->terminator_dispatch;
     }
 
+    uint64_t nameHash = pName ? XXH3_64bits(pName, strlen(pName)) : 0;
+
     bool found_name;
-    void *addr = loader_lookup_instance_dispatch_table(disp_table, pName, &found_name);
+    void *addr = loader_lookup_instance_dispatch_table(disp_table, pName, nameHash, &found_name);
     if (found_name) {
         return addr;
     }
@@ -4131,25 +4133,27 @@ VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL loader_gpdpa_instance_terminator(VkInst
 }
 
 VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL loader_gpa_instance_terminator(VkInstance inst, const char *pName) {
+    uint64_t nameHash = XXH3_64bits(pName, strlen(pName));
+
     // Global functions - Do not need a valid instance handle to query
-    if (!strcmp(pName, "vkGetInstanceProcAddr")) {
+    if (nameHash == 0xbdf594b7ae4af921 /* vkGetInstanceProcAddr */) {
         return (PFN_vkVoidFunction)loader_gpa_instance_terminator;
     }
-    if (!strcmp(pName, "vk_layerGetPhysicalDeviceProcAddr")) {
+    if (nameHash == 0x717e697d1633d74d /* vk_layerGetPhysicalDeviceProcAddr */) {
         return (PFN_vkVoidFunction)loader_gpdpa_instance_terminator;
     }
-    if (!strcmp(pName, "vkCreateInstance")) {
+    if (nameHash == 0xed8a6efd46f4e052 /* vkCreateInstance */) {
         return (PFN_vkVoidFunction)terminator_CreateInstance;
     }
     // If a layer is querying pre-instance functions using vkGetInstanceProcAddr, we need to return function pointers that match the
     // Vulkan API
-    if (!strcmp(pName, "vkEnumerateInstanceLayerProperties")) {
+    if (nameHash == 0xc930c283b60dafd0 /* vkEnumerateInstanceLayerProperties */) {
         return (PFN_vkVoidFunction)terminator_EnumerateInstanceLayerProperties;
     }
-    if (!strcmp(pName, "vkEnumerateInstanceExtensionProperties")) {
+    if (nameHash == 0x293f4d0e3d436dce /* vkEnumerateInstanceExtensionProperties */) {
         return (PFN_vkVoidFunction)terminator_EnumerateInstanceExtensionProperties;
     }
-    if (!strcmp(pName, "vkEnumerateInstanceVersion")) {
+    if (nameHash == 0xf79cbf7989a3746e /* vkEnumerateInstanceVersion */) {
         return (PFN_vkVoidFunction)terminator_EnumerateInstanceVersion;
     }
 
@@ -4158,7 +4162,7 @@ VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL loader_gpa_instance_terminator(VkInstan
 
     // As such, this is a bug to maintain compatibility for the RTSS layer (Riva Tuner Statistics Server) but may
     // be depended upon by other layers out in the wild.
-    if (!strcmp(pName, "vkCreateDevice")) {
+    if (nameHash == 0x45b2086251116f99 /* vkCreateDevice */) {
         return (PFN_vkVoidFunction)terminator_CreateDevice;
     }
 
@@ -4177,35 +4181,35 @@ VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL loader_gpa_instance_terminator(VkInstan
     // is 'supported' by the loader.
     // These functions need a terminator to handle the case of a driver not supporting VK_EXT_debug_utils when there are layers
     // present which not check for NULL before calling the function.
-    if (!strcmp(pName, "vkSetDebugUtilsObjectNameEXT")) {
+    if (nameHash == 0xfccd697bc5cf4494 /* vkSetDebugUtilsObjectNameEXT */) {
         return loader_inst->enabled_known_extensions.ext_debug_utils ? (PFN_vkVoidFunction)terminator_SetDebugUtilsObjectNameEXT
                                                                      : NULL;
     }
-    if (!strcmp(pName, "vkSetDebugUtilsObjectTagEXT")) {
+    if (nameHash == 0x7fd35824391d47a4 /* vkSetDebugUtilsObjectTagEXT */) {
         return loader_inst->enabled_known_extensions.ext_debug_utils ? (PFN_vkVoidFunction)terminator_SetDebugUtilsObjectTagEXT
                                                                      : NULL;
     }
-    if (!strcmp(pName, "vkQueueBeginDebugUtilsLabelEXT")) {
+    if (nameHash == 0xd88e4fe9c0329771 /* vkQueueBeginDebugUtilsLabelEXT */) {
         return loader_inst->enabled_known_extensions.ext_debug_utils ? (PFN_vkVoidFunction)terminator_QueueBeginDebugUtilsLabelEXT
                                                                      : NULL;
     }
-    if (!strcmp(pName, "vkQueueEndDebugUtilsLabelEXT")) {
+    if (nameHash == 0x6756af5e610d6533 /* vkQueueEndDebugUtilsLabelEXT */) {
         return loader_inst->enabled_known_extensions.ext_debug_utils ? (PFN_vkVoidFunction)terminator_QueueEndDebugUtilsLabelEXT
                                                                      : NULL;
     }
-    if (!strcmp(pName, "vkQueueInsertDebugUtilsLabelEXT")) {
+    if (nameHash == 0xe2b6c462d682d0aa /* vkQueueInsertDebugUtilsLabelEXT */) {
         return loader_inst->enabled_known_extensions.ext_debug_utils ? (PFN_vkVoidFunction)terminator_QueueInsertDebugUtilsLabelEXT
                                                                      : NULL;
     }
-    if (!strcmp(pName, "vkCmdBeginDebugUtilsLabelEXT")) {
+    if (nameHash == 0xa53a9028f9deee27 /* vkCmdBeginDebugUtilsLabelEXT */) {
         return loader_inst->enabled_known_extensions.ext_debug_utils ? (PFN_vkVoidFunction)terminator_CmdBeginDebugUtilsLabelEXT
                                                                      : NULL;
     }
-    if (!strcmp(pName, "vkCmdEndDebugUtilsLabelEXT")) {
+    if (nameHash == 0xb70a1f7b0d640472 /* vkCmdEndDebugUtilsLabelEXT */) {
         return loader_inst->enabled_known_extensions.ext_debug_utils ? (PFN_vkVoidFunction)terminator_CmdEndDebugUtilsLabelEXT
                                                                      : NULL;
     }
-    if (!strcmp(pName, "vkCmdInsertDebugUtilsLabelEXT")) {
+    if (nameHash == 0x0f70146a40b73eaf /* vkCmdInsertDebugUtilsLabelEXT */) {
         return loader_inst->enabled_known_extensions.ext_debug_utils ? (PFN_vkVoidFunction)terminator_CmdInsertDebugUtilsLabelEXT
                                                                      : NULL;
     }
@@ -4215,7 +4219,7 @@ VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL loader_gpa_instance_terminator(VkInstan
     }
 
     bool found_name;
-    void *addr = loader_lookup_instance_dispatch_table(disp_table, pName, &found_name);
+    void *addr = loader_lookup_instance_dispatch_table(disp_table, pName, nameHash, &found_name);
     if (found_name) {
         return addr;
     }
diff --git a/loader/trampoline.c b/loader/trampoline.c
index 143aca4a7..981c85199 100644
--- a/loader/trampoline.c
+++ b/loader/trampoline.c
@@ -39,6 +39,8 @@
 #include "vk_loader_extensions.h"
 #include "vk_loader_platform.h"
 #include "wsi.h"
+#define XXH_INLINE_ALL
+#include <xxhash.h>
 
 // Trampoline entrypoints are in this file for core Vulkan commands
 
@@ -121,22 +123,22 @@ LOADER_EXPORT VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vkGetInstanceProcAddr(VkI
 LOADER_EXPORT VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vkGetDeviceProcAddr(VkDevice device, const char *pName) {
     if (!pName || pName[0] != 'v' || pName[1] != 'k') return NULL;
 
+    uint64_t nameHash = XXH3_64bits(pName, strlen(pName));
+
     // For entrypoints that loader must handle (ie non-dispatchable or create object)
     // make sure the loader entrypoint is returned
-    const char *name = pName;
-    name += 2;
-    if (!strcmp(name, "GetDeviceProcAddr")) return (PFN_vkVoidFunction)vkGetDeviceProcAddr;
-    if (!strcmp(name, "DestroyDevice")) return (PFN_vkVoidFunction)vkDestroyDevice;
-    if (!strcmp(name, "GetDeviceQueue")) return (PFN_vkVoidFunction)vkGetDeviceQueue;
-    if (!strcmp(name, "AllocateCommandBuffers")) return (PFN_vkVoidFunction)vkAllocateCommandBuffers;
+    if (nameHash == 0x39595c56305c625a) return (PFN_vkVoidFunction)vkGetDeviceProcAddr;
+    if (nameHash == 0x9ef6b4cec6a221f8) return (PFN_vkVoidFunction)vkDestroyDevice;
+    if (nameHash == 0x24683f73b0e5e597) return (PFN_vkVoidFunction)vkGetDeviceQueue;
+    if (nameHash == 0x03c070149bc4adcf) return (PFN_vkVoidFunction)vkAllocateCommandBuffers;
 
     // Although CreateDevice is on device chain it's dispatchable object isn't
     // a VkDevice or child of VkDevice so return NULL.
-    if (!strcmp(pName, "CreateDevice")) return NULL;
+    if (nameHash == 0x45b2086251116f99 /* vkCreateDevice */) return NULL;
 
     // Because vkGetDeviceQueue2 is a 1.1 entry point, we need to check if the apiVersion provided during instance creation is
     // sufficient
-    if (!strcmp(name, "GetDeviceQueue2")) {
+    if (nameHash == 0x37cec3d3b8dc3838 /* vkGetDeviceQueue2 */) {
         struct loader_device *dev = NULL;
         struct loader_icd_term *icd_term = loader_get_icd_and_device(device, &dev);
         if (NULL != icd_term && dev != NULL) {
@@ -154,7 +156,7 @@ LOADER_EXPORT VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vkGetDeviceProcAddr(VkDev
     if (disp_table == NULL) return NULL;
 
     bool found_name = false;
-    void *addr = loader_lookup_device_dispatch_table(disp_table, pName, &found_name);
+    void *addr = loader_lookup_device_dispatch_table(disp_table, pName, nameHash, &found_name);
     if (found_name) return addr;
 
     if (disp_table->GetDeviceProcAddr == NULL) return NULL;
diff --git a/loader/wsi.c b/loader/wsi.c
index d04b7b3c9..186c57a1c 100644
--- a/loader/wsi.c
+++ b/loader/wsi.c
@@ -34,6 +34,8 @@
 #include "stack_allocation.h"
 #include "vk_loader_platform.h"
 #include "wsi.h"
+#define XXH_INLINE_ALL
+#include <xxhash.h>
 
 // The first ICD/Loader interface that support querying the SurfaceKHR from
 // the ICDs.
@@ -2669,53 +2671,53 @@ VKAPI_ATTR VkResult VKAPI_CALL terminator_GetPhysicalDeviceSurfaceFormats2KHR(Vk
     }
 }
 
-bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char *name, void **addr) {
+bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char *name, uint64_t nameHash, void **addr) {
     *addr = NULL;
 
     // Functions for the VK_KHR_surface extension:
-    if (!strcmp("vkDestroySurfaceKHR", name)) {
+    if (nameHash == 0xb746a730e03f945f) {
         *addr = loader_inst->wsi_surface_enabled ? (void *)vkDestroySurfaceKHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceSurfaceSupportKHR", name)) {
+    if (nameHash == 0xfa972e7a0d03ee3c) {
         *addr = loader_inst->wsi_surface_enabled ? (void *)vkGetPhysicalDeviceSurfaceSupportKHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceSurfaceCapabilitiesKHR", name)) {
+    if (nameHash == 0x70e6e260c2fba0f4) {
         *addr = loader_inst->wsi_surface_enabled ? (void *)vkGetPhysicalDeviceSurfaceCapabilitiesKHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceSurfaceFormatsKHR", name)) {
+    if (nameHash == 0x3c043f25e88ad467) {
         *addr = loader_inst->wsi_surface_enabled ? (void *)vkGetPhysicalDeviceSurfaceFormatsKHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceSurfacePresentModesKHR", name)) {
+    if (nameHash == 0x52d4fff81b4ea8de) {
         *addr = loader_inst->wsi_surface_enabled ? (void *)vkGetPhysicalDeviceSurfacePresentModesKHR : NULL;
         return true;
     }
 
-    if (!strcmp("vkGetDeviceGroupPresentCapabilitiesKHR", name)) {
+    if (nameHash == 0xd537fdf3c85210f2) {
         *addr = loader_inst->wsi_surface_enabled ? (void *)vkGetDeviceGroupPresentCapabilitiesKHR : NULL;
         return true;
     }
 
-    if (!strcmp("vkGetDeviceGroupSurfacePresentModesKHR", name)) {
+    if (nameHash == 0x32e6d8b01681a0b2) {
         *addr = loader_inst->wsi_surface_enabled ? (void *)vkGetDeviceGroupSurfacePresentModesKHR : NULL;
         return true;
     }
 
-    if (!strcmp("vkGetPhysicalDevicePresentRectanglesKHR", name)) {
+    if (nameHash == 0xadec6ca4a17a30f5) {
         *addr = loader_inst->wsi_surface_enabled ? (void *)vkGetPhysicalDevicePresentRectanglesKHR : NULL;
         return true;
     }
 
     // Functions for VK_KHR_get_surface_capabilities2 extension:
-    if (!strcmp("vkGetPhysicalDeviceSurfaceCapabilities2KHR", name)) {
+    if (nameHash == 0xeadc76790fea3998) {
         *addr = loader_inst->wsi_surface_enabled ? (void *)vkGetPhysicalDeviceSurfaceCapabilities2KHR : NULL;
         return true;
     }
 
-    if (!strcmp("vkGetPhysicalDeviceSurfaceFormats2KHR", name)) {
+    if (nameHash == 0xba60d8eb22951ad2) {
         *addr = loader_inst->wsi_surface_enabled ? (void *)vkGetPhysicalDeviceSurfaceFormats2KHR : NULL;
         return true;
     }
@@ -2726,27 +2728,27 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
     // exported from the loader.  Per Khronos decisions, the loader's GIPA
     // function will return the trampoline function for such device-extension
     // functions, regardless of whether the extension has been enabled.
-    if (!strcmp("vkCreateSwapchainKHR", name)) {
+    if (nameHash == 0x536ddebd6b81d90a) {
         *addr = (void *)vkCreateSwapchainKHR;
         return true;
     }
-    if (!strcmp("vkDestroySwapchainKHR", name)) {
+    if (nameHash == 0x22466386cc1398b8) {
         *addr = (void *)vkDestroySwapchainKHR;
         return true;
     }
-    if (!strcmp("vkGetSwapchainImagesKHR", name)) {
+    if (nameHash == 0xe3e71921cd13bc5f) {
         *addr = (void *)vkGetSwapchainImagesKHR;
         return true;
     }
-    if (!strcmp("vkAcquireNextImageKHR", name)) {
+    if (nameHash == 0x003f01982149c676) {
         *addr = (void *)vkAcquireNextImageKHR;
         return true;
     }
-    if (!strcmp("vkQueuePresentKHR", name)) {
+    if (nameHash == 0x003f01982149c676) {
         *addr = (void *)vkQueuePresentKHR;
         return true;
     }
-    if (!strcmp("vkAcquireNextImage2KHR", name)) {
+    if (nameHash == 0x81f991d1ab0bc5ce) {
         *addr = (void *)vkAcquireNextImage2KHR;
         return true;
     }
@@ -2754,11 +2756,11 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
 
     // Functions for the VK_KHR_win32_surface extension:
-    if (!strcmp("vkCreateWin32SurfaceKHR", name)) {
+    if (nameHash == 0xd6fbb1a654e70656) {
         *addr = loader_inst->wsi_win32_surface_enabled ? (void *)vkCreateWin32SurfaceKHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceWin32PresentationSupportKHR", name)) {
+    if (nameHash == 0x148832c9169f3e74) {
         *addr = loader_inst->wsi_win32_surface_enabled ? (void *)vkGetPhysicalDeviceWin32PresentationSupportKHR : NULL;
         return true;
     }
@@ -2766,11 +2768,11 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
 #if defined(VK_USE_PLATFORM_WAYLAND_KHR)
 
     // Functions for the VK_KHR_wayland_surface extension:
-    if (!strcmp("vkCreateWaylandSurfaceKHR", name)) {
+    if (nameHash == 0x2bcf2ad912ad48a3) {
         *addr = loader_inst->wsi_wayland_surface_enabled ? (void *)vkCreateWaylandSurfaceKHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceWaylandPresentationSupportKHR", name)) {
+    if (nameHash == 0xd40235c9cab9b686) {
         *addr = loader_inst->wsi_wayland_surface_enabled ? (void *)vkGetPhysicalDeviceWaylandPresentationSupportKHR : NULL;
         return true;
     }
@@ -2778,11 +2780,11 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
 #if defined(VK_USE_PLATFORM_XCB_KHR)
 
     // Functions for the VK_KHR_xcb_surface extension:
-    if (!strcmp("vkCreateXcbSurfaceKHR", name)) {
+    if (nameHash == 0xc8b1c23e6174b64b) {
         *addr = loader_inst->wsi_xcb_surface_enabled ? (void *)vkCreateXcbSurfaceKHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceXcbPresentationSupportKHR", name)) {
+    if (nameHash == 0x01628e687379a800) {
         *addr = loader_inst->wsi_xcb_surface_enabled ? (void *)vkGetPhysicalDeviceXcbPresentationSupportKHR : NULL;
         return true;
     }
@@ -2790,11 +2792,11 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
 #if defined(VK_USE_PLATFORM_XLIB_KHR)
 
     // Functions for the VK_KHR_xlib_surface extension:
-    if (!strcmp("vkCreateXlibSurfaceKHR", name)) {
+    if (nameHash == 0xf2f37645ab938329) {
         *addr = loader_inst->wsi_xlib_surface_enabled ? (void *)vkCreateXlibSurfaceKHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceXlibPresentationSupportKHR", name)) {
+    if (nameHash == 0x45ce665f079d08ec) {
         *addr = loader_inst->wsi_xlib_surface_enabled ? (void *)vkGetPhysicalDeviceXlibPresentationSupportKHR : NULL;
         return true;
     }
@@ -2802,11 +2804,11 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
 #if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
 
     // Functions for the VK_EXT_directfb_surface extension:
-    if (!strcmp("vkCreateDirectFBSurfaceEXT", name)) {
+    if (nameHash == 0x0a7cb804a19f8d38) {
         *addr = loader_inst->wsi_directfb_surface_enabled ? (void *)vkCreateDirectFBSurfaceEXT : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceDirectFBPresentationSupportEXT", name)) {
+    if (nameHash == 0xe0e022af99face3d) {
         *addr = loader_inst->wsi_directfb_surface_enabled ? (void *)vkGetPhysicalDeviceDirectFBPresentationSupportEXT : NULL;
         return true;
     }
@@ -2814,7 +2816,7 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
 #if defined(VK_USE_PLATFORM_ANDROID_KHR)
 
     // Functions for the VK_KHR_android_surface extension:
-    if (!strcmp("vkCreateAndroidSurfaceKHR", name)) {
+    if (nameHash == 0xff2edfe5fb33ed95) {
         *addr = loader_inst->wsi_android_surface_enabled ? (void *)vkCreateAndroidSurfaceKHR : NULL;
         return true;
     }
@@ -2823,7 +2825,7 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
 #if defined(VK_USE_PLATFORM_MACOS_MVK)
 
     // Functions for the VK_MVK_macos_surface extension:
-    if (!strcmp("vkCreateMacOSSurfaceMVK", name)) {
+    if (nameHash == 0x93c0d2b7c2a1fcdc) {
         *addr = loader_inst->wsi_macos_surface_enabled ? (void *)vkCreateMacOSSurfaceMVK : NULL;
         return true;
     }
@@ -2831,7 +2833,7 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
 #if defined(VK_USE_PLATFORM_IOS_MVK)
 
     // Functions for the VK_MVK_ios_surface extension:
-    if (!strcmp("vkCreateIOSSurfaceMVK", name)) {
+    if (nameHash == 0x952f84e4519a6819) {
         *addr = loader_inst->wsi_ios_surface_enabled ? (void *)vkCreateIOSSurfaceMVK : NULL;
         return true;
     }
@@ -2839,7 +2841,7 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
 #if defined(VK_USE_PLATFORM_GGP)
 
     // Functions for the VK_GGP_stream_descriptor_surface extension:
-    if (!strcmp("vkCreateStreamDescriptorSurfaceGGP", name)) {
+    if (nameHash == 0x43d06e39e3edac61) {
         *addr = loader_inst->wsi_ggp_surface_enabled ? (void *)vkCreateStreamDescriptorSurfaceGGP : NULL;
         return true;
     }
@@ -2847,7 +2849,7 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
 #if defined(VK_USE_PLATFORM_FUCHSIA)
 
     // Functions for the VK_FUCHSIA_imagepipe_surface extension:
-    if (!strcmp("vkCreateImagePipeSurfaceFUCHSIA", name)) {
+    if (nameHash == 0xce552719aadd91f1) {
         *addr = loader_inst->wsi_imagepipe_surface_enabled ? (void *)vkCreateImagePipeSurfaceFUCHSIA : NULL;
         return true;
     }
@@ -2855,14 +2857,14 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
 #endif  // VK_USE_PLATFORM_FUCHSIA
 
     // Functions for the VK_EXT_headless_surface extension:
-    if (!strcmp("vkCreateHeadlessSurfaceEXT", name)) {
+    if (nameHash == 0x32e1633a3f5c604b) {
         *addr = loader_inst->wsi_headless_surface_enabled ? (void *)vkCreateHeadlessSurfaceEXT : NULL;
         return true;
     }
 
 #if defined(VK_USE_PLATFORM_METAL_EXT)
     // Functions for the VK_MVK_macos_surface extension:
-    if (!strcmp("vkCreateMetalSurfaceEXT", name)) {
+    if (nameHash == 0xc8c1cf60816e6d0b) {
         *addr = loader_inst->wsi_metal_surface_enabled ? (void *)vkCreateMetalSurfaceEXT : NULL;
         return true;
     }
@@ -2871,11 +2873,11 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
 #if defined(VK_USE_PLATFORM_SCREEN_QNX)
 
     // Functions for the VK_QNX_screen_surface extension:
-    if (!strcmp("vkCreateScreenSurfaceQNX", name)) {
+    if (nameHash == 0x4b8ff5f08d987c5a) {
         *addr = loader_inst->wsi_screen_surface_enabled ? (void *)vkCreateScreenSurfaceQNX : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceScreenPresentationSupportQNX", name)) {
+    if (nameHash == 0xf3c741c713ed78b6) {
         *addr = loader_inst->wsi_screen_surface_enabled ? (void *)vkGetPhysicalDeviceScreenPresentationSupportQNX : NULL;
         return true;
     }
@@ -2884,62 +2886,62 @@ bool wsi_swapchain_instance_gpa(struct loader_instance *loader_inst, const char
 #if defined(VK_USE_PLATFORM_VI_NN)
 
     // Functions for the VK_NN_vi_surface extension:
-    if (!strcmp("vkCreateViSurfaceNN", name)) {
+    if (nameHash == 0xe6edbd25c980bbfb) {
         *addr = loader_inst->wsi_vi_surface_enabled ? (void *)vkCreateViSurfaceNN : NULL;
         return true;
     }
 #endif  // VK_USE_PLATFORM_VI_NN
 
     // Functions for VK_KHR_display extension:
-    if (!strcmp("vkGetPhysicalDeviceDisplayPropertiesKHR", name)) {
+    if (nameHash == 0x69ef92b3a62ea127) {
         *addr = loader_inst->wsi_display_enabled ? (void *)vkGetPhysicalDeviceDisplayPropertiesKHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceDisplayPlanePropertiesKHR", name)) {
+    if (nameHash == 0x825cde4b6e7e00ea) {
         *addr = loader_inst->wsi_display_enabled ? (void *)vkGetPhysicalDeviceDisplayPlanePropertiesKHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetDisplayPlaneSupportedDisplaysKHR", name)) {
+    if (nameHash == 0x43524692a7f3408b) {
         *addr = loader_inst->wsi_display_enabled ? (void *)vkGetDisplayPlaneSupportedDisplaysKHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetDisplayModePropertiesKHR", name)) {
+    if (nameHash == 0x0f4117dbba29bc3a) {
         *addr = loader_inst->wsi_display_enabled ? (void *)vkGetDisplayModePropertiesKHR : NULL;
         return true;
     }
-    if (!strcmp("vkCreateDisplayModeKHR", name)) {
+    if (nameHash == 0xade0cf089ad306ef) {
         *addr = loader_inst->wsi_display_enabled ? (void *)vkCreateDisplayModeKHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetDisplayPlaneCapabilitiesKHR", name)) {
+    if (nameHash == 0x0e00b79e53c7512d) {
         *addr = loader_inst->wsi_display_enabled ? (void *)vkGetDisplayPlaneCapabilitiesKHR : NULL;
         return true;
     }
-    if (!strcmp("vkCreateDisplayPlaneSurfaceKHR", name)) {
+    if (nameHash == 0xe8d5da825e49ede6) {
         *addr = loader_inst->wsi_display_enabled ? (void *)vkCreateDisplayPlaneSurfaceKHR : NULL;
         return true;
     }
 
     // Functions for KHR_display_swapchain extension:
-    if (!strcmp("vkCreateSharedSwapchainsKHR", name)) {
+    if (nameHash == 0x73239ae79c84cd85) {
         *addr = (void *)vkCreateSharedSwapchainsKHR;
         return true;
     }
 
     // Functions for KHR_get_display_properties2
-    if (!strcmp("vkGetPhysicalDeviceDisplayProperties2KHR", name)) {
+    if (nameHash == 0xdec11a6b6abbaa1b) {
         *addr = loader_inst->wsi_display_props2_enabled ? (void *)vkGetPhysicalDeviceDisplayProperties2KHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetPhysicalDeviceDisplayPlaneProperties2KHR", name)) {
+    if (nameHash == 0x1a2ceebf7665e634) {
         *addr = loader_inst->wsi_display_props2_enabled ? (void *)vkGetPhysicalDeviceDisplayPlaneProperties2KHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetDisplayModeProperties2KHR", name)) {
+    if (nameHash == 0x49b103cf69b48bba) {
         *addr = loader_inst->wsi_display_props2_enabled ? (void *)vkGetDisplayModeProperties2KHR : NULL;
         return true;
     }
-    if (!strcmp("vkGetDisplayPlaneCapabilities2KHR", name)) {
+    if (nameHash == 0x5ec24bf8bf79e8fd) {
         *addr = loader_inst->wsi_display_props2_enabled ? (void *)vkGetDisplayPlaneCapabilities2KHR : NULL;
         return true;
     }
diff --git a/loader/wsi.h b/loader/wsi.h
index c2ec9af6a..f8ae12cfc 100644
--- a/loader/wsi.h
+++ b/loader/wsi.h
@@ -28,7 +28,7 @@ typedef struct {
     uint32_t surface_index;  // This surface's index into each drivers list of created surfaces
 } VkIcdSurface;
 
-bool wsi_swapchain_instance_gpa(struct loader_instance *ptr_instance, const char *name, void **addr);
+bool wsi_swapchain_instance_gpa(struct loader_instance *ptr_instance, const char *name, uint64_t nameHash, void **addr);
 
 void wsi_create_instance(struct loader_instance *ptr_instance, const VkInstanceCreateInfo *pCreateInfo);
 bool wsi_unsupported_instance_extension(const VkExtensionProperties *ext_prop);
diff --git a/loader/xxhash.h b/loader/xxhash.h
new file mode 100644
index 000000000..8bcc51d63
--- /dev/null
+++ b/loader/xxhash.h
@@ -0,0 +1,7246 @@
+/*
+ * xxHash - Extremely Fast Hash algorithm
+ * Header File
+ * Copyright (C) 2012-2023 Yann Collet
+ *
+ * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following disclaimer
+ *      in the documentation and/or other materials provided with the
+ *      distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You can contact the author at:
+ *   - xxHash homepage: https://www.xxhash.com
+ *   - xxHash source repository: https://github.com/Cyan4973/xxHash
+ */
+
+/*!
+ * @mainpage xxHash
+ *
+ * xxHash is an extremely fast non-cryptographic hash algorithm, working at RAM speed
+ * limits.
+ *
+ * It is proposed in four flavors, in three families:
+ * 1. @ref XXH32_family
+ *   - Classic 32-bit hash function. Simple, compact, and runs on almost all
+ *     32-bit and 64-bit systems.
+ * 2. @ref XXH64_family
+ *   - Classic 64-bit adaptation of XXH32. Just as simple, and runs well on most
+ *     64-bit systems (but _not_ 32-bit systems).
+ * 3. @ref XXH3_family
+ *   - Modern 64-bit and 128-bit hash function family which features improved
+ *     strength and performance across the board, especially on smaller data.
+ *     It benefits greatly from SIMD and 64-bit without requiring it.
+ *
+ * Benchmarks
+ * ---
+ * The reference system uses an Intel i7-9700K CPU, and runs Ubuntu x64 20.04.
+ * The open source benchmark program is compiled with clang v10.0 using -O3 flag.
+ *
+ * | Hash Name            | ISA ext | Width | Large Data Speed | Small Data Velocity |
+ * | -------------------- | ------- | ----: | ---------------: | ------------------: |
+ * | XXH3_64bits()        | @b AVX2 |    64 |        59.4 GB/s |               133.1 |
+ * | MeowHash             | AES-NI  |   128 |        58.2 GB/s |                52.5 |
+ * | XXH3_128bits()       | @b AVX2 |   128 |        57.9 GB/s |               118.1 |
+ * | CLHash               | PCLMUL  |    64 |        37.1 GB/s |                58.1 |
+ * | XXH3_64bits()        | @b SSE2 |    64 |        31.5 GB/s |               133.1 |
+ * | XXH3_128bits()       | @b SSE2 |   128 |        29.6 GB/s |               118.1 |
+ * | RAM sequential read  |         |   N/A |        28.0 GB/s |                 N/A |
+ * | ahash                | AES-NI  |    64 |        22.5 GB/s |               107.2 |
+ * | City64               |         |    64 |        22.0 GB/s |                76.6 |
+ * | T1ha2                |         |    64 |        22.0 GB/s |                99.0 |
+ * | City128              |         |   128 |        21.7 GB/s |                57.7 |
+ * | FarmHash             | AES-NI  |    64 |        21.3 GB/s |                71.9 |
+ * | XXH64()              |         |    64 |        19.4 GB/s |                71.0 |
+ * | SpookyHash           |         |    64 |        19.3 GB/s |                53.2 |
+ * | Mum                  |         |    64 |        18.0 GB/s |                67.0 |
+ * | CRC32C               | SSE4.2  |    32 |        13.0 GB/s |                57.9 |
+ * | XXH32()              |         |    32 |         9.7 GB/s |                71.9 |
+ * | City32               |         |    32 |         9.1 GB/s |                66.0 |
+ * | Blake3*              | @b AVX2 |   256 |         4.4 GB/s |                 8.1 |
+ * | Murmur3              |         |    32 |         3.9 GB/s |                56.1 |
+ * | SipHash*             |         |    64 |         3.0 GB/s |                43.2 |
+ * | Blake3*              | @b SSE2 |   256 |         2.4 GB/s |                 8.1 |
+ * | HighwayHash          |         |    64 |         1.4 GB/s |                 6.0 |
+ * | FNV64                |         |    64 |         1.2 GB/s |                62.7 |
+ * | Blake2*              |         |   256 |         1.1 GB/s |                 5.1 |
+ * | SHA1*                |         |   160 |         0.8 GB/s |                 5.6 |
+ * | MD5*                 |         |   128 |         0.6 GB/s |                 7.8 |
+ * @note
+ *   - Hashes which require a specific ISA extension are noted. SSE2 is also noted,
+ *     even though it is mandatory on x64.
+ *   - Hashes with an asterisk are cryptographic. Note that MD5 is non-cryptographic
+ *     by modern standards.
+ *   - Small data velocity is a rough average of algorithm's efficiency for small
+ *     data. For more accurate information, see the wiki.
+ *   - More benchmarks and strength tests are found on the wiki:
+ *         https://github.com/Cyan4973/xxHash/wiki
+ *
+ * Usage
+ * ------
+ * All xxHash variants use a similar API. Changing the algorithm is a trivial
+ * substitution.
+ *
+ * @pre
+ *    For functions which take an input and length parameter, the following
+ *    requirements are assumed:
+ *    - The range from [`input`, `input + length`) is valid, readable memory.
+ *      - The only exception is if the `length` is `0`, `input` may be `NULL`.
+ *    - For C++, the objects must have the *TriviallyCopyable* property, as the
+ *      functions access bytes directly as if it was an array of `unsigned char`.
+ *
+ * @anchor single_shot_example
+ * **Single Shot**
+ *
+ * These functions are stateless functions which hash a contiguous block of memory,
+ * immediately returning the result. They are the easiest and usually the fastest
+ * option.
+ *
+ * XXH32(), XXH64(), XXH3_64bits(), XXH3_128bits()
+ *
+ * @code{.c}
+ *   #include <string.h>
+ *   #include "xxhash.h"
+ *
+ *   // Example for a function which hashes a null terminated string with XXH32().
+ *   XXH32_hash_t hash_string(const char* string, XXH32_hash_t seed)
+ *   {
+ *       // NULL pointers are only valid if the length is zero
+ *       size_t length = (string == NULL) ? 0 : strlen(string);
+ *       return XXH32(string, length, seed);
+ *   }
+ * @endcode
+ *
+ *
+ * @anchor streaming_example
+ * **Streaming**
+ *
+ * These groups of functions allow incremental hashing of unknown size, even
+ * more than what would fit in a size_t.
+ *
+ * XXH32_reset(), XXH64_reset(), XXH3_64bits_reset(), XXH3_128bits_reset()
+ *
+ * @code{.c}
+ *   #include <stdio.h>
+ *   #include <assert.h>
+ *   #include "xxhash.h"
+ *   // Example for a function which hashes a FILE incrementally with XXH3_64bits().
+ *   XXH64_hash_t hashFile(FILE* f)
+ *   {
+ *       // Allocate a state struct. Do not just use malloc() or new.
+ *       XXH3_state_t* state = XXH3_createState();
+ *       assert(state != NULL && "Out of memory!");
+ *       // Reset the state to start a new hashing session.
+ *       XXH3_64bits_reset(state);
+ *       char buffer[4096];
+ *       size_t count;
+ *       // Read the file in chunks
+ *       while ((count = fread(buffer, 1, sizeof(buffer), f)) != 0) {
+ *           // Run update() as many times as necessary to process the data
+ *           XXH3_64bits_update(state, buffer, count);
+ *       }
+ *       // Retrieve the finalized hash. This will not change the state.
+ *       XXH64_hash_t result = XXH3_64bits_digest(state);
+ *       // Free the state. Do not use free().
+ *       XXH3_freeState(state);
+ *       return result;
+ *   }
+ * @endcode
+ *
+ * Streaming functions generate the xxHash value from an incremental input.
+ * This method is slower than single-call functions, due to state management.
+ * For small inputs, prefer `XXH32()` and `XXH64()`, which are better optimized.
+ *
+ * An XXH state must first be allocated using `XXH*_createState()`.
+ *
+ * Start a new hash by initializing the state with a seed using `XXH*_reset()`.
+ *
+ * Then, feed the hash state by calling `XXH*_update()` as many times as necessary.
+ *
+ * The function returns an error code, with 0 meaning OK, and any other value
+ * meaning there is an error.
+ *
+ * Finally, a hash value can be produced anytime, by using `XXH*_digest()`.
+ * This function returns the nn-bits hash as an int or long long.
+ *
+ * It's still possible to continue inserting input into the hash state after a
+ * digest, and generate new hash values later on by invoking `XXH*_digest()`.
+ *
+ * When done, release the state using `XXH*_freeState()`.
+ *
+ *
+ * @anchor canonical_representation_example
+ * **Canonical Representation**
+ *
+ * The default return values from XXH functions are unsigned 32, 64 and 128 bit
+ * integers.
+ * This the simplest and fastest format for further post-processing.
+ *
+ * However, this leaves open the question of what is the order on the byte level,
+ * since little and big endian conventions will store the same number differently.
+ *
+ * The canonical representation settles this issue by mandating big-endian
+ * convention, the same convention as human-readable numbers (large digits first).
+ *
+ * When writing hash values to storage, sending them over a network, or printing
+ * them, it's highly recommended to use the canonical representation to ensure
+ * portability across a wider range of systems, present and future.
+ *
+ * The following functions allow transformation of hash values to and from
+ * canonical format.
+ *
+ * XXH32_canonicalFromHash(), XXH32_hashFromCanonical(),
+ * XXH64_canonicalFromHash(), XXH64_hashFromCanonical(),
+ * XXH128_canonicalFromHash(), XXH128_hashFromCanonical(),
+ *
+ * @code{.c}
+ *   #include <stdio.h>
+ *   #include "xxhash.h"
+ *
+ *   // Example for a function which prints XXH32_hash_t in human readable format
+ *   void printXxh32(XXH32_hash_t hash)
+ *   {
+ *       XXH32_canonical_t cano;
+ *       XXH32_canonicalFromHash(&cano, hash);
+ *       size_t i;
+ *       for(i = 0; i < sizeof(cano.digest); ++i) {
+ *           printf("%02x", cano.digest[i]);
+ *       }
+ *       printf("\n");
+ *   }
+ *
+ *   // Example for a function which converts XXH32_canonical_t to XXH32_hash_t
+ *   XXH32_hash_t convertCanonicalToXxh32(XXH32_canonical_t cano)
+ *   {
+ *       XXH32_hash_t hash = XXH32_hashFromCanonical(&cano);
+ *       return hash;
+ *   }
+ * @endcode
+ *
+ *
+ * @file xxhash.h
+ * xxHash prototypes and implementation
+ */
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+/* ****************************
+ *  INLINE mode
+ ******************************/
+/*!
+ * @defgroup public Public API
+ * Contains details on the public xxHash functions.
+ * @{
+ */
+#ifdef XXH_DOXYGEN
+/*!
+ * @brief Gives access to internal state declaration, required for static allocation.
+ *
+ * Incompatible with dynamic linking, due to risks of ABI changes.
+ *
+ * Usage:
+ * @code{.c}
+ *     #define XXH_STATIC_LINKING_ONLY
+ *     #include "xxhash.h"
+ * @endcode
+ */
+#  define XXH_STATIC_LINKING_ONLY
+/* Do not undef XXH_STATIC_LINKING_ONLY for Doxygen */
+
+/*!
+ * @brief Gives access to internal definitions.
+ *
+ * Usage:
+ * @code{.c}
+ *     #define XXH_STATIC_LINKING_ONLY
+ *     #define XXH_IMPLEMENTATION
+ *     #include "xxhash.h"
+ * @endcode
+ */
+#  define XXH_IMPLEMENTATION
+/* Do not undef XXH_IMPLEMENTATION for Doxygen */
+
+/*!
+ * @brief Exposes the implementation and marks all functions as `inline`.
+ *
+ * Use these build macros to inline xxhash into the target unit.
+ * Inlining improves performance on small inputs, especially when the length is
+ * expressed as a compile-time constant:
+ *
+ *  https://fastcompression.blogspot.com/2018/03/xxhash-for-small-keys-impressive-power.html
+ *
+ * It also keeps xxHash symbols private to the unit, so they are not exported.
+ *
+ * Usage:
+ * @code{.c}
+ *     #define XXH_INLINE_ALL
+ *     #include "xxhash.h"
+ * @endcode
+ * Do not compile and link xxhash.o as a separate object, as it is not useful.
+ */
+#  define XXH_INLINE_ALL
+#  undef XXH_INLINE_ALL
+/*!
+ * @brief Exposes the implementation without marking functions as inline.
+ */
+#  define XXH_PRIVATE_API
+#  undef XXH_PRIVATE_API
+/*!
+ * @brief Emulate a namespace by transparently prefixing all symbols.
+ *
+ * If you want to include _and expose_ xxHash functions from within your own
+ * library, but also want to avoid symbol collisions with other libraries which
+ * may also include xxHash, you can use @ref XXH_NAMESPACE to automatically prefix
+ * any public symbol from xxhash library with the value of @ref XXH_NAMESPACE
+ * (therefore, avoid empty or numeric values).
+ *
+ * Note that no change is required within the calling program as long as it
+ * includes `xxhash.h`: Regular symbol names will be automatically translated
+ * by this header.
+ */
+#  define XXH_NAMESPACE /* YOUR NAME HERE */
+#  undef XXH_NAMESPACE
+#endif
+
+#if (defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)) \
+    && !defined(XXH_INLINE_ALL_31684351384)
+   /* this section should be traversed only once */
+#  define XXH_INLINE_ALL_31684351384
+   /* give access to the advanced API, required to compile implementations */
+#  undef XXH_STATIC_LINKING_ONLY   /* avoid macro redef */
+#  define XXH_STATIC_LINKING_ONLY
+   /* make all functions private */
+#  undef XXH_PUBLIC_API
+#  if defined(__GNUC__)
+#    define XXH_PUBLIC_API static __inline __attribute__((__unused__))
+#  elif defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)
+#    define XXH_PUBLIC_API static inline
+#  elif defined(_MSC_VER)
+#    define XXH_PUBLIC_API static __inline
+#  else
+     /* note: this version may generate warnings for unused static functions */
+#    define XXH_PUBLIC_API static
+#  endif
+
+   /*
+    * This part deals with the special case where a unit wants to inline xxHash,
+    * but "xxhash.h" has previously been included without XXH_INLINE_ALL,
+    * such as part of some previously included *.h header file.
+    * Without further action, the new include would just be ignored,
+    * and functions would effectively _not_ be inlined (silent failure).
+    * The following macros solve this situation by prefixing all inlined names,
+    * avoiding naming collision with previous inclusions.
+    */
+   /* Before that, we unconditionally #undef all symbols,
+    * in case they were already defined with XXH_NAMESPACE.
+    * They will then be redefined for XXH_INLINE_ALL
+    */
+#  undef XXH_versionNumber
+    /* XXH32 */
+#  undef XXH32
+#  undef XXH32_createState
+#  undef XXH32_freeState
+#  undef XXH32_reset
+#  undef XXH32_update
+#  undef XXH32_digest
+#  undef XXH32_copyState
+#  undef XXH32_canonicalFromHash
+#  undef XXH32_hashFromCanonical
+    /* XXH64 */
+#  undef XXH64
+#  undef XXH64_createState
+#  undef XXH64_freeState
+#  undef XXH64_reset
+#  undef XXH64_update
+#  undef XXH64_digest
+#  undef XXH64_copyState
+#  undef XXH64_canonicalFromHash
+#  undef XXH64_hashFromCanonical
+    /* XXH3_64bits */
+#  undef XXH3_64bits
+#  undef XXH3_64bits_withSecret
+#  undef XXH3_64bits_withSeed
+#  undef XXH3_64bits_withSecretandSeed
+#  undef XXH3_createState
+#  undef XXH3_freeState
+#  undef XXH3_copyState
+#  undef XXH3_64bits_reset
+#  undef XXH3_64bits_reset_withSeed
+#  undef XXH3_64bits_reset_withSecret
+#  undef XXH3_64bits_update
+#  undef XXH3_64bits_digest
+#  undef XXH3_generateSecret
+    /* XXH3_128bits */
+#  undef XXH128
+#  undef XXH3_128bits
+#  undef XXH3_128bits_withSeed
+#  undef XXH3_128bits_withSecret
+#  undef XXH3_128bits_reset
+#  undef XXH3_128bits_reset_withSeed
+#  undef XXH3_128bits_reset_withSecret
+#  undef XXH3_128bits_reset_withSecretandSeed
+#  undef XXH3_128bits_update
+#  undef XXH3_128bits_digest
+#  undef XXH128_isEqual
+#  undef XXH128_cmp
+#  undef XXH128_canonicalFromHash
+#  undef XXH128_hashFromCanonical
+    /* Finally, free the namespace itself */
+#  undef XXH_NAMESPACE
+
+    /* employ the namespace for XXH_INLINE_ALL */
+#  define XXH_NAMESPACE XXH_INLINE_
+   /*
+    * Some identifiers (enums, type names) are not symbols,
+    * but they must nonetheless be renamed to avoid redeclaration.
+    * Alternative solution: do not redeclare them.
+    * However, this requires some #ifdefs, and has a more dispersed impact.
+    * Meanwhile, renaming can be achieved in a single place.
+    */
+#  define XXH_IPREF(Id)   XXH_NAMESPACE ## Id
+#  define XXH_OK XXH_IPREF(XXH_OK)
+#  define XXH_ERROR XXH_IPREF(XXH_ERROR)
+#  define XXH_errorcode XXH_IPREF(XXH_errorcode)
+#  define XXH32_canonical_t  XXH_IPREF(XXH32_canonical_t)
+#  define XXH64_canonical_t  XXH_IPREF(XXH64_canonical_t)
+#  define XXH128_canonical_t XXH_IPREF(XXH128_canonical_t)
+#  define XXH32_state_s XXH_IPREF(XXH32_state_s)
+#  define XXH32_state_t XXH_IPREF(XXH32_state_t)
+#  define XXH64_state_s XXH_IPREF(XXH64_state_s)
+#  define XXH64_state_t XXH_IPREF(XXH64_state_t)
+#  define XXH3_state_s  XXH_IPREF(XXH3_state_s)
+#  define XXH3_state_t  XXH_IPREF(XXH3_state_t)
+#  define XXH128_hash_t XXH_IPREF(XXH128_hash_t)
+   /* Ensure the header is parsed again, even if it was previously included */
+#  undef XXHASH_H_5627135585666179
+#  undef XXHASH_H_STATIC_13879238742
+#endif /* XXH_INLINE_ALL || XXH_PRIVATE_API */
+
+/* ****************************************************************
+ *  Stable API
+ *****************************************************************/
+#ifndef XXHASH_H_5627135585666179
+#define XXHASH_H_5627135585666179 1
+
+/*! @brief Marks a global symbol. */
+#if !defined(XXH_INLINE_ALL) && !defined(XXH_PRIVATE_API)
+#  if defined(_WIN32) && defined(_MSC_VER) && (defined(XXH_IMPORT) || defined(XXH_EXPORT))
+#    ifdef XXH_EXPORT
+#      define XXH_PUBLIC_API __declspec(dllexport)
+#    elif XXH_IMPORT
+#      define XXH_PUBLIC_API __declspec(dllimport)
+#    endif
+#  else
+#    define XXH_PUBLIC_API   /* do nothing */
+#  endif
+#endif
+
+#ifdef XXH_NAMESPACE
+#  define XXH_CAT(A,B) A##B
+#  define XXH_NAME2(A,B) XXH_CAT(A,B)
+#  define XXH_versionNumber XXH_NAME2(XXH_NAMESPACE, XXH_versionNumber)
+/* XXH32 */
+#  define XXH32 XXH_NAME2(XXH_NAMESPACE, XXH32)
+#  define XXH32_createState XXH_NAME2(XXH_NAMESPACE, XXH32_createState)
+#  define XXH32_freeState XXH_NAME2(XXH_NAMESPACE, XXH32_freeState)
+#  define XXH32_reset XXH_NAME2(XXH_NAMESPACE, XXH32_reset)
+#  define XXH32_update XXH_NAME2(XXH_NAMESPACE, XXH32_update)
+#  define XXH32_digest XXH_NAME2(XXH_NAMESPACE, XXH32_digest)
+#  define XXH32_copyState XXH_NAME2(XXH_NAMESPACE, XXH32_copyState)
+#  define XXH32_canonicalFromHash XXH_NAME2(XXH_NAMESPACE, XXH32_canonicalFromHash)
+#  define XXH32_hashFromCanonical XXH_NAME2(XXH_NAMESPACE, XXH32_hashFromCanonical)
+/* XXH64 */
+#  define XXH64 XXH_NAME2(XXH_NAMESPACE, XXH64)
+#  define XXH64_createState XXH_NAME2(XXH_NAMESPACE, XXH64_createState)
+#  define XXH64_freeState XXH_NAME2(XXH_NAMESPACE, XXH64_freeState)
+#  define XXH64_reset XXH_NAME2(XXH_NAMESPACE, XXH64_reset)
+#  define XXH64_update XXH_NAME2(XXH_NAMESPACE, XXH64_update)
+#  define XXH64_digest XXH_NAME2(XXH_NAMESPACE, XXH64_digest)
+#  define XXH64_copyState XXH_NAME2(XXH_NAMESPACE, XXH64_copyState)
+#  define XXH64_canonicalFromHash XXH_NAME2(XXH_NAMESPACE, XXH64_canonicalFromHash)
+#  define XXH64_hashFromCanonical XXH_NAME2(XXH_NAMESPACE, XXH64_hashFromCanonical)
+/* XXH3_64bits */
+#  define XXH3_64bits XXH_NAME2(XXH_NAMESPACE, XXH3_64bits)
+#  define XXH3_64bits_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSecret)
+#  define XXH3_64bits_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSeed)
+#  define XXH3_64bits_withSecretandSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSecretandSeed)
+#  define XXH3_createState XXH_NAME2(XXH_NAMESPACE, XXH3_createState)
+#  define XXH3_freeState XXH_NAME2(XXH_NAMESPACE, XXH3_freeState)
+#  define XXH3_copyState XXH_NAME2(XXH_NAMESPACE, XXH3_copyState)
+#  define XXH3_64bits_reset XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset)
+#  define XXH3_64bits_reset_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSeed)
+#  define XXH3_64bits_reset_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSecret)
+#  define XXH3_64bits_reset_withSecretandSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSecretandSeed)
+#  define XXH3_64bits_update XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_update)
+#  define XXH3_64bits_digest XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_digest)
+#  define XXH3_generateSecret XXH_NAME2(XXH_NAMESPACE, XXH3_generateSecret)
+#  define XXH3_generateSecret_fromSeed XXH_NAME2(XXH_NAMESPACE, XXH3_generateSecret_fromSeed)
+/* XXH3_128bits */
+#  define XXH128 XXH_NAME2(XXH_NAMESPACE, XXH128)
+#  define XXH3_128bits XXH_NAME2(XXH_NAMESPACE, XXH3_128bits)
+#  define XXH3_128bits_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSeed)
+#  define XXH3_128bits_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSecret)
+#  define XXH3_128bits_withSecretandSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSecretandSeed)
+#  define XXH3_128bits_reset XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset)
+#  define XXH3_128bits_reset_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSeed)
+#  define XXH3_128bits_reset_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSecret)
+#  define XXH3_128bits_reset_withSecretandSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSecretandSeed)
+#  define XXH3_128bits_update XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_update)
+#  define XXH3_128bits_digest XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_digest)
+#  define XXH128_isEqual XXH_NAME2(XXH_NAMESPACE, XXH128_isEqual)
+#  define XXH128_cmp     XXH_NAME2(XXH_NAMESPACE, XXH128_cmp)
+#  define XXH128_canonicalFromHash XXH_NAME2(XXH_NAMESPACE, XXH128_canonicalFromHash)
+#  define XXH128_hashFromCanonical XXH_NAME2(XXH_NAMESPACE, XXH128_hashFromCanonical)
+#endif
+
+
+/* *************************************
+*  Compiler specifics
+***************************************/
+
+/* specific declaration modes for Windows */
+#if !defined(XXH_INLINE_ALL) && !defined(XXH_PRIVATE_API)
+#  if defined(_WIN32) && defined(_MSC_VER) && (defined(XXH_IMPORT) || defined(XXH_EXPORT))
+#    ifdef XXH_EXPORT
+#      define XXH_PUBLIC_API __declspec(dllexport)
+#    elif XXH_IMPORT
+#      define XXH_PUBLIC_API __declspec(dllimport)
+#    endif
+#  else
+#    define XXH_PUBLIC_API   /* do nothing */
+#  endif
+#endif
+
+#if defined (__GNUC__)
+# define XXH_CONSTF  __attribute__((__const__))
+# define XXH_PUREF   __attribute__((__pure__))
+# define XXH_MALLOCF __attribute__((__malloc__))
+#else
+# define XXH_CONSTF  /* disable */
+# define XXH_PUREF
+# define XXH_MALLOCF
+#endif
+
+/* *************************************
+*  Version
+***************************************/
+#define XXH_VERSION_MAJOR    0
+#define XXH_VERSION_MINOR    8
+#define XXH_VERSION_RELEASE  3
+/*! @brief Version number, encoded as two digits each */
+#define XXH_VERSION_NUMBER  (XXH_VERSION_MAJOR *100*100 + XXH_VERSION_MINOR *100 + XXH_VERSION_RELEASE)
+
+/*!
+ * @brief Obtains the xxHash version.
+ *
+ * This is mostly useful when xxHash is compiled as a shared library,
+ * since the returned value comes from the library, as opposed to header file.
+ *
+ * @return @ref XXH_VERSION_NUMBER of the invoked library.
+ */
+XXH_PUBLIC_API XXH_CONSTF unsigned XXH_versionNumber (void);
+
+
+/* ****************************
+*  Common basic types
+******************************/
+#include <stddef.h>   /* size_t */
+/*!
+ * @brief Exit code for the streaming API.
+ */
+typedef enum {
+    XXH_OK = 0, /*!< OK */
+    XXH_ERROR   /*!< Error */
+} XXH_errorcode;
+
+
+/*-**********************************************************************
+*  32-bit hash
+************************************************************************/
+#if defined(XXH_DOXYGEN) /* Don't show <stdint.h> include */
+/*!
+ * @brief An unsigned 32-bit integer.
+ *
+ * Not necessarily defined to `uint32_t` but functionally equivalent.
+ */
+typedef uint32_t XXH32_hash_t;
+
+#elif !defined (__VMS) \
+  && (defined (__cplusplus) \
+  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+#   ifdef _AIX
+#     include <inttypes.h>
+#   else
+#     include <stdint.h>
+#   endif
+    typedef uint32_t XXH32_hash_t;
+
+#else
+#   include <limits.h>
+#   if UINT_MAX == 0xFFFFFFFFUL
+      typedef unsigned int XXH32_hash_t;
+#   elif ULONG_MAX == 0xFFFFFFFFUL
+      typedef unsigned long XXH32_hash_t;
+#   else
+#     error "unsupported platform: need a 32-bit type"
+#   endif
+#endif
+
+/*!
+ * @}
+ *
+ * @defgroup XXH32_family XXH32 family
+ * @ingroup public
+ * Contains functions used in the classic 32-bit xxHash algorithm.
+ *
+ * @note
+ *   XXH32 is useful for older platforms, with no or poor 64-bit performance.
+ *   Note that the @ref XXH3_family provides competitive speed for both 32-bit
+ *   and 64-bit systems, and offers true 64/128 bit hash results.
+ *
+ * @see @ref XXH64_family, @ref XXH3_family : Other xxHash families
+ * @see @ref XXH32_impl for implementation details
+ * @{
+ */
+
+/*!
+ * @brief Calculates the 32-bit hash of @p input using xxHash32.
+ *
+ * @param input The block of data to be hashed, at least @p length bytes in size.
+ * @param length The length of @p input, in bytes.
+ * @param seed The 32-bit seed to alter the hash's output predictably.
+ *
+ * @pre
+ *   The memory between @p input and @p input + @p length must be valid,
+ *   readable, contiguous memory. However, if @p length is `0`, @p input may be
+ *   `NULL`. In C++, this also must be *TriviallyCopyable*.
+ *
+ * @return The calculated 32-bit xxHash32 value.
+ *
+ * @see @ref single_shot_example "Single Shot Example" for an example.
+ */
+XXH_PUBLIC_API XXH_PUREF XXH32_hash_t XXH32 (const void* input, size_t length, XXH32_hash_t seed);
+
+#ifndef XXH_NO_STREAM
+/*!
+ * @typedef struct XXH32_state_s XXH32_state_t
+ * @brief The opaque state struct for the XXH32 streaming API.
+ *
+ * @see XXH32_state_s for details.
+ * @see @ref streaming_example "Streaming Example"
+ */
+typedef struct XXH32_state_s XXH32_state_t;
+
+/*!
+ * @brief Allocates an @ref XXH32_state_t.
+ *
+ * @return An allocated pointer of @ref XXH32_state_t on success.
+ * @return `NULL` on failure.
+ *
+ * @note Must be freed with XXH32_freeState().
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_MALLOCF XXH32_state_t* XXH32_createState(void);
+/*!
+ * @brief Frees an @ref XXH32_state_t.
+ *
+ * @param statePtr A pointer to an @ref XXH32_state_t allocated with @ref XXH32_createState().
+ *
+ * @return @ref XXH_OK.
+ *
+ * @note @p statePtr must be allocated with XXH32_createState().
+ *
+ * @see @ref streaming_example "Streaming Example"
+ *
+ */
+XXH_PUBLIC_API XXH_errorcode  XXH32_freeState(XXH32_state_t* statePtr);
+/*!
+ * @brief Copies one @ref XXH32_state_t to another.
+ *
+ * @param dst_state The state to copy to.
+ * @param src_state The state to copy from.
+ * @pre
+ *   @p dst_state and @p src_state must not be `NULL` and must not overlap.
+ */
+XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dst_state, const XXH32_state_t* src_state);
+
+/*!
+ * @brief Resets an @ref XXH32_state_t to begin a new hash.
+ *
+ * @param statePtr The state struct to reset.
+ * @param seed The 32-bit seed to alter the hash result predictably.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @note This function resets and seeds a state. Call it before @ref XXH32_update().
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_errorcode XXH32_reset  (XXH32_state_t* statePtr, XXH32_hash_t seed);
+
+/*!
+ * @brief Consumes a block of @p input to an @ref XXH32_state_t.
+ *
+ * @param statePtr The state struct to update.
+ * @param input The block of data to be hashed, at least @p length bytes in size.
+ * @param length The length of @p input, in bytes.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ * @pre
+ *   The memory between @p input and @p input + @p length must be valid,
+ *   readable, contiguous memory. However, if @p length is `0`, @p input may be
+ *   `NULL`. In C++, this also must be *TriviallyCopyable*.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @note Call this to incrementally consume blocks of data.
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_errorcode XXH32_update (XXH32_state_t* statePtr, const void* input, size_t length);
+
+/*!
+ * @brief Returns the calculated hash value from an @ref XXH32_state_t.
+ *
+ * @param statePtr The state struct to calculate the hash from.
+ *
+ * @pre
+ *  @p statePtr must not be `NULL`.
+ *
+ * @return The calculated 32-bit xxHash32 value from that state.
+ *
+ * @note
+ *   Calling XXH32_digest() will not affect @p statePtr, so you can update,
+ *   digest, and update again.
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_PUREF XXH32_hash_t XXH32_digest (const XXH32_state_t* statePtr);
+#endif /* !XXH_NO_STREAM */
+
+/*******   Canonical representation   *******/
+
+/*!
+ * @brief Canonical (big endian) representation of @ref XXH32_hash_t.
+ */
+typedef struct {
+    unsigned char digest[4]; /*!< Hash bytes, big endian */
+} XXH32_canonical_t;
+
+/*!
+ * @brief Converts an @ref XXH32_hash_t to a big endian @ref XXH32_canonical_t.
+ *
+ * @param dst  The @ref XXH32_canonical_t pointer to be stored to.
+ * @param hash The @ref XXH32_hash_t to be converted.
+ *
+ * @pre
+ *   @p dst must not be `NULL`.
+ *
+ * @see @ref canonical_representation_example "Canonical Representation Example"
+ */
+XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash);
+
+/*!
+ * @brief Converts an @ref XXH32_canonical_t to a native @ref XXH32_hash_t.
+ *
+ * @param src The @ref XXH32_canonical_t to convert.
+ *
+ * @pre
+ *   @p src must not be `NULL`.
+ *
+ * @return The converted hash.
+ *
+ * @see @ref canonical_representation_example "Canonical Representation Example"
+ */
+XXH_PUBLIC_API XXH_PUREF XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src);
+
+
+/*! @cond Doxygen ignores this part */
+#ifdef __has_attribute
+# define XXH_HAS_ATTRIBUTE(x) __has_attribute(x)
+#else
+# define XXH_HAS_ATTRIBUTE(x) 0
+#endif
+/*! @endcond */
+
+/*! @cond Doxygen ignores this part */
+/*
+ * C23 __STDC_VERSION__ number hasn't been specified yet. For now
+ * leave as `201711L` (C17 + 1).
+ * TODO: Update to correct value when its been specified.
+ */
+#define XXH_C23_VN 201711L
+/*! @endcond */
+
+/*! @cond Doxygen ignores this part */
+/* C-language Attributes are added in C23. */
+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= XXH_C23_VN) && defined(__has_c_attribute)
+# define XXH_HAS_C_ATTRIBUTE(x) __has_c_attribute(x)
+#else
+# define XXH_HAS_C_ATTRIBUTE(x) 0
+#endif
+/*! @endcond */
+
+/*! @cond Doxygen ignores this part */
+#if defined(__cplusplus) && defined(__has_cpp_attribute)
+# define XXH_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
+#else
+# define XXH_HAS_CPP_ATTRIBUTE(x) 0
+#endif
+/*! @endcond */
+
+/*! @cond Doxygen ignores this part */
+/*
+ * Define XXH_FALLTHROUGH macro for annotating switch case with the 'fallthrough' attribute
+ * introduced in CPP17 and C23.
+ * CPP17 : https://en.cppreference.com/w/cpp/language/attributes/fallthrough
+ * C23   : https://en.cppreference.com/w/c/language/attributes/fallthrough
+ */
+#if XXH_HAS_C_ATTRIBUTE(fallthrough) || XXH_HAS_CPP_ATTRIBUTE(fallthrough)
+# define XXH_FALLTHROUGH [[fallthrough]]
+#elif XXH_HAS_ATTRIBUTE(__fallthrough__)
+# define XXH_FALLTHROUGH __attribute__ ((__fallthrough__))
+#else
+# define XXH_FALLTHROUGH /* fallthrough */
+#endif
+/*! @endcond */
+
+/*! @cond Doxygen ignores this part */
+/*
+ * Define XXH_NOESCAPE for annotated pointers in public API.
+ * https://clang.llvm.org/docs/AttributeReference.html#noescape
+ * As of writing this, only supported by clang.
+ */
+#if XXH_HAS_ATTRIBUTE(noescape)
+# define XXH_NOESCAPE __attribute__((__noescape__))
+#else
+# define XXH_NOESCAPE
+#endif
+/*! @endcond */
+
+
+/*!
+ * @}
+ * @ingroup public
+ * @{
+ */
+
+#ifndef XXH_NO_LONG_LONG
+/*-**********************************************************************
+*  64-bit hash
+************************************************************************/
+#if defined(XXH_DOXYGEN) /* don't include <stdint.h> */
+/*!
+ * @brief An unsigned 64-bit integer.
+ *
+ * Not necessarily defined to `uint64_t` but functionally equivalent.
+ */
+typedef uint64_t XXH64_hash_t;
+#elif !defined (__VMS) \
+  && (defined (__cplusplus) \
+  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+#   ifdef _AIX
+#     include <inttypes.h>
+#   else
+#     include <stdint.h>
+#   endif
+   typedef uint64_t XXH64_hash_t;
+#else
+#  include <limits.h>
+#  if defined(__LP64__) && ULONG_MAX == 0xFFFFFFFFFFFFFFFFULL
+     /* LP64 ABI says uint64_t is unsigned long */
+     typedef unsigned long XXH64_hash_t;
+#  else
+     /* the following type must have a width of 64-bit */
+     typedef unsigned long long XXH64_hash_t;
+#  endif
+#endif
+
+/*!
+ * @}
+ *
+ * @defgroup XXH64_family XXH64 family
+ * @ingroup public
+ * @{
+ * Contains functions used in the classic 64-bit xxHash algorithm.
+ *
+ * @note
+ *   XXH3 provides competitive speed for both 32-bit and 64-bit systems,
+ *   and offers true 64/128 bit hash results.
+ *   It provides better speed for systems with vector processing capabilities.
+ */
+
+/*!
+ * @brief Calculates the 64-bit hash of @p input using xxHash64.
+ *
+ * @param input The block of data to be hashed, at least @p length bytes in size.
+ * @param length The length of @p input, in bytes.
+ * @param seed The 64-bit seed to alter the hash's output predictably.
+ *
+ * @pre
+ *   The memory between @p input and @p input + @p length must be valid,
+ *   readable, contiguous memory. However, if @p length is `0`, @p input may be
+ *   `NULL`. In C++, this also must be *TriviallyCopyable*.
+ *
+ * @return The calculated 64-bit xxHash64 value.
+ *
+ * @see @ref single_shot_example "Single Shot Example" for an example.
+ */
+XXH_PUBLIC_API XXH_PUREF XXH64_hash_t XXH64(XXH_NOESCAPE const void* input, size_t length, XXH64_hash_t seed);
+
+/*******   Streaming   *******/
+#ifndef XXH_NO_STREAM
+/*!
+ * @brief The opaque state struct for the XXH64 streaming API.
+ *
+ * @see XXH64_state_s for details.
+ * @see @ref streaming_example "Streaming Example"
+ */
+typedef struct XXH64_state_s XXH64_state_t;   /* incomplete type */
+
+/*!
+ * @brief Allocates an @ref XXH64_state_t.
+ *
+ * @return An allocated pointer of @ref XXH64_state_t on success.
+ * @return `NULL` on failure.
+ *
+ * @note Must be freed with XXH64_freeState().
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_MALLOCF XXH64_state_t* XXH64_createState(void);
+
+/*!
+ * @brief Frees an @ref XXH64_state_t.
+ *
+ * @param statePtr A pointer to an @ref XXH64_state_t allocated with @ref XXH64_createState().
+ *
+ * @return @ref XXH_OK.
+ *
+ * @note @p statePtr must be allocated with XXH64_createState().
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_errorcode  XXH64_freeState(XXH64_state_t* statePtr);
+
+/*!
+ * @brief Copies one @ref XXH64_state_t to another.
+ *
+ * @param dst_state The state to copy to.
+ * @param src_state The state to copy from.
+ * @pre
+ *   @p dst_state and @p src_state must not be `NULL` and must not overlap.
+ */
+XXH_PUBLIC_API void XXH64_copyState(XXH_NOESCAPE XXH64_state_t* dst_state, const XXH64_state_t* src_state);
+
+/*!
+ * @brief Resets an @ref XXH64_state_t to begin a new hash.
+ *
+ * @param statePtr The state struct to reset.
+ * @param seed The 64-bit seed to alter the hash result predictably.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @note This function resets and seeds a state. Call it before @ref XXH64_update().
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_errorcode XXH64_reset  (XXH_NOESCAPE XXH64_state_t* statePtr, XXH64_hash_t seed);
+
+/*!
+ * @brief Consumes a block of @p input to an @ref XXH64_state_t.
+ *
+ * @param statePtr The state struct to update.
+ * @param input The block of data to be hashed, at least @p length bytes in size.
+ * @param length The length of @p input, in bytes.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ * @pre
+ *   The memory between @p input and @p input + @p length must be valid,
+ *   readable, contiguous memory. However, if @p length is `0`, @p input may be
+ *   `NULL`. In C++, this also must be *TriviallyCopyable*.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @note Call this to incrementally consume blocks of data.
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_errorcode XXH64_update (XXH_NOESCAPE XXH64_state_t* statePtr, XXH_NOESCAPE const void* input, size_t length);
+
+/*!
+ * @brief Returns the calculated hash value from an @ref XXH64_state_t.
+ *
+ * @param statePtr The state struct to calculate the hash from.
+ *
+ * @pre
+ *  @p statePtr must not be `NULL`.
+ *
+ * @return The calculated 64-bit xxHash64 value from that state.
+ *
+ * @note
+ *   Calling XXH64_digest() will not affect @p statePtr, so you can update,
+ *   digest, and update again.
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_PUREF XXH64_hash_t XXH64_digest (XXH_NOESCAPE const XXH64_state_t* statePtr);
+#endif /* !XXH_NO_STREAM */
+/*******   Canonical representation   *******/
+
+/*!
+ * @brief Canonical (big endian) representation of @ref XXH64_hash_t.
+ */
+typedef struct { unsigned char digest[sizeof(XXH64_hash_t)]; } XXH64_canonical_t;
+
+/*!
+ * @brief Converts an @ref XXH64_hash_t to a big endian @ref XXH64_canonical_t.
+ *
+ * @param dst The @ref XXH64_canonical_t pointer to be stored to.
+ * @param hash The @ref XXH64_hash_t to be converted.
+ *
+ * @pre
+ *   @p dst must not be `NULL`.
+ *
+ * @see @ref canonical_representation_example "Canonical Representation Example"
+ */
+XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH_NOESCAPE XXH64_canonical_t* dst, XXH64_hash_t hash);
+
+/*!
+ * @brief Converts an @ref XXH64_canonical_t to a native @ref XXH64_hash_t.
+ *
+ * @param src The @ref XXH64_canonical_t to convert.
+ *
+ * @pre
+ *   @p src must not be `NULL`.
+ *
+ * @return The converted hash.
+ *
+ * @see @ref canonical_representation_example "Canonical Representation Example"
+ */
+XXH_PUBLIC_API XXH_PUREF XXH64_hash_t XXH64_hashFromCanonical(XXH_NOESCAPE const XXH64_canonical_t* src);
+
+#ifndef XXH_NO_XXH3
+
+/*!
+ * @}
+ * ************************************************************************
+ * @defgroup XXH3_family XXH3 family
+ * @ingroup public
+ * @{
+ *
+ * XXH3 is a more recent hash algorithm featuring:
+ *  - Improved speed for both small and large inputs
+ *  - True 64-bit and 128-bit outputs
+ *  - SIMD acceleration
+ *  - Improved 32-bit viability
+ *
+ * Speed analysis methodology is explained here:
+ *
+ *    https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html
+ *
+ * Compared to XXH64, expect XXH3 to run approximately
+ * ~2x faster on large inputs and >3x faster on small ones,
+ * exact differences vary depending on platform.
+ *
+ * XXH3's speed benefits greatly from SIMD and 64-bit arithmetic,
+ * but does not require it.
+ * Most 32-bit and 64-bit targets that can run XXH32 smoothly can run XXH3
+ * at competitive speeds, even without vector support. Further details are
+ * explained in the implementation.
+ *
+ * XXH3 has a fast scalar implementation, but it also includes accelerated SIMD
+ * implementations for many common platforms:
+ *   - AVX512
+ *   - AVX2
+ *   - SSE2
+ *   - ARM NEON
+ *   - WebAssembly SIMD128
+ *   - POWER8 VSX
+ *   - s390x ZVector
+ * This can be controlled via the @ref XXH_VECTOR macro, but it automatically
+ * selects the best version according to predefined macros. For the x86 family, an
+ * automatic runtime dispatcher is included separately in @ref xxh_x86dispatch.c.
+ *
+ * XXH3 implementation is portable:
+ * it has a generic C90 formulation that can be compiled on any platform,
+ * all implementations generate exactly the same hash value on all platforms.
+ * Starting from v0.8.0, it's also labelled "stable", meaning that
+ * any future version will also generate the same hash value.
+ *
+ * XXH3 offers 2 variants, _64bits and _128bits.
+ *
+ * When only 64 bits are needed, prefer invoking the _64bits variant, as it
+ * reduces the amount of mixing, resulting in faster speed on small inputs.
+ * It's also generally simpler to manipulate a scalar return type than a struct.
+ *
+ * The API supports one-shot hashing, streaming mode, and custom secrets.
+ */
+
+/*!
+ * @ingroup tuning
+ * @brief Possible values for @ref XXH_VECTOR.
+ *
+ * Unless set explicitly, determined automatically.
+ */
+#  define XXH_SCALAR 0 /*!< Portable scalar version */
+#  define XXH_SSE2   1 /*!< SSE2 for Pentium 4, Opteron, all x86_64. */
+#  define XXH_AVX2   2 /*!< AVX2 for Haswell and Bulldozer */
+#  define XXH_AVX512 3 /*!< AVX512 for Skylake and Icelake */
+#  define XXH_NEON   4 /*!< NEON for most ARMv7-A, all AArch64, and WASM SIMD128 */
+#  define XXH_VSX    5 /*!< VSX and ZVector for POWER8/z13 (64-bit) */
+#  define XXH_SVE    6 /*!< SVE for some ARMv8-A and ARMv9-A */
+#  define XXH_LSX    7 /*!< LSX (128-bit SIMD) for LoongArch64 */
+
+
+/*-**********************************************************************
+*  XXH3 64-bit variant
+************************************************************************/
+
+/*!
+ * @brief Calculates 64-bit unseeded variant of XXH3 hash of @p input.
+ *
+ * @param input  The block of data to be hashed, at least @p length bytes in size.
+ * @param length The length of @p input, in bytes.
+ *
+ * @pre
+ *   The memory between @p input and @p input + @p length must be valid,
+ *   readable, contiguous memory. However, if @p length is `0`, @p input may be
+ *   `NULL`. In C++, this also must be *TriviallyCopyable*.
+ *
+ * @return The calculated 64-bit XXH3 hash value.
+ *
+ * @note
+ *   This is equivalent to @ref XXH3_64bits_withSeed() with a seed of `0`, however
+ *   it may have slightly better performance due to constant propagation of the
+ *   defaults.
+ *
+ * @see
+ *    XXH3_64bits_withSeed(), XXH3_64bits_withSecret(): other seeding variants
+ * @see @ref single_shot_example "Single Shot Example" for an example.
+ */
+XXH_PUBLIC_API XXH_PUREF XXH64_hash_t XXH3_64bits(XXH_NOESCAPE const void* input, size_t length);
+
+/*!
+ * @brief Calculates 64-bit seeded variant of XXH3 hash of @p input.
+ *
+ * @param input  The block of data to be hashed, at least @p length bytes in size.
+ * @param length The length of @p input, in bytes.
+ * @param seed   The 64-bit seed to alter the hash result predictably.
+ *
+ * @pre
+ *   The memory between @p input and @p input + @p length must be valid,
+ *   readable, contiguous memory. However, if @p length is `0`, @p input may be
+ *   `NULL`. In C++, this also must be *TriviallyCopyable*.
+ *
+ * @return The calculated 64-bit XXH3 hash value.
+ *
+ * @note
+ *    seed == 0 produces the same results as @ref XXH3_64bits().
+ *
+ * This variant generates a custom secret on the fly based on default secret
+ * altered using the @p seed value.
+ *
+ * While this operation is decently fast, note that it's not completely free.
+ *
+ * @see @ref single_shot_example "Single Shot Example" for an example.
+ */
+XXH_PUBLIC_API XXH_PUREF XXH64_hash_t XXH3_64bits_withSeed(XXH_NOESCAPE const void* input, size_t length, XXH64_hash_t seed);
+
+/*!
+ * The bare minimum size for a custom secret.
+ *
+ * @see
+ *  XXH3_64bits_withSecret(), XXH3_64bits_reset_withSecret(),
+ *  XXH3_128bits_withSecret(), XXH3_128bits_reset_withSecret().
+ */
+#define XXH3_SECRET_SIZE_MIN 136
+
+/*!
+ * @brief Calculates 64-bit variant of XXH3 with a custom "secret".
+ *
+ * @param data       The block of data to be hashed, at least @p len bytes in size.
+ * @param len        The length of @p data, in bytes.
+ * @param secret     The secret data.
+ * @param secretSize The length of @p secret, in bytes.
+ *
+ * @return The calculated 64-bit XXH3 hash value.
+ *
+ * @pre
+ *   The memory between @p data and @p data + @p len must be valid,
+ *   readable, contiguous memory. However, if @p length is `0`, @p data may be
+ *   `NULL`. In C++, this also must be *TriviallyCopyable*.
+ *
+ * It's possible to provide any blob of bytes as a "secret" to generate the hash.
+ * This makes it more difficult for an external actor to prepare an intentional collision.
+ * The main condition is that @p secretSize *must* be large enough (>= @ref XXH3_SECRET_SIZE_MIN).
+ * However, the quality of the secret impacts the dispersion of the hash algorithm.
+ * Therefore, the secret _must_ look like a bunch of random bytes.
+ * Avoid "trivial" or structured data such as repeated sequences or a text document.
+ * Whenever in doubt about the "randomness" of the blob of bytes,
+ * consider employing @ref XXH3_generateSecret() instead (see below).
+ * It will generate a proper high entropy secret derived from the blob of bytes.
+ * Another advantage of using XXH3_generateSecret() is that
+ * it guarantees that all bits within the initial blob of bytes
+ * will impact every bit of the output.
+ * This is not necessarily the case when using the blob of bytes directly
+ * because, when hashing _small_ inputs, only a portion of the secret is employed.
+ *
+ * @see @ref single_shot_example "Single Shot Example" for an example.
+ */
+XXH_PUBLIC_API XXH_PUREF XXH64_hash_t XXH3_64bits_withSecret(XXH_NOESCAPE const void* data, size_t len, XXH_NOESCAPE const void* secret, size_t secretSize);
+
+
+/*******   Streaming   *******/
+#ifndef XXH_NO_STREAM
+/*
+ * Streaming requires state maintenance.
+ * This operation costs memory and CPU.
+ * As a consequence, streaming is slower than one-shot hashing.
+ * For better performance, prefer one-shot functions whenever applicable.
+ */
+
+/*!
+ * @brief The opaque state struct for the XXH3 streaming API.
+ *
+ * @see XXH3_state_s for details.
+ * @see @ref streaming_example "Streaming Example"
+ */
+typedef struct XXH3_state_s XXH3_state_t;
+XXH_PUBLIC_API XXH_MALLOCF XXH3_state_t* XXH3_createState(void);
+XXH_PUBLIC_API XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr);
+
+/*!
+ * @brief Copies one @ref XXH3_state_t to another.
+ *
+ * @param dst_state The state to copy to.
+ * @param src_state The state to copy from.
+ * @pre
+ *   @p dst_state and @p src_state must not be `NULL` and must not overlap.
+ */
+XXH_PUBLIC_API void XXH3_copyState(XXH_NOESCAPE XXH3_state_t* dst_state, XXH_NOESCAPE const XXH3_state_t* src_state);
+
+/*!
+ * @brief Resets an @ref XXH3_state_t to begin a new hash.
+ *
+ * @param statePtr The state struct to reset.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @note
+ *   - This function resets `statePtr` and generate a secret with default parameters.
+ *   - Call this function before @ref XXH3_64bits_update().
+ *   - Digest will be equivalent to `XXH3_64bits()`.
+ *
+ * @see @ref streaming_example "Streaming Example"
+ *
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset(XXH_NOESCAPE XXH3_state_t* statePtr);
+
+/*!
+ * @brief Resets an @ref XXH3_state_t with 64-bit seed to begin a new hash.
+ *
+ * @param statePtr The state struct to reset.
+ * @param seed     The 64-bit seed to alter the hash result predictably.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @note
+ *   - This function resets `statePtr` and generate a secret from `seed`.
+ *   - Call this function before @ref XXH3_64bits_update().
+ *   - Digest will be equivalent to `XXH3_64bits_withSeed()`.
+ *
+ * @see @ref streaming_example "Streaming Example"
+ *
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSeed(XXH_NOESCAPE XXH3_state_t* statePtr, XXH64_hash_t seed);
+
+/*!
+ * @brief Resets an @ref XXH3_state_t with secret data to begin a new hash.
+ *
+ * @param statePtr The state struct to reset.
+ * @param secret     The secret data.
+ * @param secretSize The length of @p secret, in bytes.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @note
+ *   `secret` is referenced, it _must outlive_ the hash streaming session.
+ *
+ * Similar to one-shot API, `secretSize` must be >= @ref XXH3_SECRET_SIZE_MIN,
+ * and the quality of produced hash values depends on secret's entropy
+ * (secret's content should look like a bunch of random bytes).
+ * When in doubt about the randomness of a candidate `secret`,
+ * consider employing `XXH3_generateSecret()` instead (see below).
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSecret(XXH_NOESCAPE XXH3_state_t* statePtr, XXH_NOESCAPE const void* secret, size_t secretSize);
+
+/*!
+ * @brief Consumes a block of @p input to an @ref XXH3_state_t.
+ *
+ * @param statePtr The state struct to update.
+ * @param input The block of data to be hashed, at least @p length bytes in size.
+ * @param length The length of @p input, in bytes.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ * @pre
+ *   The memory between @p input and @p input + @p length must be valid,
+ *   readable, contiguous memory. However, if @p length is `0`, @p input may be
+ *   `NULL`. In C++, this also must be *TriviallyCopyable*.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @note Call this to incrementally consume blocks of data.
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_64bits_update (XXH_NOESCAPE XXH3_state_t* statePtr, XXH_NOESCAPE const void* input, size_t length);
+
+/*!
+ * @brief Returns the calculated XXH3 64-bit hash value from an @ref XXH3_state_t.
+ *
+ * @param statePtr The state struct to calculate the hash from.
+ *
+ * @pre
+ *  @p statePtr must not be `NULL`.
+ *
+ * @return The calculated XXH3 64-bit hash value from that state.
+ *
+ * @note
+ *   Calling XXH3_64bits_digest() will not affect @p statePtr, so you can update,
+ *   digest, and update again.
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_PUREF XXH64_hash_t  XXH3_64bits_digest (XXH_NOESCAPE const XXH3_state_t* statePtr);
+#endif /* !XXH_NO_STREAM */
+
+/* note : canonical representation of XXH3 is the same as XXH64
+ * since they both produce XXH64_hash_t values */
+
+
+/*-**********************************************************************
+*  XXH3 128-bit variant
+************************************************************************/
+
+/*!
+ * @brief The return value from 128-bit hashes.
+ *
+ * Stored in little endian order, although the fields themselves are in native
+ * endianness.
+ */
+typedef struct {
+    XXH64_hash_t low64;   /*!< `value & 0xFFFFFFFFFFFFFFFF` */
+    XXH64_hash_t high64;  /*!< `value >> 64` */
+} XXH128_hash_t;
+
+/*!
+ * @brief Calculates 128-bit unseeded variant of XXH3 of @p data.
+ *
+ * @param data The block of data to be hashed, at least @p length bytes in size.
+ * @param len  The length of @p data, in bytes.
+ *
+ * @return The calculated 128-bit variant of XXH3 value.
+ *
+ * The 128-bit variant of XXH3 has more strength, but it has a bit of overhead
+ * for shorter inputs.
+ *
+ * This is equivalent to @ref XXH3_128bits_withSeed() with a seed of `0`, however
+ * it may have slightly better performance due to constant propagation of the
+ * defaults.
+ *
+ * @see XXH3_128bits_withSeed(), XXH3_128bits_withSecret(): other seeding variants
+ * @see @ref single_shot_example "Single Shot Example" for an example.
+ */
+XXH_PUBLIC_API XXH_PUREF XXH128_hash_t XXH3_128bits(XXH_NOESCAPE const void* data, size_t len);
+/*! @brief Calculates 128-bit seeded variant of XXH3 hash of @p data.
+ *
+ * @param data The block of data to be hashed, at least @p length bytes in size.
+ * @param len  The length of @p data, in bytes.
+ * @param seed The 64-bit seed to alter the hash result predictably.
+ *
+ * @return The calculated 128-bit variant of XXH3 value.
+ *
+ * @note
+ *    seed == 0 produces the same results as @ref XXH3_64bits().
+ *
+ * This variant generates a custom secret on the fly based on default secret
+ * altered using the @p seed value.
+ *
+ * While this operation is decently fast, note that it's not completely free.
+ *
+ * @see XXH3_128bits(), XXH3_128bits_withSecret(): other seeding variants
+ * @see @ref single_shot_example "Single Shot Example" for an example.
+ */
+XXH_PUBLIC_API XXH_PUREF XXH128_hash_t XXH3_128bits_withSeed(XXH_NOESCAPE const void* data, size_t len, XXH64_hash_t seed);
+/*!
+ * @brief Calculates 128-bit variant of XXH3 with a custom "secret".
+ *
+ * @param data       The block of data to be hashed, at least @p len bytes in size.
+ * @param len        The length of @p data, in bytes.
+ * @param secret     The secret data.
+ * @param secretSize The length of @p secret, in bytes.
+ *
+ * @return The calculated 128-bit variant of XXH3 value.
+ *
+ * It's possible to provide any blob of bytes as a "secret" to generate the hash.
+ * This makes it more difficult for an external actor to prepare an intentional collision.
+ * The main condition is that @p secretSize *must* be large enough (>= @ref XXH3_SECRET_SIZE_MIN).
+ * However, the quality of the secret impacts the dispersion of the hash algorithm.
+ * Therefore, the secret _must_ look like a bunch of random bytes.
+ * Avoid "trivial" or structured data such as repeated sequences or a text document.
+ * Whenever in doubt about the "randomness" of the blob of bytes,
+ * consider employing @ref XXH3_generateSecret() instead (see below).
+ * It will generate a proper high entropy secret derived from the blob of bytes.
+ * Another advantage of using XXH3_generateSecret() is that
+ * it guarantees that all bits within the initial blob of bytes
+ * will impact every bit of the output.
+ * This is not necessarily the case when using the blob of bytes directly
+ * because, when hashing _small_ inputs, only a portion of the secret is employed.
+ *
+ * @see @ref single_shot_example "Single Shot Example" for an example.
+ */
+XXH_PUBLIC_API XXH_PUREF XXH128_hash_t XXH3_128bits_withSecret(XXH_NOESCAPE const void* data, size_t len, XXH_NOESCAPE const void* secret, size_t secretSize);
+
+/*******   Streaming   *******/
+#ifndef XXH_NO_STREAM
+/*
+ * Streaming requires state maintenance.
+ * This operation costs memory and CPU.
+ * As a consequence, streaming is slower than one-shot hashing.
+ * For better performance, prefer one-shot functions whenever applicable.
+ *
+ * XXH3_128bits uses the same XXH3_state_t as XXH3_64bits().
+ * Use already declared XXH3_createState() and XXH3_freeState().
+ *
+ * All reset and streaming functions have same meaning as their 64-bit counterpart.
+ */
+
+/*!
+ * @brief Resets an @ref XXH3_state_t to begin a new hash.
+ *
+ * @param statePtr The state struct to reset.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @note
+ *   - This function resets `statePtr` and generate a secret with default parameters.
+ *   - Call it before @ref XXH3_128bits_update().
+ *   - Digest will be equivalent to `XXH3_128bits()`.
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset(XXH_NOESCAPE XXH3_state_t* statePtr);
+
+/*!
+ * @brief Resets an @ref XXH3_state_t with 64-bit seed to begin a new hash.
+ *
+ * @param statePtr The state struct to reset.
+ * @param seed     The 64-bit seed to alter the hash result predictably.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @note
+ *   - This function resets `statePtr` and generate a secret from `seed`.
+ *   - Call it before @ref XXH3_128bits_update().
+ *   - Digest will be equivalent to `XXH3_128bits_withSeed()`.
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH_NOESCAPE XXH3_state_t* statePtr, XXH64_hash_t seed);
+/*!
+ * @brief Resets an @ref XXH3_state_t with secret data to begin a new hash.
+ *
+ * @param statePtr   The state struct to reset.
+ * @param secret     The secret data.
+ * @param secretSize The length of @p secret, in bytes.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * `secret` is referenced, it _must outlive_ the hash streaming session.
+ * Similar to one-shot API, `secretSize` must be >= @ref XXH3_SECRET_SIZE_MIN,
+ * and the quality of produced hash values depends on secret's entropy
+ * (secret's content should look like a bunch of random bytes).
+ * When in doubt about the randomness of a candidate `secret`,
+ * consider employing `XXH3_generateSecret()` instead (see below).
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH_NOESCAPE XXH3_state_t* statePtr, XXH_NOESCAPE const void* secret, size_t secretSize);
+
+/*!
+ * @brief Consumes a block of @p input to an @ref XXH3_state_t.
+ *
+ * Call this to incrementally consume blocks of data.
+ *
+ * @param statePtr The state struct to update.
+ * @param input The block of data to be hashed, at least @p length bytes in size.
+ * @param length The length of @p input, in bytes.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @note
+ *   The memory between @p input and @p input + @p length must be valid,
+ *   readable, contiguous memory. However, if @p length is `0`, @p input may be
+ *   `NULL`. In C++, this also must be *TriviallyCopyable*.
+ *
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH_NOESCAPE XXH3_state_t* statePtr, XXH_NOESCAPE const void* input, size_t length);
+
+/*!
+ * @brief Returns the calculated XXH3 128-bit hash value from an @ref XXH3_state_t.
+ *
+ * @param statePtr The state struct to calculate the hash from.
+ *
+ * @pre
+ *  @p statePtr must not be `NULL`.
+ *
+ * @return The calculated XXH3 128-bit hash value from that state.
+ *
+ * @note
+ *   Calling XXH3_128bits_digest() will not affect @p statePtr, so you can update,
+ *   digest, and update again.
+ *
+ */
+XXH_PUBLIC_API XXH_PUREF XXH128_hash_t XXH3_128bits_digest (XXH_NOESCAPE const XXH3_state_t* statePtr);
+#endif /* !XXH_NO_STREAM */
+
+/* Following helper functions make it possible to compare XXH128_hast_t values.
+ * Since XXH128_hash_t is a structure, this capability is not offered by the language.
+ * Note: For better performance, these functions can be inlined using XXH_INLINE_ALL */
+
+/*!
+ * @brief Check equality of two XXH128_hash_t values
+ *
+ * @param h1 The 128-bit hash value.
+ * @param h2 Another 128-bit hash value.
+ *
+ * @return `1` if `h1` and `h2` are equal.
+ * @return `0` if they are not.
+ */
+XXH_PUBLIC_API XXH_PUREF int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2);
+
+/*!
+ * @brief Compares two @ref XXH128_hash_t
+ *
+ * This comparator is compatible with stdlib's `qsort()`/`bsearch()`.
+ *
+ * @param h128_1 Left-hand side value
+ * @param h128_2 Right-hand side value
+ *
+ * @return >0 if @p h128_1  > @p h128_2
+ * @return =0 if @p h128_1 == @p h128_2
+ * @return <0 if @p h128_1  < @p h128_2
+ */
+XXH_PUBLIC_API XXH_PUREF int XXH128_cmp(XXH_NOESCAPE const void* h128_1, XXH_NOESCAPE const void* h128_2);
+
+
+/*******   Canonical representation   *******/
+typedef struct { unsigned char digest[sizeof(XXH128_hash_t)]; } XXH128_canonical_t;
+
+
+/*!
+ * @brief Converts an @ref XXH128_hash_t to a big endian @ref XXH128_canonical_t.
+ *
+ * @param dst  The @ref XXH128_canonical_t pointer to be stored to.
+ * @param hash The @ref XXH128_hash_t to be converted.
+ *
+ * @pre
+ *   @p dst must not be `NULL`.
+ * @see @ref canonical_representation_example "Canonical Representation Example"
+ */
+XXH_PUBLIC_API void XXH128_canonicalFromHash(XXH_NOESCAPE XXH128_canonical_t* dst, XXH128_hash_t hash);
+
+/*!
+ * @brief Converts an @ref XXH128_canonical_t to a native @ref XXH128_hash_t.
+ *
+ * @param src The @ref XXH128_canonical_t to convert.
+ *
+ * @pre
+ *   @p src must not be `NULL`.
+ *
+ * @return The converted hash.
+ * @see @ref canonical_representation_example "Canonical Representation Example"
+ */
+XXH_PUBLIC_API XXH_PUREF XXH128_hash_t XXH128_hashFromCanonical(XXH_NOESCAPE const XXH128_canonical_t* src);
+
+
+#endif  /* !XXH_NO_XXH3 */
+#endif  /* XXH_NO_LONG_LONG */
+
+/*!
+ * @}
+ */
+#endif /* XXHASH_H_5627135585666179 */
+
+
+
+#if defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742)
+#define XXHASH_H_STATIC_13879238742
+/* ****************************************************************************
+ * This section contains declarations which are not guaranteed to remain stable.
+ * They may change in future versions, becoming incompatible with a different
+ * version of the library.
+ * These declarations should only be used with static linking.
+ * Never use them in association with dynamic linking!
+ ***************************************************************************** */
+
+/*
+ * These definitions are only present to allow static allocation
+ * of XXH states, on stack or in a struct, for example.
+ * Never **ever** access their members directly.
+ */
+
+/*!
+ * @internal
+ * @brief Structure for XXH32 streaming API.
+ *
+ * @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,
+ * @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined. Otherwise it is
+ * an opaque type. This allows fields to safely be changed.
+ *
+ * Typedef'd to @ref XXH32_state_t.
+ * Do not access the members of this struct directly.
+ * @see XXH64_state_s, XXH3_state_s
+ */
+struct XXH32_state_s {
+   XXH32_hash_t total_len_32; /*!< Total length hashed, modulo 2^32 */
+   XXH32_hash_t large_len;    /*!< Whether the hash is >= 16 (handles @ref total_len_32 overflow) */
+   XXH32_hash_t acc[4];       /*!< Accumulator lanes */
+   unsigned char buffer[16];  /*!< Internal buffer for partial reads. */
+   XXH32_hash_t bufferedSize; /*!< Amount of data in @ref buffer */
+   XXH32_hash_t reserved;     /*!< Reserved field. Do not read nor write to it. */
+};   /* typedef'd to XXH32_state_t */
+
+
+#ifndef XXH_NO_LONG_LONG  /* defined when there is no 64-bit support */
+
+/*!
+ * @internal
+ * @brief Structure for XXH64 streaming API.
+ *
+ * @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,
+ * @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined. Otherwise it is
+ * an opaque type. This allows fields to safely be changed.
+ *
+ * Typedef'd to @ref XXH64_state_t.
+ * Do not access the members of this struct directly.
+ * @see XXH32_state_s, XXH3_state_s
+ */
+struct XXH64_state_s {
+   XXH64_hash_t total_len;    /*!< Total length hashed. This is always 64-bit. */
+   XXH64_hash_t acc[4];       /*!< Accumulator lanes */
+   unsigned char buffer[32];  /*!< Internal buffer for partial reads.. */
+   XXH32_hash_t bufferedSize; /*!< Amount of data in @ref buffer */
+   XXH32_hash_t reserved32;   /*!< Reserved field, needed for padding anyways*/
+   XXH64_hash_t reserved64;   /*!< Reserved field. Do not read or write to it. */
+};   /* typedef'd to XXH64_state_t */
+
+#ifndef XXH_NO_XXH3
+
+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) /* >= C11 */
+#  define XXH_ALIGN(n)      _Alignas(n)
+#elif defined(__cplusplus) && (__cplusplus >= 201103L) /* >= C++11 */
+/* In C++ alignas() is a keyword */
+#  define XXH_ALIGN(n)      alignas(n)
+#elif defined(__GNUC__)
+#  define XXH_ALIGN(n)      __attribute__ ((aligned(n)))
+#elif defined(_MSC_VER)
+#  define XXH_ALIGN(n)      __declspec(align(n))
+#else
+#  define XXH_ALIGN(n)   /* disabled */
+#endif
+
+/* Old GCC versions only accept the attribute after the type in structures. */
+#if !(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L))   /* C11+ */ \
+    && ! (defined(__cplusplus) && (__cplusplus >= 201103L)) /* >= C++11 */ \
+    && defined(__GNUC__)
+#   define XXH_ALIGN_MEMBER(align, type) type XXH_ALIGN(align)
+#else
+#   define XXH_ALIGN_MEMBER(align, type) XXH_ALIGN(align) type
+#endif
+
+/*!
+ * @brief The size of the internal XXH3 buffer.
+ *
+ * This is the optimal update size for incremental hashing.
+ *
+ * @see XXH3_64b_update(), XXH3_128b_update().
+ */
+#define XXH3_INTERNALBUFFER_SIZE 256
+
+/*!
+ * @internal
+ * @brief Default size of the secret buffer (and @ref XXH3_kSecret).
+ *
+ * This is the size used in @ref XXH3_kSecret and the seeded functions.
+ *
+ * Not to be confused with @ref XXH3_SECRET_SIZE_MIN.
+ */
+#define XXH3_SECRET_DEFAULT_SIZE 192
+
+/*!
+ * @internal
+ * @brief Structure for XXH3 streaming API.
+ *
+ * @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,
+ * @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined.
+ * Otherwise it is an opaque type.
+ * Never use this definition in combination with dynamic library.
+ * This allows fields to safely be changed in the future.
+ *
+ * @note ** This structure has a strict alignment requirement of 64 bytes!! **
+ * Do not allocate this with `malloc()` or `new`,
+ * it will not be sufficiently aligned.
+ * Use @ref XXH3_createState() and @ref XXH3_freeState(), or stack allocation.
+ *
+ * Typedef'd to @ref XXH3_state_t.
+ * Do never access the members of this struct directly.
+ *
+ * @see XXH3_INITSTATE() for stack initialization.
+ * @see XXH3_createState(), XXH3_freeState().
+ * @see XXH32_state_s, XXH64_state_s
+ */
+struct XXH3_state_s {
+   XXH_ALIGN_MEMBER(64, XXH64_hash_t acc[8]);
+       /*!< The 8 accumulators. See @ref XXH32_state_s::v and @ref XXH64_state_s::v */
+   XXH_ALIGN_MEMBER(64, unsigned char customSecret[XXH3_SECRET_DEFAULT_SIZE]);
+       /*!< Used to store a custom secret generated from a seed. */
+   XXH_ALIGN_MEMBER(64, unsigned char buffer[XXH3_INTERNALBUFFER_SIZE]);
+       /*!< The internal buffer. @see XXH32_state_s::mem32 */
+   XXH32_hash_t bufferedSize;
+       /*!< The amount of memory in @ref buffer, @see XXH32_state_s::memsize */
+   XXH32_hash_t useSeed;
+       /*!< Reserved field. Needed for padding on 64-bit. */
+   size_t nbStripesSoFar;
+       /*!< Number or stripes processed. */
+   XXH64_hash_t totalLen;
+       /*!< Total length hashed. 64-bit even on 32-bit targets. */
+   size_t nbStripesPerBlock;
+       /*!< Number of stripes per block. */
+   size_t secretLimit;
+       /*!< Size of @ref customSecret or @ref extSecret */
+   XXH64_hash_t seed;
+       /*!< Seed for _withSeed variants. Must be zero otherwise, @see XXH3_INITSTATE() */
+   XXH64_hash_t reserved64;
+       /*!< Reserved field. */
+   const unsigned char* extSecret;
+       /*!< Reference to an external secret for the _withSecret variants, NULL
+        *   for other variants. */
+   /* note: there may be some padding at the end due to alignment on 64 bytes */
+}; /* typedef'd to XXH3_state_t */
+
+#undef XXH_ALIGN_MEMBER
+
+/*!
+ * @brief Initializes a stack-allocated `XXH3_state_s`.
+ *
+ * When the @ref XXH3_state_t structure is merely emplaced on stack,
+ * it should be initialized with XXH3_INITSTATE() or a memset()
+ * in case its first reset uses XXH3_NNbits_reset_withSeed().
+ * This init can be omitted if the first reset uses default or _withSecret mode.
+ * This operation isn't necessary when the state is created with XXH3_createState().
+ * Note that this doesn't prepare the state for a streaming operation,
+ * it's still necessary to use XXH3_NNbits_reset*() afterwards.
+ */
+#define XXH3_INITSTATE(XXH3_state_ptr)                       \
+    do {                                                     \
+        XXH3_state_t* tmp_xxh3_state_ptr = (XXH3_state_ptr); \
+        tmp_xxh3_state_ptr->seed = 0;                        \
+        tmp_xxh3_state_ptr->extSecret = NULL;                \
+    } while(0)
+
+
+/*!
+ * @brief Calculates the 128-bit hash of @p data using XXH3.
+ *
+ * @param data The block of data to be hashed, at least @p len bytes in size.
+ * @param len  The length of @p data, in bytes.
+ * @param seed The 64-bit seed to alter the hash's output predictably.
+ *
+ * @pre
+ *   The memory between @p data and @p data + @p len must be valid,
+ *   readable, contiguous memory. However, if @p len is `0`, @p data may be
+ *   `NULL`. In C++, this also must be *TriviallyCopyable*.
+ *
+ * @return The calculated 128-bit XXH3 value.
+ *
+ * @see @ref single_shot_example "Single Shot Example" for an example.
+ */
+XXH_PUBLIC_API XXH_PUREF XXH128_hash_t XXH128(XXH_NOESCAPE const void* data, size_t len, XXH64_hash_t seed);
+
+
+/* ===   Experimental API   === */
+/* Symbols defined below must be considered tied to a specific library version. */
+
+/*!
+ * @brief Derive a high-entropy secret from any user-defined content, named customSeed.
+ *
+ * @param secretBuffer    A writable buffer for derived high-entropy secret data.
+ * @param secretSize      Size of secretBuffer, in bytes.  Must be >= XXH3_SECRET_SIZE_MIN.
+ * @param customSeed      A user-defined content.
+ * @param customSeedSize  Size of customSeed, in bytes.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * The generated secret can be used in combination with `*_withSecret()` functions.
+ * The `_withSecret()` variants are useful to provide a higher level of protection
+ * than 64-bit seed, as it becomes much more difficult for an external actor to
+ * guess how to impact the calculation logic.
+ *
+ * The function accepts as input a custom seed of any length and any content,
+ * and derives from it a high-entropy secret of length @p secretSize into an
+ * already allocated buffer @p secretBuffer.
+ *
+ * The generated secret can then be used with any `*_withSecret()` variant.
+ * The functions @ref XXH3_128bits_withSecret(), @ref XXH3_64bits_withSecret(),
+ * @ref XXH3_128bits_reset_withSecret() and @ref XXH3_64bits_reset_withSecret()
+ * are part of this list. They all accept a `secret` parameter
+ * which must be large enough for implementation reasons (>= @ref XXH3_SECRET_SIZE_MIN)
+ * _and_ feature very high entropy (consist of random-looking bytes).
+ * These conditions can be a high bar to meet, so @ref XXH3_generateSecret() can
+ * be employed to ensure proper quality.
+ *
+ * @p customSeed can be anything. It can have any size, even small ones,
+ * and its content can be anything, even "poor entropy" sources such as a bunch
+ * of zeroes. The resulting `secret` will nonetheless provide all required qualities.
+ *
+ * @pre
+ *   - @p secretSize must be >= @ref XXH3_SECRET_SIZE_MIN
+ *   - When @p customSeedSize > 0, supplying NULL as customSeed is undefined behavior.
+ *
+ * Example code:
+ * @code{.c}
+ *    #include <stdio.h>
+ *    #include <stdlib.h>
+ *    #include <string.h>
+ *    #define XXH_STATIC_LINKING_ONLY // expose unstable API
+ *    #include "xxhash.h"
+ *    // Hashes argv[2] using the entropy from argv[1].
+ *    int main(int argc, char* argv[])
+ *    {
+ *        char secret[XXH3_SECRET_SIZE_MIN];
+ *        if (argv != 3) { return 1; }
+ *        XXH3_generateSecret(secret, sizeof(secret), argv[1], strlen(argv[1]));
+ *        XXH64_hash_t h = XXH3_64bits_withSecret(
+ *             argv[2], strlen(argv[2]),
+ *             secret, sizeof(secret)
+ *        );
+ *        printf("%016llx\n", (unsigned long long) h);
+ *    }
+ * @endcode
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_generateSecret(XXH_NOESCAPE void* secretBuffer, size_t secretSize, XXH_NOESCAPE const void* customSeed, size_t customSeedSize);
+
+/*!
+ * @brief Generate the same secret as the _withSeed() variants.
+ *
+ * @param secretBuffer A writable buffer of @ref XXH3_SECRET_DEFAULT_SIZE bytes
+ * @param seed         The 64-bit seed to alter the hash result predictably.
+ *
+ * The generated secret can be used in combination with
+ *`*_withSecret()` and `_withSecretandSeed()` variants.
+ *
+ * Example C++ `std::string` hash class:
+ * @code{.cpp}
+ *    #include <string>
+ *    #define XXH_STATIC_LINKING_ONLY // expose unstable API
+ *    #include "xxhash.h"
+ *    // Slow, seeds each time
+ *    class HashSlow {
+ *        XXH64_hash_t seed;
+ *    public:
+ *        HashSlow(XXH64_hash_t s) : seed{s} {}
+ *        size_t operator()(const std::string& x) const {
+ *            return size_t{XXH3_64bits_withSeed(x.c_str(), x.length(), seed)};
+ *        }
+ *    };
+ *    // Fast, caches the seeded secret for future uses.
+ *    class HashFast {
+ *        unsigned char secret[XXH3_SECRET_DEFAULT_SIZE];
+ *    public:
+ *        HashFast(XXH64_hash_t s) {
+ *            XXH3_generateSecret_fromSeed(secret, seed);
+ *        }
+ *        size_t operator()(const std::string& x) const {
+ *            return size_t{
+ *                XXH3_64bits_withSecret(x.c_str(), x.length(), secret, sizeof(secret))
+ *            };
+ *        }
+ *    };
+ * @endcode
+ */
+XXH_PUBLIC_API void XXH3_generateSecret_fromSeed(XXH_NOESCAPE void* secretBuffer, XXH64_hash_t seed);
+
+/*!
+ * @brief Maximum size of "short" key in bytes.
+ */
+#define XXH3_MIDSIZE_MAX 240
+
+/*!
+ * @brief Calculates 64/128-bit seeded variant of XXH3 hash of @p data.
+ *
+ * @param data       The block of data to be hashed, at least @p len bytes in size.
+ * @param len        The length of @p data, in bytes.
+ * @param secret     The secret data.
+ * @param secretSize The length of @p secret, in bytes.
+ * @param seed       The 64-bit seed to alter the hash result predictably.
+ *
+ * These variants generate hash values using either:
+ * - @p seed for "short" keys (< @ref XXH3_MIDSIZE_MAX = 240 bytes)
+ * - @p secret for "large" keys (>= @ref XXH3_MIDSIZE_MAX).
+ *
+ * This generally benefits speed, compared to `_withSeed()` or `_withSecret()`.
+ * `_withSeed()` has to generate the secret on the fly for "large" keys.
+ * It's fast, but can be perceptible for "not so large" keys (< 1 KB).
+ * `_withSecret()` has to generate the masks on the fly for "small" keys,
+ * which requires more instructions than _withSeed() variants.
+ * Therefore, _withSecretandSeed variant combines the best of both worlds.
+ *
+ * When @p secret has been generated by XXH3_generateSecret_fromSeed(),
+ * this variant produces *exactly* the same results as `_withSeed()` variant,
+ * hence offering only a pure speed benefit on "large" input,
+ * by skipping the need to regenerate the secret for every large input.
+ *
+ * Another usage scenario is to hash the secret to a 64-bit hash value,
+ * for example with XXH3_64bits(), which then becomes the seed,
+ * and then employ both the seed and the secret in _withSecretandSeed().
+ * On top of speed, an added benefit is that each bit in the secret
+ * has a 50% chance to swap each bit in the output, via its impact to the seed.
+ *
+ * This is not guaranteed when using the secret directly in "small data" scenarios,
+ * because only portions of the secret are employed for small data.
+ */
+XXH_PUBLIC_API XXH_PUREF XXH64_hash_t
+XXH3_64bits_withSecretandSeed(XXH_NOESCAPE const void* data, size_t len,
+                              XXH_NOESCAPE const void* secret, size_t secretSize,
+                              XXH64_hash_t seed);
+
+/*!
+ * @brief Calculates 128-bit seeded variant of XXH3 hash of @p data.
+ *
+ * @param data       The memory segment to be hashed, at least @p len bytes in size.
+ * @param length     The length of @p data, in bytes.
+ * @param secret     The secret used to alter hash result predictably.
+ * @param secretSize The length of @p secret, in bytes (must be >= XXH3_SECRET_SIZE_MIN)
+ * @param seed64     The 64-bit seed to alter the hash result predictably.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @see XXH3_64bits_withSecretandSeed(): contract is the same.
+ */
+XXH_PUBLIC_API XXH_PUREF XXH128_hash_t
+XXH3_128bits_withSecretandSeed(XXH_NOESCAPE const void* input, size_t length,
+                               XXH_NOESCAPE const void* secret, size_t secretSize,
+                               XXH64_hash_t seed64);
+
+#ifndef XXH_NO_STREAM
+/*!
+ * @brief Resets an @ref XXH3_state_t with secret data to begin a new hash.
+ *
+ * @param statePtr   A pointer to an @ref XXH3_state_t allocated with @ref XXH3_createState().
+ * @param secret     The secret data.
+ * @param secretSize The length of @p secret, in bytes.
+ * @param seed64     The 64-bit seed to alter the hash result predictably.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @see XXH3_64bits_withSecretandSeed(). Contract is identical.
+ */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_reset_withSecretandSeed(XXH_NOESCAPE XXH3_state_t* statePtr,
+                                    XXH_NOESCAPE const void* secret, size_t secretSize,
+                                    XXH64_hash_t seed64);
+
+/*!
+ * @brief Resets an @ref XXH3_state_t with secret data to begin a new hash.
+ *
+ * @param statePtr   A pointer to an @ref XXH3_state_t allocated with @ref XXH3_createState().
+ * @param secret     The secret data.
+ * @param secretSize The length of @p secret, in bytes.
+ * @param seed64     The 64-bit seed to alter the hash result predictably.
+ *
+ * @return @ref XXH_OK on success.
+ * @return @ref XXH_ERROR on failure.
+ *
+ * @see XXH3_64bits_withSecretandSeed(). Contract is identical.
+ *
+ * Note: there was a bug in an earlier version of this function (<= v0.8.2)
+ * that would make it generate an incorrect hash value
+ * when @p seed == 0 and @p length < XXH3_MIDSIZE_MAX
+ * and @p secret is different from XXH3_generateSecret_fromSeed().
+ * As stated in the contract, the correct hash result must be
+ * the same as XXH3_128bits_withSeed() when @p length <= XXH3_MIDSIZE_MAX.
+ * Results generated by this older version are wrong, hence not comparable.
+ */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_reset_withSecretandSeed(XXH_NOESCAPE XXH3_state_t* statePtr,
+                                     XXH_NOESCAPE const void* secret, size_t secretSize,
+                                     XXH64_hash_t seed64);
+
+#endif /* !XXH_NO_STREAM */
+
+#endif  /* !XXH_NO_XXH3 */
+#endif  /* XXH_NO_LONG_LONG */
+#if defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)
+#  define XXH_IMPLEMENTATION
+#endif
+
+#endif  /* defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742) */
+
+
+/* ======================================================================== */
+/* ======================================================================== */
+/* ======================================================================== */
+
+
+/*-**********************************************************************
+ * xxHash implementation
+ *-**********************************************************************
+ * xxHash's implementation used to be hosted inside xxhash.c.
+ *
+ * However, inlining requires implementation to be visible to the compiler,
+ * hence be included alongside the header.
+ * Previously, implementation was hosted inside xxhash.c,
+ * which was then #included when inlining was activated.
+ * This construction created issues with a few build and install systems,
+ * as it required xxhash.c to be stored in /include directory.
+ *
+ * xxHash implementation is now directly integrated within xxhash.h.
+ * As a consequence, xxhash.c is no longer needed in /include.
+ *
+ * xxhash.c is still available and is still useful.
+ * In a "normal" setup, when xxhash is not inlined,
+ * xxhash.h only exposes the prototypes and public symbols,
+ * while xxhash.c can be built into an object file xxhash.o
+ * which can then be linked into the final binary.
+ ************************************************************************/
+
+#if ( defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API) \
+   || defined(XXH_IMPLEMENTATION) ) && !defined(XXH_IMPLEM_13a8737387)
+#  define XXH_IMPLEM_13a8737387
+
+/* *************************************
+*  Tuning parameters
+***************************************/
+
+/*!
+ * @defgroup tuning Tuning parameters
+ * @{
+ *
+ * Various macros to control xxHash's behavior.
+ */
+#ifdef XXH_DOXYGEN
+/*!
+ * @brief Define this to disable 64-bit code.
+ *
+ * Useful if only using the @ref XXH32_family and you have a strict C90 compiler.
+ */
+#  define XXH_NO_LONG_LONG
+#  undef XXH_NO_LONG_LONG /* don't actually */
+/*!
+ * @brief Controls how unaligned memory is accessed.
+ *
+ * By default, access to unaligned memory is controlled by `memcpy()`, which is
+ * safe and portable.
+ *
+ * Unfortunately, on some target/compiler combinations, the generated assembly
+ * is sub-optimal.
+ *
+ * The below switch allow selection of a different access method
+ * in the search for improved performance.
+ *
+ * @par Possible options:
+ *
+ *  - `XXH_FORCE_MEMORY_ACCESS=0` (default): `memcpy`
+ *   @par
+ *     Use `memcpy()`. Safe and portable. Note that most modern compilers will
+ *     eliminate the function call and treat it as an unaligned access.
+ *
+ *  - `XXH_FORCE_MEMORY_ACCESS=1`: `__attribute__((aligned(1)))`
+ *   @par
+ *     Depends on compiler extensions and is therefore not portable.
+ *     This method is safe _if_ your compiler supports it,
+ *     and *generally* as fast or faster than `memcpy`.
+ *
+ *  - `XXH_FORCE_MEMORY_ACCESS=2`: Direct cast
+ *  @par
+ *     Casts directly and dereferences. This method doesn't depend on the
+ *     compiler, but it violates the C standard as it directly dereferences an
+ *     unaligned pointer. It can generate buggy code on targets which do not
+ *     support unaligned memory accesses, but in some circumstances, it's the
+ *     only known way to get the most performance.
+ *
+ *  - `XXH_FORCE_MEMORY_ACCESS=3`: Byteshift
+ *  @par
+ *     Also portable. This can generate the best code on old compilers which don't
+ *     inline small `memcpy()` calls, and it might also be faster on big-endian
+ *     systems which lack a native byteswap instruction. However, some compilers
+ *     will emit literal byteshifts even if the target supports unaligned access.
+ *
+ *
+ * @warning
+ *   Methods 1 and 2 rely on implementation-defined behavior. Use these with
+ *   care, as what works on one compiler/platform/optimization level may cause
+ *   another to read garbage data or even crash.
+ *
+ * See https://fastcompression.blogspot.com/2015/08/accessing-unaligned-memory.html for details.
+ *
+ * Prefer these methods in priority order (0 > 3 > 1 > 2)
+ */
+#  define XXH_FORCE_MEMORY_ACCESS 0
+
+/*!
+ * @def XXH_SIZE_OPT
+ * @brief Controls how much xxHash optimizes for size.
+ *
+ * xxHash, when compiled, tends to result in a rather large binary size. This
+ * is mostly due to heavy usage to forced inlining and constant folding of the
+ * @ref XXH3_family to increase performance.
+ *
+ * However, some developers prefer size over speed. This option can
+ * significantly reduce the size of the generated code. When using the `-Os`
+ * or `-Oz` options on GCC or Clang, this is defined to 1 by default,
+ * otherwise it is defined to 0.
+ *
+ * Most of these size optimizations can be controlled manually.
+ *
+ * This is a number from 0-2.
+ *  - `XXH_SIZE_OPT` == 0: Default. xxHash makes no size optimizations. Speed
+ *    comes first.
+ *  - `XXH_SIZE_OPT` == 1: Default for `-Os` and `-Oz`. xxHash is more
+ *    conservative and disables hacks that increase code size. It implies the
+ *    options @ref XXH_NO_INLINE_HINTS == 1, @ref XXH_FORCE_ALIGN_CHECK == 0,
+ *    and @ref XXH3_NEON_LANES == 8 if they are not already defined.
+ *  - `XXH_SIZE_OPT` == 2: xxHash tries to make itself as small as possible.
+ *    Performance may cry. For example, the single shot functions just use the
+ *    streaming API.
+ */
+#  define XXH_SIZE_OPT 0
+
+/*!
+ * @def XXH_FORCE_ALIGN_CHECK
+ * @brief If defined to non-zero, adds a special path for aligned inputs (XXH32()
+ * and XXH64() only).
+ *
+ * This is an important performance trick for architectures without decent
+ * unaligned memory access performance.
+ *
+ * It checks for input alignment, and when conditions are met, uses a "fast
+ * path" employing direct 32-bit/64-bit reads, resulting in _dramatically
+ * faster_ read speed.
+ *
+ * The check costs one initial branch per hash, which is generally negligible,
+ * but not zero.
+ *
+ * Moreover, it's not useful to generate an additional code path if memory
+ * access uses the same instruction for both aligned and unaligned
+ * addresses (e.g. x86 and aarch64).
+ *
+ * In these cases, the alignment check can be removed by setting this macro to 0.
+ * Then the code will always use unaligned memory access.
+ * Align check is automatically disabled on x86, x64, ARM64, and some ARM chips
+ * which are platforms known to offer good unaligned memory accesses performance.
+ *
+ * It is also disabled by default when @ref XXH_SIZE_OPT >= 1.
+ *
+ * This option does not affect XXH3 (only XXH32 and XXH64).
+ */
+#  define XXH_FORCE_ALIGN_CHECK 0
+
+/*!
+ * @def XXH_NO_INLINE_HINTS
+ * @brief When non-zero, sets all functions to `static`.
+ *
+ * By default, xxHash tries to force the compiler to inline almost all internal
+ * functions.
+ *
+ * This can usually improve performance due to reduced jumping and improved
+ * constant folding, but significantly increases the size of the binary which
+ * might not be favorable.
+ *
+ * Additionally, sometimes the forced inlining can be detrimental to performance,
+ * depending on the architecture.
+ *
+ * XXH_NO_INLINE_HINTS marks all internal functions as static, giving the
+ * compiler full control on whether to inline or not.
+ *
+ * When not optimizing (-O0), using `-fno-inline` with GCC or Clang, or if
+ * @ref XXH_SIZE_OPT >= 1, this will automatically be defined.
+ */
+#  define XXH_NO_INLINE_HINTS 0
+
+/*!
+ * @def XXH3_INLINE_SECRET
+ * @brief Determines whether to inline the XXH3 withSecret code.
+ *
+ * When the secret size is known, the compiler can improve the performance
+ * of XXH3_64bits_withSecret() and XXH3_128bits_withSecret().
+ *
+ * However, if the secret size is not known, it doesn't have any benefit. This
+ * happens when xxHash is compiled into a global symbol. Therefore, if
+ * @ref XXH_INLINE_ALL is *not* defined, this will be defined to 0.
+ *
+ * Additionally, this defaults to 0 on GCC 12+, which has an issue with function pointers
+ * that are *sometimes* force inline on -Og, and it is impossible to automatically
+ * detect this optimization level.
+ */
+#  define XXH3_INLINE_SECRET 0
+
+/*!
+ * @def XXH32_ENDJMP
+ * @brief Whether to use a jump for `XXH32_finalize`.
+ *
+ * For performance, `XXH32_finalize` uses multiple branches in the finalizer.
+ * This is generally preferable for performance,
+ * but depending on exact architecture, a jmp may be preferable.
+ *
+ * This setting is only possibly making a difference for very small inputs.
+ */
+#  define XXH32_ENDJMP 0
+
+/*!
+ * @internal
+ * @brief Redefines old internal names.
+ *
+ * For compatibility with code that uses xxHash's internals before the names
+ * were changed to improve namespacing. There is no other reason to use this.
+ */
+#  define XXH_OLD_NAMES
+#  undef XXH_OLD_NAMES /* don't actually use, it is ugly. */
+
+/*!
+ * @def XXH_NO_STREAM
+ * @brief Disables the streaming API.
+ *
+ * When xxHash is not inlined and the streaming functions are not used, disabling
+ * the streaming functions can improve code size significantly, especially with
+ * the @ref XXH3_family which tends to make constant folded copies of itself.
+ */
+#  define XXH_NO_STREAM
+#  undef XXH_NO_STREAM /* don't actually */
+#endif /* XXH_DOXYGEN */
+/*!
+ * @}
+ */
+
+#ifndef XXH_FORCE_MEMORY_ACCESS   /* can be defined externally, on command line for example */
+   /* prefer __packed__ structures (method 1) for GCC
+    * < ARMv7 with unaligned access (e.g. Raspbian armhf) still uses byte shifting, so we use memcpy
+    * which for some reason does unaligned loads. */
+#  if defined(__GNUC__) && !(defined(__ARM_ARCH) && __ARM_ARCH < 7 && defined(__ARM_FEATURE_UNALIGNED))
+#    define XXH_FORCE_MEMORY_ACCESS 1
+#  endif
+#endif
+
+#ifndef XXH_SIZE_OPT
+   /* default to 1 for -Os or -Oz */
+#  if (defined(__GNUC__) || defined(__clang__)) && defined(__OPTIMIZE_SIZE__)
+#    define XXH_SIZE_OPT 1
+#  else
+#    define XXH_SIZE_OPT 0
+#  endif
+#endif
+
+#ifndef XXH_FORCE_ALIGN_CHECK  /* can be defined externally */
+   /* don't check on sizeopt, x86, aarch64, or arm when unaligned access is available */
+#  if XXH_SIZE_OPT >= 1 || \
+      defined(__i386)  || defined(__x86_64__) || defined(__aarch64__) || defined(__ARM_FEATURE_UNALIGNED) \
+   || defined(_M_IX86) || defined(_M_X64)     || defined(_M_ARM64)    || defined(_M_ARM) /* visual */
+#    define XXH_FORCE_ALIGN_CHECK 0
+#  else
+#    define XXH_FORCE_ALIGN_CHECK 1
+#  endif
+#endif
+
+#ifndef XXH_NO_INLINE_HINTS
+#  if XXH_SIZE_OPT >= 1 || defined(__NO_INLINE__)  /* -O0, -fno-inline */
+#    define XXH_NO_INLINE_HINTS 1
+#  else
+#    define XXH_NO_INLINE_HINTS 0
+#  endif
+#endif
+
+#ifndef XXH3_INLINE_SECRET
+#  if (defined(__GNUC__) && !defined(__clang__) && __GNUC__ >= 12) \
+     || !defined(XXH_INLINE_ALL)
+#    define XXH3_INLINE_SECRET 0
+#  else
+#    define XXH3_INLINE_SECRET 1
+#  endif
+#endif
+
+#ifndef XXH32_ENDJMP
+/* generally preferable for performance */
+#  define XXH32_ENDJMP 0
+#endif
+
+/*!
+ * @defgroup impl Implementation
+ * @{
+ */
+
+
+/* *************************************
+*  Includes & Memory related functions
+***************************************/
+#if !defined(XXH_CUSTOM_MALLOC)
+#if defined(XXH_NO_STREAM)
+/* nothing */
+#elif defined(XXH_NO_STDLIB)
+
+/* When requesting to disable any mention of stdlib,
+ * the library loses the ability to invoked malloc / free.
+ * In practice, it means that functions like `XXH*_createState()`
+ * will always fail, and return NULL.
+ * This flag is useful in situations where
+ * xxhash.h is integrated into some kernel, embedded or limited environment
+ * without access to dynamic allocation.
+ */
+
+static XXH_CONSTF void* XXH_malloc(size_t s) { (void)s; return NULL; }
+static void XXH_free(void* p) { (void)p; }
+
+#else
+
+/*
+ * Modify the local functions below should you wish to use
+ * different memory routines for malloc() and free()
+ */
+#include <stdlib.h>
+
+/*!
+ * @internal
+ * @brief Modify this function to use a different routine than malloc().
+ */
+static XXH_MALLOCF void* XXH_malloc(size_t s) { return malloc(s); }
+
+/*!
+ * @internal
+ * @brief Modify this function to use a different routine than free().
+ */
+static void XXH_free(void* p) { free(p); }
+
+#endif  /* XXH_NO_STDLIB */
+#endif  /* !XXH_CUSTOM_MALLOC */
+
+#include <string.h>
+
+/*!
+ * @internal
+ * @brief Modify this function to use a different routine than memcpy().
+ */
+static void* XXH_memcpy(void* dest, const void* src, size_t size)
+{
+    return memcpy(dest,src,size);
+}
+
+#include <limits.h>   /* ULLONG_MAX */
+
+
+/* *************************************
+*  Compiler Specific Options
+***************************************/
+#ifdef _MSC_VER /* Visual Studio warning fix */
+#  pragma warning(disable : 4127) /* disable: C4127: conditional expression is constant */
+#endif
+
+#if XXH_NO_INLINE_HINTS  /* disable inlining hints */
+#  if defined(__GNUC__) || defined(__clang__)
+#    define XXH_FORCE_INLINE static __attribute__((__unused__))
+#  else
+#    define XXH_FORCE_INLINE static
+#  endif
+#  define XXH_NO_INLINE static
+/* enable inlining hints */
+#elif defined(__GNUC__) || defined(__clang__)
+#  define XXH_FORCE_INLINE static __inline__ __attribute__((__always_inline__, __unused__))
+#  define XXH_NO_INLINE static __attribute__((__noinline__))
+#elif defined(_MSC_VER)  /* Visual Studio */
+#  define XXH_FORCE_INLINE static __forceinline
+#  define XXH_NO_INLINE static __declspec(noinline)
+#elif defined (__cplusplus) \
+  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L))   /* C99 */
+#  define XXH_FORCE_INLINE static inline
+#  define XXH_NO_INLINE static
+#else
+#  define XXH_FORCE_INLINE static
+#  define XXH_NO_INLINE static
+#endif
+
+#if defined(XXH_INLINE_ALL)
+#  define XXH_STATIC XXH_FORCE_INLINE
+#else
+#  define XXH_STATIC static
+#endif
+
+#if XXH3_INLINE_SECRET
+#  define XXH3_WITH_SECRET_INLINE XXH_FORCE_INLINE
+#else
+#  define XXH3_WITH_SECRET_INLINE XXH_NO_INLINE
+#endif
+
+#if ((defined(sun) || defined(__sun)) && __cplusplus) /* Solaris includes __STDC_VERSION__ with C++. Tested with GCC 5.5 */
+#  define XXH_RESTRICT   /* disable */
+#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* >= C99 */
+#  define XXH_RESTRICT   restrict
+#elif (defined (__GNUC__) && ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))) \
+   || (defined (__clang__)) \
+   || (defined (_MSC_VER) && (_MSC_VER >= 1400)) \
+   || (defined (__INTEL_COMPILER) && (__INTEL_COMPILER >= 1300))
+/*
+ * There are a LOT more compilers that recognize __restrict but this
+ * covers the major ones.
+ */
+#  define XXH_RESTRICT   __restrict
+#else
+#  define XXH_RESTRICT   /* disable */
+#endif
+
+/* *************************************
+*  Debug
+***************************************/
+/*!
+ * @ingroup tuning
+ * @def XXH_DEBUGLEVEL
+ * @brief Sets the debugging level.
+ *
+ * XXH_DEBUGLEVEL is expected to be defined externally, typically via the
+ * compiler's command line options. The value must be a number.
+ */
+#ifndef XXH_DEBUGLEVEL
+#  ifdef DEBUGLEVEL /* backwards compat */
+#    define XXH_DEBUGLEVEL DEBUGLEVEL
+#  else
+#    define XXH_DEBUGLEVEL 0
+#  endif
+#endif
+
+#if (XXH_DEBUGLEVEL>=1)
+#  include <assert.h>   /* note: can still be disabled with NDEBUG */
+#  define XXH_ASSERT(c)   assert(c)
+#else
+#  if defined(__INTEL_COMPILER)
+#    define XXH_ASSERT(c)   XXH_ASSUME((unsigned char) (c))
+#  else
+#    define XXH_ASSERT(c)   XXH_ASSUME(c)
+#  endif
+#endif
+
+/* note: use after variable declarations */
+#ifndef XXH_STATIC_ASSERT
+#  if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)    /* C11 */
+#    define XXH_STATIC_ASSERT_WITH_MESSAGE(c,m) do { _Static_assert((c),m); } while(0)
+#  elif defined(__cplusplus) && (__cplusplus >= 201103L)            /* C++11 */
+#    define XXH_STATIC_ASSERT_WITH_MESSAGE(c,m) do { static_assert((c),m); } while(0)
+#  else
+#    define XXH_STATIC_ASSERT_WITH_MESSAGE(c,m) do { struct xxh_sa { char x[(c) ? 1 : -1]; }; } while(0)
+#  endif
+#  define XXH_STATIC_ASSERT(c) XXH_STATIC_ASSERT_WITH_MESSAGE((c),#c)
+#endif
+
+/*!
+ * @internal
+ * @def XXH_COMPILER_GUARD(var)
+ * @brief Used to prevent unwanted optimizations for @p var.
+ *
+ * It uses an empty GCC inline assembly statement with a register constraint
+ * which forces @p var into a general purpose register (eg eax, ebx, ecx
+ * on x86) and marks it as modified.
+ *
+ * This is used in a few places to avoid unwanted autovectorization (e.g.
+ * XXH32_round()). All vectorization we want is explicit via intrinsics,
+ * and _usually_ isn't wanted elsewhere.
+ *
+ * We also use it to prevent unwanted constant folding for AArch64 in
+ * XXH3_initCustomSecret_scalar().
+ */
+#if defined(__GNUC__) || defined(__clang__)
+#  define XXH_COMPILER_GUARD(var) __asm__("" : "+r" (var))
+#else
+#  define XXH_COMPILER_GUARD(var) ((void)0)
+#endif
+
+/* Specifically for NEON vectors which use the "w" constraint, on
+ * Clang. */
+#if defined(__clang__) && defined(__ARM_ARCH) && !defined(__wasm__)
+#  define XXH_COMPILER_GUARD_CLANG_NEON(var) __asm__("" : "+w" (var))
+#else
+#  define XXH_COMPILER_GUARD_CLANG_NEON(var) ((void)0)
+#endif
+
+/* *************************************
+*  Basic Types
+***************************************/
+#if !defined (__VMS) \
+ && (defined (__cplusplus) \
+ || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+#   ifdef _AIX
+#     include <inttypes.h>
+#   else
+#     include <stdint.h>
+#   endif
+    typedef uint8_t xxh_u8;
+#else
+    typedef unsigned char xxh_u8;
+#endif
+typedef XXH32_hash_t xxh_u32;
+
+#ifdef XXH_OLD_NAMES
+#  warning "XXH_OLD_NAMES is planned to be removed starting v0.9. If the program depends on it, consider moving away from it by employing newer type names directly"
+#  define BYTE xxh_u8
+#  define U8   xxh_u8
+#  define U32  xxh_u32
+#endif
+
+/* ***   Memory access   *** */
+
+/*!
+ * @internal
+ * @fn xxh_u32 XXH_read32(const void* ptr)
+ * @brief Reads an unaligned 32-bit integer from @p ptr in native endianness.
+ *
+ * Affected by @ref XXH_FORCE_MEMORY_ACCESS.
+ *
+ * @param ptr The pointer to read from.
+ * @return The 32-bit native endian integer from the bytes at @p ptr.
+ */
+
+/*!
+ * @internal
+ * @fn xxh_u32 XXH_readLE32(const void* ptr)
+ * @brief Reads an unaligned 32-bit little endian integer from @p ptr.
+ *
+ * Affected by @ref XXH_FORCE_MEMORY_ACCESS.
+ *
+ * @param ptr The pointer to read from.
+ * @return The 32-bit little endian integer from the bytes at @p ptr.
+ */
+
+/*!
+ * @internal
+ * @fn xxh_u32 XXH_readBE32(const void* ptr)
+ * @brief Reads an unaligned 32-bit big endian integer from @p ptr.
+ *
+ * Affected by @ref XXH_FORCE_MEMORY_ACCESS.
+ *
+ * @param ptr The pointer to read from.
+ * @return The 32-bit big endian integer from the bytes at @p ptr.
+ */
+
+/*!
+ * @internal
+ * @fn xxh_u32 XXH_readLE32_align(const void* ptr, XXH_alignment align)
+ * @brief Like @ref XXH_readLE32(), but has an option for aligned reads.
+ *
+ * Affected by @ref XXH_FORCE_MEMORY_ACCESS.
+ * Note that when @ref XXH_FORCE_ALIGN_CHECK == 0, the @p align parameter is
+ * always @ref XXH_alignment::XXH_unaligned.
+ *
+ * @param ptr The pointer to read from.
+ * @param align Whether @p ptr is aligned.
+ * @pre
+ *   If @p align == @ref XXH_alignment::XXH_aligned, @p ptr must be 4 byte
+ *   aligned.
+ * @return The 32-bit little endian integer from the bytes at @p ptr.
+ */
+
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+/*
+ * Manual byteshift. Best for old compilers which don't inline memcpy.
+ * We actually directly use XXH_readLE32 and XXH_readBE32.
+ */
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
+
+/*
+ * Force direct memory access. Only works on CPU which support unaligned memory
+ * access in hardware.
+ */
+static xxh_u32 XXH_read32(const void* memPtr) { return *(const xxh_u32*) memPtr; }
+
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
+
+/*
+ * __attribute__((aligned(1))) is supported by gcc and clang. Originally the
+ * documentation claimed that it only increased the alignment, but actually it
+ * can decrease it on gcc, clang, and icc:
+ * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=69502,
+ * https://gcc.godbolt.org/z/xYez1j67Y.
+ */
+#ifdef XXH_OLD_NAMES
+typedef union { xxh_u32 u32; } __attribute__((__packed__)) unalign;
+#endif
+static xxh_u32 XXH_read32(const void* ptr)
+{
+    typedef __attribute__((__aligned__(1))) xxh_u32 xxh_unalign32;
+    return *((const xxh_unalign32*)ptr);
+}
+
+#else
+
+/*
+ * Portable and safe solution. Generally efficient.
+ * see: https://fastcompression.blogspot.com/2015/08/accessing-unaligned-memory.html
+ */
+static xxh_u32 XXH_read32(const void* memPtr)
+{
+    xxh_u32 val;
+    XXH_memcpy(&val, memPtr, sizeof(val));
+    return val;
+}
+
+#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
+
+
+/* ***   Endianness   *** */
+
+/*!
+ * @ingroup tuning
+ * @def XXH_CPU_LITTLE_ENDIAN
+ * @brief Whether the target is little endian.
+ *
+ * Defined to 1 if the target is little endian, or 0 if it is big endian.
+ * It can be defined externally, for example on the compiler command line.
+ *
+ * If it is not defined,
+ * a runtime check (which is usually constant folded) is used instead.
+ *
+ * @note
+ *   This is not necessarily defined to an integer constant.
+ *
+ * @see XXH_isLittleEndian() for the runtime check.
+ */
+#ifndef XXH_CPU_LITTLE_ENDIAN
+/*
+ * Try to detect endianness automatically, to avoid the nonstandard behavior
+ * in `XXH_isLittleEndian()`
+ */
+#  if defined(_WIN32) /* Windows is always little endian */ \
+     || defined(__LITTLE_ENDIAN__) \
+     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
+#    define XXH_CPU_LITTLE_ENDIAN 1
+#  elif defined(__BIG_ENDIAN__) \
+     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+#    define XXH_CPU_LITTLE_ENDIAN 0
+#  else
+/*!
+ * @internal
+ * @brief Runtime check for @ref XXH_CPU_LITTLE_ENDIAN.
+ *
+ * Most compilers will constant fold this.
+ */
+static int XXH_isLittleEndian(void)
+{
+    /*
+     * Portable and well-defined behavior.
+     * Don't use static: it is detrimental to performance.
+     */
+    const union { xxh_u32 u; xxh_u8 c[4]; } one = { 1 };
+    return one.c[0];
+}
+#   define XXH_CPU_LITTLE_ENDIAN   XXH_isLittleEndian()
+#  endif
+#endif
+
+
+
+
+/* ****************************************
+*  Compiler-specific Functions and Macros
+******************************************/
+#define XXH_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
+
+#ifdef __has_builtin
+#  define XXH_HAS_BUILTIN(x) __has_builtin(x)
+#else
+#  define XXH_HAS_BUILTIN(x) 0
+#endif
+
+
+
+/*
+ * C23 and future versions have standard "unreachable()".
+ * Once it has been implemented reliably we can add it as an
+ * additional case:
+ *
+ * ```
+ * #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= XXH_C23_VN)
+ * #  include <stddef.h>
+ * #  ifdef unreachable
+ * #    define XXH_UNREACHABLE() unreachable()
+ * #  endif
+ * #endif
+ * ```
+ *
+ * Note C++23 also has std::unreachable() which can be detected
+ * as follows:
+ * ```
+ * #if defined(__cpp_lib_unreachable) && (__cpp_lib_unreachable >= 202202L)
+ * #  include <utility>
+ * #  define XXH_UNREACHABLE() std::unreachable()
+ * #endif
+ * ```
+ * NB: `__cpp_lib_unreachable` is defined in the `<version>` header.
+ * We don't use that as including `<utility>` in `extern "C"` blocks
+ * doesn't work on GCC12
+ */
+
+#if XXH_HAS_BUILTIN(__builtin_unreachable)
+#  define XXH_UNREACHABLE() __builtin_unreachable()
+
+#elif defined(_MSC_VER)
+#  define XXH_UNREACHABLE() __assume(0)
+
+#else
+#  define XXH_UNREACHABLE()
+#endif
+
+#if XXH_HAS_BUILTIN(__builtin_assume)
+#  define XXH_ASSUME(c) __builtin_assume(c)
+#else
+#  define XXH_ASSUME(c) if (!(c)) { XXH_UNREACHABLE(); }
+#endif
+
+/*!
+ * @internal
+ * @def XXH_rotl32(x,r)
+ * @brief 32-bit rotate left.
+ *
+ * @param x The 32-bit integer to be rotated.
+ * @param r The number of bits to rotate.
+ * @pre
+ *   @p r > 0 && @p r < 32
+ * @note
+ *   @p x and @p r may be evaluated multiple times.
+ * @return The rotated result.
+ */
+#if !defined(NO_CLANG_BUILTIN) && XXH_HAS_BUILTIN(__builtin_rotateleft32) \
+                               && XXH_HAS_BUILTIN(__builtin_rotateleft64)
+#  define XXH_rotl32 __builtin_rotateleft32
+#  define XXH_rotl64 __builtin_rotateleft64
+#elif XXH_HAS_BUILTIN(__builtin_stdc_rotate_left)
+#  define XXH_rotl32 __builtin_stdc_rotate_left
+#  define XXH_rotl64 __builtin_stdc_rotate_left
+/* Note: although _rotl exists for minGW (GCC under windows), performance seems poor */
+#elif defined(_MSC_VER)
+#  define XXH_rotl32(x,r) _rotl(x,r)
+#  define XXH_rotl64(x,r) _rotl64(x,r)
+#else
+#  define XXH_rotl32(x,r) (((x) << (r)) | ((x) >> (32 - (r))))
+#  define XXH_rotl64(x,r) (((x) << (r)) | ((x) >> (64 - (r))))
+#endif
+
+/*!
+ * @internal
+ * @fn xxh_u32 XXH_swap32(xxh_u32 x)
+ * @brief A 32-bit byteswap.
+ *
+ * @param x The 32-bit integer to byteswap.
+ * @return @p x, byteswapped.
+ */
+#if defined(_MSC_VER) && !defined(__clang__)   /* Visual Studio */
+#  define XXH_swap32 _byteswap_ulong
+#elif XXH_GCC_VERSION >= 403 || XXH_HAS_BUILTIN(__builtin_bswap32)
+#  define XXH_swap32 __builtin_bswap32
+#else
+static xxh_u32 XXH_swap32 (xxh_u32 x)
+{
+    return  ((x << 24) & 0xff000000 ) |
+            ((x <<  8) & 0x00ff0000 ) |
+            ((x >>  8) & 0x0000ff00 ) |
+            ((x >> 24) & 0x000000ff );
+}
+#endif
+
+
+/* ***************************
+*  Memory reads
+*****************************/
+
+/*!
+ * @internal
+ * @brief Enum to indicate whether a pointer is aligned.
+ */
+typedef enum {
+    XXH_aligned,  /*!< Aligned */
+    XXH_unaligned /*!< Possibly unaligned */
+} XXH_alignment;
+
+/*
+ * XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load.
+ *
+ * This is ideal for older compilers which don't inline memcpy.
+ */
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+
+XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[0]
+         | ((xxh_u32)bytePtr[1] << 8)
+         | ((xxh_u32)bytePtr[2] << 16)
+         | ((xxh_u32)bytePtr[3] << 24);
+}
+
+XXH_FORCE_INLINE xxh_u32 XXH_readBE32(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[3]
+         | ((xxh_u32)bytePtr[2] << 8)
+         | ((xxh_u32)bytePtr[1] << 16)
+         | ((xxh_u32)bytePtr[0] << 24);
+}
+
+#else
+XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));
+}
+
+static xxh_u32 XXH_readBE32(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap32(XXH_read32(ptr)) : XXH_read32(ptr);
+}
+#endif
+
+XXH_FORCE_INLINE xxh_u32
+XXH_readLE32_align(const void* ptr, XXH_alignment align)
+{
+    if (align==XXH_unaligned) {
+        return XXH_readLE32(ptr);
+    } else {
+        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u32*)ptr : XXH_swap32(*(const xxh_u32*)ptr);
+    }
+}
+
+
+/* *************************************
+*  Misc
+***************************************/
+/*! @ingroup public */
+XXH_PUBLIC_API unsigned XXH_versionNumber (void) { return XXH_VERSION_NUMBER; }
+
+
+/* *******************************************************************
+*  32-bit hash functions
+*********************************************************************/
+/*!
+ * @}
+ * @defgroup XXH32_impl XXH32 implementation
+ * @ingroup impl
+ *
+ * Details on the XXH32 implementation.
+ * @{
+ */
+ /* #define instead of static const, to be used as initializers */
+#define XXH_PRIME32_1  0x9E3779B1U  /*!< 0b10011110001101110111100110110001 */
+#define XXH_PRIME32_2  0x85EBCA77U  /*!< 0b10000101111010111100101001110111 */
+#define XXH_PRIME32_3  0xC2B2AE3DU  /*!< 0b11000010101100101010111000111101 */
+#define XXH_PRIME32_4  0x27D4EB2FU  /*!< 0b00100111110101001110101100101111 */
+#define XXH_PRIME32_5  0x165667B1U  /*!< 0b00010110010101100110011110110001 */
+
+#ifdef XXH_OLD_NAMES
+#  define PRIME32_1 XXH_PRIME32_1
+#  define PRIME32_2 XXH_PRIME32_2
+#  define PRIME32_3 XXH_PRIME32_3
+#  define PRIME32_4 XXH_PRIME32_4
+#  define PRIME32_5 XXH_PRIME32_5
+#endif
+
+/*!
+ * @internal
+ * @brief Normal stripe processing routine.
+ *
+ * This shuffles the bits so that any bit from @p input impacts several bits in
+ * @p acc.
+ *
+ * @param acc The accumulator lane.
+ * @param input The stripe of input to mix.
+ * @return The mixed accumulator lane.
+ */
+static xxh_u32 XXH32_round(xxh_u32 acc, xxh_u32 input)
+{
+    acc += input * XXH_PRIME32_2;
+    acc  = XXH_rotl32(acc, 13);
+    acc *= XXH_PRIME32_1;
+#if (defined(__SSE4_1__) || defined(__aarch64__) || defined(__wasm_simd128__)) && !defined(XXH_ENABLE_AUTOVECTORIZE)
+    /*
+     * UGLY HACK:
+     * A compiler fence is used to prevent GCC and Clang from
+     * autovectorizing the XXH32 loop (pragmas and attributes don't work for some
+     * reason) without globally disabling SSE4.1.
+     *
+     * The reason we want to avoid vectorization is because despite working on
+     * 4 integers at a time, there are multiple factors slowing XXH32 down on
+     * SSE4:
+     * - There's a ridiculous amount of lag from pmulld (10 cycles of latency on
+     *   newer chips!) making it slightly slower to multiply four integers at
+     *   once compared to four integers independently. Even when pmulld was
+     *   fastest, Sandy/Ivy Bridge, it is still not worth it to go into SSE
+     *   just to multiply unless doing a long operation.
+     *
+     * - Four instructions are required to rotate,
+     *      movqda tmp,  v // not required with VEX encoding
+     *      pslld  tmp, 13 // tmp <<= 13
+     *      psrld  v,   19 // x >>= 19
+     *      por    v,  tmp // x |= tmp
+     *   compared to one for scalar:
+     *      roll   v, 13    // reliably fast across the board
+     *      shldl  v, v, 13 // Sandy Bridge and later prefer this for some reason
+     *
+     * - Instruction level parallelism is actually more beneficial here because
+     *   the SIMD actually serializes this operation: While v1 is rotating, v2
+     *   can load data, while v3 can multiply. SSE forces them to operate
+     *   together.
+     *
+     * This is also enabled on AArch64, as Clang is *very aggressive* in vectorizing
+     * the loop. NEON is only faster on the A53, and with the newer cores, it is less
+     * than half the speed.
+     *
+     * Additionally, this is used on WASM SIMD128 because it JITs to the same
+     * SIMD instructions and has the same issue.
+     */
+    XXH_COMPILER_GUARD(acc);
+#endif
+    return acc;
+}
+
+/*!
+ * @internal
+ * @brief Mixes all bits to finalize the hash.
+ *
+ * The final mix ensures that all input bits have a chance to impact any bit in
+ * the output digest, resulting in an unbiased distribution.
+ *
+ * @param hash The hash to avalanche.
+ * @return The avalanched hash.
+ */
+static xxh_u32 XXH32_avalanche(xxh_u32 hash)
+{
+    hash ^= hash >> 15;
+    hash *= XXH_PRIME32_2;
+    hash ^= hash >> 13;
+    hash *= XXH_PRIME32_3;
+    hash ^= hash >> 16;
+    return hash;
+}
+
+#define XXH_get32bits(p) XXH_readLE32_align(p, align)
+
+/*!
+ * @internal
+ * @brief Sets up the initial accumulator state for XXH32().
+ */
+XXH_FORCE_INLINE void
+XXH32_initAccs(xxh_u32 *acc, xxh_u32 seed)
+{
+    XXH_ASSERT(acc != NULL);
+    acc[0] = seed + XXH_PRIME32_1 + XXH_PRIME32_2;
+    acc[1] = seed + XXH_PRIME32_2;
+    acc[2] = seed + 0;
+    acc[3] = seed - XXH_PRIME32_1;
+}
+
+/*!
+ * @internal
+ * @brief Consumes a block of data for XXH32().
+ *
+ * @return the end input pointer.
+ */
+XXH_FORCE_INLINE const xxh_u8 *
+XXH32_consumeLong(
+    xxh_u32 *XXH_RESTRICT acc,
+    xxh_u8 const *XXH_RESTRICT input,
+    size_t len,
+    XXH_alignment align
+)
+{
+    const xxh_u8* const bEnd = input + len;
+    const xxh_u8* const limit = bEnd - 15;
+    XXH_ASSERT(acc != NULL);
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(len >= 16);
+    do {
+        acc[0] = XXH32_round(acc[0], XXH_get32bits(input)); input += 4;
+        acc[1] = XXH32_round(acc[1], XXH_get32bits(input)); input += 4;
+        acc[2] = XXH32_round(acc[2], XXH_get32bits(input)); input += 4;
+        acc[3] = XXH32_round(acc[3], XXH_get32bits(input)); input += 4;
+    } while (input < limit);
+
+    return input;
+}
+
+/*!
+ * @internal
+ * @brief Merges the accumulator lanes together for XXH32()
+ */
+XXH_FORCE_INLINE XXH_PUREF xxh_u32
+XXH32_mergeAccs(const xxh_u32 *acc)
+{
+    XXH_ASSERT(acc != NULL);
+    return XXH_rotl32(acc[0], 1)  + XXH_rotl32(acc[1], 7)
+         + XXH_rotl32(acc[2], 12) + XXH_rotl32(acc[3], 18);
+}
+
+/*!
+ * @internal
+ * @brief Processes the last 0-15 bytes of @p ptr.
+ *
+ * There may be up to 15 bytes remaining to consume from the input.
+ * This final stage will digest them to ensure that all input bytes are present
+ * in the final mix.
+ *
+ * @param hash The hash to finalize.
+ * @param ptr The pointer to the remaining input.
+ * @param len The remaining length, modulo 16.
+ * @param align Whether @p ptr is aligned.
+ * @return The finalized hash.
+ * @see XXH64_finalize().
+ */
+static XXH_PUREF xxh_u32
+XXH32_finalize(xxh_u32 hash, const xxh_u8* ptr, size_t len, XXH_alignment align)
+{
+#define XXH_PROCESS1 do {                             \
+    hash += (*ptr++) * XXH_PRIME32_5;                 \
+    hash = XXH_rotl32(hash, 11) * XXH_PRIME32_1;      \
+} while (0)
+
+#define XXH_PROCESS4 do {                             \
+    hash += XXH_get32bits(ptr) * XXH_PRIME32_3;       \
+    ptr += 4;                                         \
+    hash  = XXH_rotl32(hash, 17) * XXH_PRIME32_4;     \
+} while (0)
+
+    if (ptr==NULL) XXH_ASSERT(len == 0);
+
+    /* Compact rerolled version; generally faster */
+    if (!XXH32_ENDJMP) {
+        len &= 15;
+        while (len >= 4) {
+            XXH_PROCESS4;
+            len -= 4;
+        }
+        while (len > 0) {
+            XXH_PROCESS1;
+            --len;
+        }
+        return XXH32_avalanche(hash);
+    } else {
+         switch(len&15) /* or switch(bEnd - p) */ {
+           case 12:      XXH_PROCESS4;
+                         XXH_FALLTHROUGH;  /* fallthrough */
+           case 8:       XXH_PROCESS4;
+                         XXH_FALLTHROUGH;  /* fallthrough */
+           case 4:       XXH_PROCESS4;
+                         return XXH32_avalanche(hash);
+
+           case 13:      XXH_PROCESS4;
+                         XXH_FALLTHROUGH;  /* fallthrough */
+           case 9:       XXH_PROCESS4;
+                         XXH_FALLTHROUGH;  /* fallthrough */
+           case 5:       XXH_PROCESS4;
+                         XXH_PROCESS1;
+                         return XXH32_avalanche(hash);
+
+           case 14:      XXH_PROCESS4;
+                         XXH_FALLTHROUGH;  /* fallthrough */
+           case 10:      XXH_PROCESS4;
+                         XXH_FALLTHROUGH;  /* fallthrough */
+           case 6:       XXH_PROCESS4;
+                         XXH_PROCESS1;
+                         XXH_PROCESS1;
+                         return XXH32_avalanche(hash);
+
+           case 15:      XXH_PROCESS4;
+                         XXH_FALLTHROUGH;  /* fallthrough */
+           case 11:      XXH_PROCESS4;
+                         XXH_FALLTHROUGH;  /* fallthrough */
+           case 7:       XXH_PROCESS4;
+                         XXH_FALLTHROUGH;  /* fallthrough */
+           case 3:       XXH_PROCESS1;
+                         XXH_FALLTHROUGH;  /* fallthrough */
+           case 2:       XXH_PROCESS1;
+                         XXH_FALLTHROUGH;  /* fallthrough */
+           case 1:       XXH_PROCESS1;
+                         XXH_FALLTHROUGH;  /* fallthrough */
+           case 0:       return XXH32_avalanche(hash);
+        }
+        XXH_ASSERT(0);
+        return hash;   /* reaching this point is deemed impossible */
+    }
+}
+
+#ifdef XXH_OLD_NAMES
+#  define PROCESS1 XXH_PROCESS1
+#  define PROCESS4 XXH_PROCESS4
+#else
+#  undef XXH_PROCESS1
+#  undef XXH_PROCESS4
+#endif
+
+/*!
+ * @internal
+ * @brief The implementation for @ref XXH32().
+ *
+ * @param input , len , seed Directly passed from @ref XXH32().
+ * @param align Whether @p input is aligned.
+ * @return The calculated hash.
+ */
+XXH_FORCE_INLINE XXH_PUREF xxh_u32
+XXH32_endian_align(const xxh_u8* input, size_t len, xxh_u32 seed, XXH_alignment align)
+{
+    xxh_u32 h32;
+
+    if (input==NULL) XXH_ASSERT(len == 0);
+
+    if (len>=16) {
+        xxh_u32 acc[4];
+        XXH32_initAccs(acc, seed);
+
+        input = XXH32_consumeLong(acc, input, len, align);
+
+        h32 = XXH32_mergeAccs(acc);
+    } else {
+        h32  = seed + XXH_PRIME32_5;
+    }
+
+    h32 += (xxh_u32)len;
+
+    return XXH32_finalize(h32, input, len&15, align);
+}
+
+/*! @ingroup XXH32_family */
+XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t len, XXH32_hash_t seed)
+{
+#if !defined(XXH_NO_STREAM) && XXH_SIZE_OPT >= 2
+    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
+    XXH32_state_t state;
+    XXH32_reset(&state, seed);
+    XXH32_update(&state, (const xxh_u8*)input, len);
+    return XXH32_digest(&state);
+#else
+    if (XXH_FORCE_ALIGN_CHECK) {
+        if ((((size_t)input) & 3) == 0) {   /* Input is 4-bytes aligned, leverage the speed benefit */
+            return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
+    }   }
+
+    return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
+#endif
+}
+
+
+
+/*******   Hash streaming   *******/
+#ifndef XXH_NO_STREAM
+/*! @ingroup XXH32_family */
+XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void)
+{
+    return (XXH32_state_t*)XXH_malloc(sizeof(XXH32_state_t));
+}
+/*! @ingroup XXH32_family */
+XXH_PUBLIC_API XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)
+{
+    XXH_free(statePtr);
+    return XXH_OK;
+}
+
+/*! @ingroup XXH32_family */
+XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dstState, const XXH32_state_t* srcState)
+{
+    XXH_memcpy(dstState, srcState, sizeof(*dstState));
+}
+
+/*! @ingroup XXH32_family */
+XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, XXH32_hash_t seed)
+{
+    XXH_ASSERT(statePtr != NULL);
+    memset(statePtr, 0, sizeof(*statePtr));
+    XXH32_initAccs(statePtr->acc, seed);
+    return XXH_OK;
+}
+
+
+/*! @ingroup XXH32_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH32_update(XXH32_state_t* state, const void* input, size_t len)
+{
+    if (input==NULL) {
+        XXH_ASSERT(len == 0);
+        return XXH_OK;
+    }
+
+    state->total_len_32 += (XXH32_hash_t)len;
+    state->large_len |= (XXH32_hash_t)((len>=16) | (state->total_len_32>=16));
+
+    XXH_ASSERT(state->bufferedSize < sizeof(state->buffer));
+    if (len < sizeof(state->buffer) - state->bufferedSize)  {   /* fill in tmp buffer */
+        XXH_memcpy(state->buffer + state->bufferedSize, input, len);
+        state->bufferedSize += (XXH32_hash_t)len;
+        return XXH_OK;
+    }
+
+    {   const xxh_u8* xinput = (const xxh_u8*)input;
+        const xxh_u8* const bEnd = xinput + len;
+
+        if (state->bufferedSize) {   /* non-empty buffer: complete first */
+            XXH_memcpy(state->buffer + state->bufferedSize, xinput, sizeof(state->buffer) - state->bufferedSize);
+            xinput += sizeof(state->buffer) - state->bufferedSize;
+            /* then process one round */
+            (void)XXH32_consumeLong(state->acc, state->buffer, sizeof(state->buffer), XXH_aligned);
+            state->bufferedSize = 0;
+        }
+
+        XXH_ASSERT(xinput <= bEnd);
+        if ((size_t)(bEnd - xinput) >= sizeof(state->buffer)) {
+            /* Process the remaining data */
+            xinput = XXH32_consumeLong(state->acc, xinput, (size_t)(bEnd - xinput), XXH_unaligned);
+        }
+
+        if (xinput < bEnd) {
+            /* Copy the leftover to the tmp buffer */
+            XXH_memcpy(state->buffer, xinput, (size_t)(bEnd-xinput));
+            state->bufferedSize = (unsigned)(bEnd-xinput);
+        }
+    }
+
+    return XXH_OK;
+}
+
+
+/*! @ingroup XXH32_family */
+XXH_PUBLIC_API XXH32_hash_t XXH32_digest(const XXH32_state_t* state)
+{
+    xxh_u32 h32;
+
+    if (state->large_len) {
+        h32 = XXH32_mergeAccs(state->acc);
+    } else {
+        h32 = state->acc[2] /* == seed */ + XXH_PRIME32_5;
+    }
+
+    h32 += state->total_len_32;
+
+    return XXH32_finalize(h32, state->buffer, state->bufferedSize, XXH_aligned);
+}
+#endif /* !XXH_NO_STREAM */
+
+/*******   Canonical representation   *******/
+
+/*! @ingroup XXH32_family */
+XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash)
+{
+    XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t));
+    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap32(hash);
+    XXH_memcpy(dst, &hash, sizeof(*dst));
+}
+/*! @ingroup XXH32_family */
+XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src)
+{
+    return XXH_readBE32(src);
+}
+
+
+#ifndef XXH_NO_LONG_LONG
+
+/* *******************************************************************
+*  64-bit hash functions
+*********************************************************************/
+/*!
+ * @}
+ * @ingroup impl
+ * @{
+ */
+/*******   Memory access   *******/
+
+typedef XXH64_hash_t xxh_u64;
+
+#ifdef XXH_OLD_NAMES
+#  define U64 xxh_u64
+#endif
+
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+/*
+ * Manual byteshift. Best for old compilers which don't inline memcpy.
+ * We actually directly use XXH_readLE64 and XXH_readBE64.
+ */
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
+
+/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
+static xxh_u64 XXH_read64(const void* memPtr)
+{
+    return *(const xxh_u64*) memPtr;
+}
+
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
+
+/*
+ * __attribute__((aligned(1))) is supported by gcc and clang. Originally the
+ * documentation claimed that it only increased the alignment, but actually it
+ * can decrease it on gcc, clang, and icc:
+ * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=69502,
+ * https://gcc.godbolt.org/z/xYez1j67Y.
+ */
+#ifdef XXH_OLD_NAMES
+typedef union { xxh_u32 u32; xxh_u64 u64; } __attribute__((__packed__)) unalign64;
+#endif
+static xxh_u64 XXH_read64(const void* ptr)
+{
+    typedef __attribute__((__aligned__(1))) xxh_u64 xxh_unalign64;
+    return *((const xxh_unalign64*)ptr);
+}
+
+#else
+
+/*
+ * Portable and safe solution. Generally efficient.
+ * see: https://fastcompression.blogspot.com/2015/08/accessing-unaligned-memory.html
+ */
+static xxh_u64 XXH_read64(const void* memPtr)
+{
+    xxh_u64 val;
+    XXH_memcpy(&val, memPtr, sizeof(val));
+    return val;
+}
+
+#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
+
+#if defined(_MSC_VER) && !defined(__clang__)     /* Visual Studio */
+#  define XXH_swap64 _byteswap_uint64
+#elif XXH_GCC_VERSION >= 403 || XXH_HAS_BUILTIN(__builtin_bswap64)
+#  define XXH_swap64 __builtin_bswap64
+#else
+static xxh_u64 XXH_swap64(xxh_u64 x)
+{
+    return  ((x << 56) & 0xff00000000000000ULL) |
+            ((x << 40) & 0x00ff000000000000ULL) |
+            ((x << 24) & 0x0000ff0000000000ULL) |
+            ((x << 8)  & 0x000000ff00000000ULL) |
+            ((x >> 8)  & 0x00000000ff000000ULL) |
+            ((x >> 24) & 0x0000000000ff0000ULL) |
+            ((x >> 40) & 0x000000000000ff00ULL) |
+            ((x >> 56) & 0x00000000000000ffULL);
+}
+#endif
+
+
+/* XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load. */
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+
+XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[0]
+         | ((xxh_u64)bytePtr[1] << 8)
+         | ((xxh_u64)bytePtr[2] << 16)
+         | ((xxh_u64)bytePtr[3] << 24)
+         | ((xxh_u64)bytePtr[4] << 32)
+         | ((xxh_u64)bytePtr[5] << 40)
+         | ((xxh_u64)bytePtr[6] << 48)
+         | ((xxh_u64)bytePtr[7] << 56);
+}
+
+XXH_FORCE_INLINE xxh_u64 XXH_readBE64(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[7]
+         | ((xxh_u64)bytePtr[6] << 8)
+         | ((xxh_u64)bytePtr[5] << 16)
+         | ((xxh_u64)bytePtr[4] << 24)
+         | ((xxh_u64)bytePtr[3] << 32)
+         | ((xxh_u64)bytePtr[2] << 40)
+         | ((xxh_u64)bytePtr[1] << 48)
+         | ((xxh_u64)bytePtr[0] << 56);
+}
+
+#else
+XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));
+}
+
+static xxh_u64 XXH_readBE64(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap64(XXH_read64(ptr)) : XXH_read64(ptr);
+}
+#endif
+
+XXH_FORCE_INLINE xxh_u64
+XXH_readLE64_align(const void* ptr, XXH_alignment align)
+{
+    if (align==XXH_unaligned)
+        return XXH_readLE64(ptr);
+    else
+        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u64*)ptr : XXH_swap64(*(const xxh_u64*)ptr);
+}
+
+
+/*******   xxh64   *******/
+/*!
+ * @}
+ * @defgroup XXH64_impl XXH64 implementation
+ * @ingroup impl
+ *
+ * Details on the XXH64 implementation.
+ * @{
+ */
+/* #define rather that static const, to be used as initializers */
+#define XXH_PRIME64_1  0x9E3779B185EBCA87ULL  /*!< 0b1001111000110111011110011011000110000101111010111100101010000111 */
+#define XXH_PRIME64_2  0xC2B2AE3D27D4EB4FULL  /*!< 0b1100001010110010101011100011110100100111110101001110101101001111 */
+#define XXH_PRIME64_3  0x165667B19E3779F9ULL  /*!< 0b0001011001010110011001111011000110011110001101110111100111111001 */
+#define XXH_PRIME64_4  0x85EBCA77C2B2AE63ULL  /*!< 0b1000010111101011110010100111011111000010101100101010111001100011 */
+#define XXH_PRIME64_5  0x27D4EB2F165667C5ULL  /*!< 0b0010011111010100111010110010111100010110010101100110011111000101 */
+
+#ifdef XXH_OLD_NAMES
+#  define PRIME64_1 XXH_PRIME64_1
+#  define PRIME64_2 XXH_PRIME64_2
+#  define PRIME64_3 XXH_PRIME64_3
+#  define PRIME64_4 XXH_PRIME64_4
+#  define PRIME64_5 XXH_PRIME64_5
+#endif
+
+/*! @copydoc XXH32_round */
+static xxh_u64 XXH64_round(xxh_u64 acc, xxh_u64 input)
+{
+    acc += input * XXH_PRIME64_2;
+    acc  = XXH_rotl64(acc, 31);
+    acc *= XXH_PRIME64_1;
+#if (defined(__AVX512F__)) && !defined(XXH_ENABLE_AUTOVECTORIZE)
+    /*
+     * DISABLE AUTOVECTORIZATION:
+     * A compiler fence is used to prevent GCC and Clang from
+     * autovectorizing the XXH64 loop (pragmas and attributes don't work for some
+     * reason) without globally disabling AVX512.
+     *
+     * Autovectorization of XXH64 tends to be detrimental,
+     * though the exact outcome may change depending on exact cpu and compiler version.
+     * For information, it has been reported as detrimental for Skylake-X,
+     * but possibly beneficial for Zen4.
+     *
+     * The default is to disable auto-vectorization,
+     * but you can select to enable it instead using `XXH_ENABLE_AUTOVECTORIZE` build variable.
+     */
+    XXH_COMPILER_GUARD(acc);
+#endif
+    return acc;
+}
+
+static xxh_u64 XXH64_mergeRound(xxh_u64 acc, xxh_u64 val)
+{
+    val  = XXH64_round(0, val);
+    acc ^= val;
+    acc  = acc * XXH_PRIME64_1 + XXH_PRIME64_4;
+    return acc;
+}
+
+/*! @copydoc XXH32_avalanche */
+static xxh_u64 XXH64_avalanche(xxh_u64 hash)
+{
+    hash ^= hash >> 33;
+    hash *= XXH_PRIME64_2;
+    hash ^= hash >> 29;
+    hash *= XXH_PRIME64_3;
+    hash ^= hash >> 32;
+    return hash;
+}
+
+
+#define XXH_get64bits(p) XXH_readLE64_align(p, align)
+
+/*!
+ * @internal
+ * @brief Sets up the initial accumulator state for XXH64().
+ */
+XXH_FORCE_INLINE void
+XXH64_initAccs(xxh_u64 *acc, xxh_u64 seed)
+{
+    XXH_ASSERT(acc != NULL);
+    acc[0] = seed + XXH_PRIME64_1 + XXH_PRIME64_2;
+    acc[1] = seed + XXH_PRIME64_2;
+    acc[2] = seed + 0;
+    acc[3] = seed - XXH_PRIME64_1;
+}
+
+/*!
+ * @internal
+ * @brief Consumes a block of data for XXH64().
+ *
+ * @return the end input pointer.
+ */
+XXH_FORCE_INLINE const xxh_u8 *
+XXH64_consumeLong(
+    xxh_u64 *XXH_RESTRICT acc,
+    xxh_u8 const *XXH_RESTRICT input,
+    size_t len,
+    XXH_alignment align
+)
+{
+    const xxh_u8* const bEnd = input + len;
+    const xxh_u8* const limit = bEnd - 31;
+    XXH_ASSERT(acc != NULL);
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(len >= 32);
+    do {
+        /* reroll on 32-bit */
+        if (sizeof(void *) < sizeof(xxh_u64)) {
+            size_t i;
+            for (i = 0; i < 4; i++) {
+                acc[i] = XXH64_round(acc[i], XXH_get64bits(input));
+                input += 8;
+            }
+        } else {
+            acc[0] = XXH64_round(acc[0], XXH_get64bits(input)); input += 8;
+            acc[1] = XXH64_round(acc[1], XXH_get64bits(input)); input += 8;
+            acc[2] = XXH64_round(acc[2], XXH_get64bits(input)); input += 8;
+            acc[3] = XXH64_round(acc[3], XXH_get64bits(input)); input += 8;
+        }
+    } while (input < limit);
+
+    return input;
+}
+
+/*!
+ * @internal
+ * @brief Merges the accumulator lanes together for XXH64()
+ */
+XXH_FORCE_INLINE XXH_PUREF xxh_u64
+XXH64_mergeAccs(const xxh_u64 *acc)
+{
+    XXH_ASSERT(acc != NULL);
+    {
+        xxh_u64 h64 = XXH_rotl64(acc[0], 1) + XXH_rotl64(acc[1], 7)
+                    + XXH_rotl64(acc[2], 12) + XXH_rotl64(acc[3], 18);
+        /* reroll on 32-bit */
+        if (sizeof(void *) < sizeof(xxh_u64)) {
+            size_t i;
+            for (i = 0; i < 4; i++) {
+                h64 = XXH64_mergeRound(h64, acc[i]);
+            }
+        } else {
+            h64 = XXH64_mergeRound(h64, acc[0]);
+            h64 = XXH64_mergeRound(h64, acc[1]);
+            h64 = XXH64_mergeRound(h64, acc[2]);
+            h64 = XXH64_mergeRound(h64, acc[3]);
+        }
+        return h64;
+    }
+}
+
+/*!
+ * @internal
+ * @brief Processes the last 0-31 bytes of @p ptr.
+ *
+ * There may be up to 31 bytes remaining to consume from the input.
+ * This final stage will digest them to ensure that all input bytes are present
+ * in the final mix.
+ *
+ * @param hash The hash to finalize.
+ * @param ptr The pointer to the remaining input.
+ * @param len The remaining length, modulo 32.
+ * @param align Whether @p ptr is aligned.
+ * @return The finalized hash
+ * @see XXH32_finalize().
+ */
+XXH_STATIC XXH_PUREF xxh_u64
+XXH64_finalize(xxh_u64 hash, const xxh_u8* ptr, size_t len, XXH_alignment align)
+{
+    if (ptr==NULL) XXH_ASSERT(len == 0);
+    len &= 31;
+    while (len >= 8) {
+        xxh_u64 const k1 = XXH64_round(0, XXH_get64bits(ptr));
+        ptr += 8;
+        hash ^= k1;
+        hash  = XXH_rotl64(hash,27) * XXH_PRIME64_1 + XXH_PRIME64_4;
+        len -= 8;
+    }
+    if (len >= 4) {
+        hash ^= (xxh_u64)(XXH_get32bits(ptr)) * XXH_PRIME64_1;
+        ptr += 4;
+        hash = XXH_rotl64(hash, 23) * XXH_PRIME64_2 + XXH_PRIME64_3;
+        len -= 4;
+    }
+    while (len > 0) {
+        hash ^= (*ptr++) * XXH_PRIME64_5;
+        hash = XXH_rotl64(hash, 11) * XXH_PRIME64_1;
+        --len;
+    }
+    return  XXH64_avalanche(hash);
+}
+
+#ifdef XXH_OLD_NAMES
+#  define PROCESS1_64 XXH_PROCESS1_64
+#  define PROCESS4_64 XXH_PROCESS4_64
+#  define PROCESS8_64 XXH_PROCESS8_64
+#else
+#  undef XXH_PROCESS1_64
+#  undef XXH_PROCESS4_64
+#  undef XXH_PROCESS8_64
+#endif
+
+/*!
+ * @internal
+ * @brief The implementation for @ref XXH64().
+ *
+ * @param input , len , seed Directly passed from @ref XXH64().
+ * @param align Whether @p input is aligned.
+ * @return The calculated hash.
+ */
+XXH_FORCE_INLINE XXH_PUREF xxh_u64
+XXH64_endian_align(const xxh_u8* input, size_t len, xxh_u64 seed, XXH_alignment align)
+{
+    xxh_u64 h64;
+    if (input==NULL) XXH_ASSERT(len == 0);
+
+    if (len>=32) {  /* Process a large block of data */
+        xxh_u64 acc[4];
+        XXH64_initAccs(acc, seed);
+
+        input = XXH64_consumeLong(acc, input, len, align);
+
+        h64 = XXH64_mergeAccs(acc);
+    } else {
+        h64  = seed + XXH_PRIME64_5;
+    }
+
+    h64 += (xxh_u64) len;
+
+    return XXH64_finalize(h64, input, len, align);
+}
+
+
+/*! @ingroup XXH64_family */
+XXH_PUBLIC_API XXH64_hash_t XXH64 (XXH_NOESCAPE const void* input, size_t len, XXH64_hash_t seed)
+{
+#if !defined(XXH_NO_STREAM) && XXH_SIZE_OPT >= 2
+    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
+    XXH64_state_t state;
+    XXH64_reset(&state, seed);
+    XXH64_update(&state, (const xxh_u8*)input, len);
+    return XXH64_digest(&state);
+#else
+    if (XXH_FORCE_ALIGN_CHECK) {
+        if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
+            return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
+    }   }
+
+    return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
+
+#endif
+}
+
+/*******   Hash Streaming   *******/
+#ifndef XXH_NO_STREAM
+/*! @ingroup XXH64_family*/
+XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void)
+{
+    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));
+}
+/*! @ingroup XXH64_family */
+XXH_PUBLIC_API XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)
+{
+    XXH_free(statePtr);
+    return XXH_OK;
+}
+
+/*! @ingroup XXH64_family */
+XXH_PUBLIC_API void XXH64_copyState(XXH_NOESCAPE XXH64_state_t* dstState, const XXH64_state_t* srcState)
+{
+    XXH_memcpy(dstState, srcState, sizeof(*dstState));
+}
+
+/*! @ingroup XXH64_family */
+XXH_PUBLIC_API XXH_errorcode XXH64_reset(XXH_NOESCAPE XXH64_state_t* statePtr, XXH64_hash_t seed)
+{
+    XXH_ASSERT(statePtr != NULL);
+    memset(statePtr, 0, sizeof(*statePtr));
+    XXH64_initAccs(statePtr->acc, seed);
+    return XXH_OK;
+}
+
+/*! @ingroup XXH64_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH64_update (XXH_NOESCAPE XXH64_state_t* state, XXH_NOESCAPE const void* input, size_t len)
+{
+    if (input==NULL) {
+        XXH_ASSERT(len == 0);
+        return XXH_OK;
+    }
+
+    state->total_len += len;
+
+    XXH_ASSERT(state->bufferedSize <= sizeof(state->buffer));
+    if (len < sizeof(state->buffer) - state->bufferedSize)  {   /* fill in tmp buffer */
+        XXH_memcpy(state->buffer + state->bufferedSize, input, len);
+        state->bufferedSize += (XXH32_hash_t)len;
+        return XXH_OK;
+    }
+
+    {   const xxh_u8* xinput = (const xxh_u8*)input;
+        const xxh_u8* const bEnd = xinput + len;
+
+        if (state->bufferedSize) {   /* non-empty buffer => complete first */
+            XXH_memcpy(state->buffer + state->bufferedSize, xinput, sizeof(state->buffer) - state->bufferedSize);
+            xinput += sizeof(state->buffer) - state->bufferedSize;
+            /* and process one round */
+            (void)XXH64_consumeLong(state->acc, state->buffer, sizeof(state->buffer), XXH_aligned);
+            state->bufferedSize = 0;
+        }
+
+        XXH_ASSERT(xinput <= bEnd);
+        if ((size_t)(bEnd - xinput) >= sizeof(state->buffer)) {
+            /* Process the remaining data */
+            xinput = XXH64_consumeLong(state->acc, xinput, (size_t)(bEnd - xinput), XXH_unaligned);
+        }
+
+        if (xinput < bEnd) {
+            /* Copy the leftover to the tmp buffer */
+            XXH_memcpy(state->buffer, xinput, (size_t)(bEnd-xinput));
+            state->bufferedSize = (unsigned)(bEnd-xinput);
+        }
+    }
+
+    return XXH_OK;
+}
+
+
+/*! @ingroup XXH64_family */
+XXH_PUBLIC_API XXH64_hash_t XXH64_digest(XXH_NOESCAPE const XXH64_state_t* state)
+{
+    xxh_u64 h64;
+
+    if (state->total_len >= 32) {
+        h64 = XXH64_mergeAccs(state->acc);
+    } else {
+        h64  = state->acc[2] /*seed*/ + XXH_PRIME64_5;
+    }
+
+    h64 += (xxh_u64) state->total_len;
+
+    return XXH64_finalize(h64, state->buffer, (size_t)state->total_len, XXH_aligned);
+}
+#endif /* !XXH_NO_STREAM */
+
+/******* Canonical representation   *******/
+
+/*! @ingroup XXH64_family */
+XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH_NOESCAPE XXH64_canonical_t* dst, XXH64_hash_t hash)
+{
+    XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t));
+    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap64(hash);
+    XXH_memcpy(dst, &hash, sizeof(*dst));
+}
+
+/*! @ingroup XXH64_family */
+XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(XXH_NOESCAPE const XXH64_canonical_t* src)
+{
+    return XXH_readBE64(src);
+}
+
+#ifndef XXH_NO_XXH3
+
+/* *********************************************************************
+*  XXH3
+*  New generation hash designed for speed on small keys and vectorization
+************************************************************************ */
+/*!
+ * @}
+ * @defgroup XXH3_impl XXH3 implementation
+ * @ingroup impl
+ * @{
+ */
+
+/* ===   Compiler specifics   === */
+
+
+#if (defined(__GNUC__) && (__GNUC__ >= 3))  \
+  || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) \
+  || defined(__clang__)
+#    define XXH_likely(x) __builtin_expect(x, 1)
+#    define XXH_unlikely(x) __builtin_expect(x, 0)
+#else
+#    define XXH_likely(x) (x)
+#    define XXH_unlikely(x) (x)
+#endif
+
+#ifndef XXH_HAS_INCLUDE
+#  ifdef __has_include
+/*
+ * Not defined as XXH_HAS_INCLUDE(x) (function-like) because
+ * this causes segfaults in Apple Clang 4.2 (on Mac OS X 10.7 Lion)
+ */
+#    define XXH_HAS_INCLUDE __has_include
+#  else
+#    define XXH_HAS_INCLUDE(x) 0
+#  endif
+#endif
+
+#if defined(__GNUC__) || defined(__clang__)
+#  if defined(__ARM_FEATURE_SVE)
+#    include <arm_sve.h>
+#  endif
+#  if defined(__ARM_NEON__) || defined(__ARM_NEON) \
+   || (defined(_M_ARM) && _M_ARM >= 7) \
+   || defined(_M_ARM64) || defined(_M_ARM64EC) \
+   || (defined(__wasm_simd128__) && XXH_HAS_INCLUDE(<arm_neon.h>)) /* WASM SIMD128 via SIMDe */
+#    define inline __inline__  /* circumvent a clang bug */
+#    include <arm_neon.h>
+#    undef inline
+#  elif defined(__AVX2__)
+#    include <immintrin.h>
+#  elif defined(__SSE2__)
+#    include <emmintrin.h>
+#  elif defined(__loongarch_sx)
+#    include <lsxintrin.h>
+#  endif
+#endif
+
+#if defined(_MSC_VER)
+#  include <intrin.h>
+#endif
+
+/*
+ * One goal of XXH3 is to make it fast on both 32-bit and 64-bit, while
+ * remaining a true 64-bit/128-bit hash function.
+ *
+ * This is done by prioritizing a subset of 64-bit operations that can be
+ * emulated without too many steps on the average 32-bit machine.
+ *
+ * For example, these two lines seem similar, and run equally fast on 64-bit:
+ *
+ *   xxh_u64 x;
+ *   x ^= (x >> 47); // good
+ *   x ^= (x >> 13); // bad
+ *
+ * However, to a 32-bit machine, there is a major difference.
+ *
+ * x ^= (x >> 47) looks like this:
+ *
+ *   x.lo ^= (x.hi >> (47 - 32));
+ *
+ * while x ^= (x >> 13) looks like this:
+ *
+ *   // note: funnel shifts are not usually cheap.
+ *   x.lo ^= (x.lo >> 13) | (x.hi << (32 - 13));
+ *   x.hi ^= (x.hi >> 13);
+ *
+ * The first one is significantly faster than the second, simply because the
+ * shift is larger than 32. This means:
+ *  - All the bits we need are in the upper 32 bits, so we can ignore the lower
+ *    32 bits in the shift.
+ *  - The shift result will always fit in the lower 32 bits, and therefore,
+ *    we can ignore the upper 32 bits in the xor.
+ *
+ * Thanks to this optimization, XXH3 only requires these features to be efficient:
+ *
+ *  - Usable unaligned access
+ *  - A 32-bit or 64-bit ALU
+ *      - If 32-bit, a decent ADC instruction
+ *  - A 32 or 64-bit multiply with a 64-bit result
+ *  - For the 128-bit variant, a decent byteswap helps short inputs.
+ *
+ * The first two are already required by XXH32, and almost all 32-bit and 64-bit
+ * platforms which can run XXH32 can run XXH3 efficiently.
+ *
+ * Thumb-1, the classic 16-bit only subset of ARM's instruction set, is one
+ * notable exception.
+ *
+ * First of all, Thumb-1 lacks support for the UMULL instruction which
+ * performs the important long multiply. This means numerous __aeabi_lmul
+ * calls.
+ *
+ * Second of all, the 8 functional registers are just not enough.
+ * Setup for __aeabi_lmul, byteshift loads, pointers, and all arithmetic need
+ * Lo registers, and this shuffling results in thousands more MOVs than A32.
+ *
+ * A32 and T32 don't have this limitation. They can access all 14 registers,
+ * do a 32->64 multiply with UMULL, and the flexible operand allowing free
+ * shifts is helpful, too.
+ *
+ * Therefore, we do a quick sanity check.
+ *
+ * If compiling Thumb-1 for a target which supports ARM instructions, we will
+ * emit a warning, as it is not a "sane" platform to compile for.
+ *
+ * Usually, if this happens, it is because of an accident and you probably need
+ * to specify -march, as you likely meant to compile for a newer architecture.
+ *
+ * Credit: large sections of the vectorial and asm source code paths
+ *         have been contributed by @easyaspi314
+ */
+#if defined(__thumb__) && !defined(__thumb2__) && defined(__ARM_ARCH_ISA_ARM)
+#   warning "XXH3 is highly inefficient without ARM or Thumb-2."
+#endif
+
+/* ==========================================
+ * Vectorization detection
+ * ========================================== */
+
+#ifdef XXH_DOXYGEN
+/*!
+ * @ingroup tuning
+ * @brief Overrides the vectorization implementation chosen for XXH3.
+ *
+ * Can be defined to 0 to disable SIMD or any of the values mentioned in
+ * @ref XXH_VECTOR_TYPE.
+ *
+ * If this is not defined, it uses predefined macros to determine the best
+ * implementation.
+ */
+#  define XXH_VECTOR XXH_SCALAR
+/*!
+ * @ingroup tuning
+ * @brief Selects the minimum alignment for XXH3's accumulators.
+ *
+ * When using SIMD, this should match the alignment required for said vector
+ * type, so, for example, 32 for AVX2.
+ *
+ * Default: Auto detected.
+ */
+#  define XXH_ACC_ALIGN 8
+#endif
+
+/* Actual definition */
+#ifndef XXH_DOXYGEN
+#endif
+
+#ifndef XXH_VECTOR    /* can be defined on command line */
+#  if defined(__ARM_FEATURE_SVE)
+#    define XXH_VECTOR XXH_SVE
+#  elif ( \
+        defined(__ARM_NEON__) || defined(__ARM_NEON) /* gcc */ \
+     || defined(_M_ARM) || defined(_M_ARM64) || defined(_M_ARM64EC) /* msvc */ \
+     || (defined(__wasm_simd128__) && XXH_HAS_INCLUDE(<arm_neon.h>)) /* wasm simd128 via SIMDe */ \
+   ) && ( \
+        defined(_WIN32) || defined(__LITTLE_ENDIAN__) /* little endian only */ \
+    || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) \
+   )
+#    define XXH_VECTOR XXH_NEON
+#  elif defined(__AVX512F__)
+#    define XXH_VECTOR XXH_AVX512
+#  elif defined(__AVX2__)
+#    define XXH_VECTOR XXH_AVX2
+#  elif defined(__SSE2__) || defined(_M_AMD64) || defined(_M_X64) || (defined(_M_IX86_FP) && (_M_IX86_FP == 2))
+#    define XXH_VECTOR XXH_SSE2
+#  elif (defined(__PPC64__) && defined(__POWER8_VECTOR__)) \
+     || (defined(__s390x__) && defined(__VEC__)) \
+     && defined(__GNUC__) /* TODO: IBM XL */
+#    define XXH_VECTOR XXH_VSX
+#  elif defined(__loongarch_sx)
+#    define XXH_VECTOR XXH_LSX
+#  else
+#    define XXH_VECTOR XXH_SCALAR
+#  endif
+#endif
+
+/* __ARM_FEATURE_SVE is only supported by GCC & Clang. */
+#if (XXH_VECTOR == XXH_SVE) && !defined(__ARM_FEATURE_SVE)
+#  ifdef _MSC_VER
+#    pragma warning(once : 4606)
+#  else
+#    warning "__ARM_FEATURE_SVE isn't supported. Use SCALAR instead."
+#  endif
+#  undef XXH_VECTOR
+#  define XXH_VECTOR XXH_SCALAR
+#endif
+
+/*
+ * Controls the alignment of the accumulator,
+ * for compatibility with aligned vector loads, which are usually faster.
+ */
+#ifndef XXH_ACC_ALIGN
+#  if defined(XXH_X86DISPATCH)
+#     define XXH_ACC_ALIGN 64  /* for compatibility with avx512 */
+#  elif XXH_VECTOR == XXH_SCALAR  /* scalar */
+#     define XXH_ACC_ALIGN 8
+#  elif XXH_VECTOR == XXH_SSE2  /* sse2 */
+#     define XXH_ACC_ALIGN 16
+#  elif XXH_VECTOR == XXH_AVX2  /* avx2 */
+#     define XXH_ACC_ALIGN 32
+#  elif XXH_VECTOR == XXH_NEON  /* neon */
+#     define XXH_ACC_ALIGN 16
+#  elif XXH_VECTOR == XXH_VSX   /* vsx */
+#     define XXH_ACC_ALIGN 16
+#  elif XXH_VECTOR == XXH_AVX512  /* avx512 */
+#     define XXH_ACC_ALIGN 64
+#  elif XXH_VECTOR == XXH_SVE   /* sve */
+#     define XXH_ACC_ALIGN 64
+#  elif XXH_VECTOR == XXH_LSX   /* lsx */
+#     define XXH_ACC_ALIGN 64
+#  endif
+#endif
+
+#if defined(XXH_X86DISPATCH) || XXH_VECTOR == XXH_SSE2 \
+    || XXH_VECTOR == XXH_AVX2 || XXH_VECTOR == XXH_AVX512
+#  define XXH_SEC_ALIGN XXH_ACC_ALIGN
+#elif XXH_VECTOR == XXH_SVE
+#  define XXH_SEC_ALIGN XXH_ACC_ALIGN
+#else
+#  define XXH_SEC_ALIGN 8
+#endif
+
+#if defined(__GNUC__) || defined(__clang__)
+#  define XXH_ALIASING __attribute__((__may_alias__))
+#else
+#  define XXH_ALIASING /* nothing */
+#endif
+
+/*
+ * UGLY HACK:
+ * GCC usually generates the best code with -O3 for xxHash.
+ *
+ * However, when targeting AVX2, it is overzealous in its unrolling resulting
+ * in code roughly 3/4 the speed of Clang.
+ *
+ * There are other issues, such as GCC splitting _mm256_loadu_si256 into
+ * _mm_loadu_si128 + _mm256_inserti128_si256. This is an optimization which
+ * only applies to Sandy and Ivy Bridge... which don't even support AVX2.
+ *
+ * That is why when compiling the AVX2 version, it is recommended to use either
+ *   -O2 -mavx2 -march=haswell
+ * or
+ *   -O2 -mavx2 -mno-avx256-split-unaligned-load
+ * for decent performance, or to use Clang instead.
+ *
+ * Fortunately, we can control the first one with a pragma that forces GCC into
+ * -O2, but the other one we can't control without "failed to inline always
+ * inline function due to target mismatch" warnings.
+ */
+#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
+  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__OPTIMIZE__) && XXH_SIZE_OPT <= 0 /* respect -O0 and -Os */
+#  pragma GCC push_options
+#  pragma GCC optimize("-O2")
+#endif
+
+#if XXH_VECTOR == XXH_NEON
+
+/*
+ * UGLY HACK: While AArch64 GCC on Linux does not seem to care, on macOS, GCC -O3
+ * optimizes out the entire hashLong loop because of the aliasing violation.
+ *
+ * However, GCC is also inefficient at load-store optimization with vld1q/vst1q,
+ * so the only option is to mark it as aliasing.
+ */
+typedef uint64x2_t xxh_aliasing_uint64x2_t XXH_ALIASING;
+
+/*!
+ * @internal
+ * @brief `vld1q_u64` but faster and alignment-safe.
+ *
+ * On AArch64, unaligned access is always safe, but on ARMv7-a, it is only
+ * *conditionally* safe (`vld1` has an alignment bit like `movdq[ua]` in x86).
+ *
+ * GCC for AArch64 sees `vld1q_u8` as an intrinsic instead of a load, so it
+ * prohibits load-store optimizations. Therefore, a direct dereference is used.
+ *
+ * Otherwise, `vld1q_u8` is used with `vreinterpretq_u8_u64` to do a safe
+ * unaligned load.
+ */
+#if defined(__aarch64__) && defined(__GNUC__) && !defined(__clang__)
+XXH_FORCE_INLINE uint64x2_t XXH_vld1q_u64(void const* ptr) /* silence -Wcast-align */
+{
+    return *(xxh_aliasing_uint64x2_t const *)ptr;
+}
+#else
+XXH_FORCE_INLINE uint64x2_t XXH_vld1q_u64(void const* ptr)
+{
+    return vreinterpretq_u64_u8(vld1q_u8((uint8_t const*)ptr));
+}
+#endif
+
+/*!
+ * @internal
+ * @brief `vmlal_u32` on low and high halves of a vector.
+ *
+ * This is a workaround for AArch64 GCC < 11 which implemented arm_neon.h with
+ * inline assembly and were therefore incapable of merging the `vget_{low, high}_u32`
+ * with `vmlal_u32`.
+ */
+#if defined(__aarch64__) && defined(__GNUC__) && !defined(__clang__) && __GNUC__ < 11
+XXH_FORCE_INLINE uint64x2_t
+XXH_vmlal_low_u32(uint64x2_t acc, uint32x4_t lhs, uint32x4_t rhs)
+{
+    /* Inline assembly is the only way */
+    __asm__("umlal   %0.2d, %1.2s, %2.2s" : "+w" (acc) : "w" (lhs), "w" (rhs));
+    return acc;
+}
+XXH_FORCE_INLINE uint64x2_t
+XXH_vmlal_high_u32(uint64x2_t acc, uint32x4_t lhs, uint32x4_t rhs)
+{
+    /* This intrinsic works as expected */
+    return vmlal_high_u32(acc, lhs, rhs);
+}
+#else
+/* Portable intrinsic versions */
+XXH_FORCE_INLINE uint64x2_t
+XXH_vmlal_low_u32(uint64x2_t acc, uint32x4_t lhs, uint32x4_t rhs)
+{
+    return vmlal_u32(acc, vget_low_u32(lhs), vget_low_u32(rhs));
+}
+/*! @copydoc XXH_vmlal_low_u32
+ * Assume the compiler converts this to vmlal_high_u32 on aarch64 */
+XXH_FORCE_INLINE uint64x2_t
+XXH_vmlal_high_u32(uint64x2_t acc, uint32x4_t lhs, uint32x4_t rhs)
+{
+    return vmlal_u32(acc, vget_high_u32(lhs), vget_high_u32(rhs));
+}
+#endif
+
+/*!
+ * @ingroup tuning
+ * @brief Controls the NEON to scalar ratio for XXH3
+ *
+ * This can be set to 2, 4, 6, or 8.
+ *
+ * ARM Cortex CPUs are _very_ sensitive to how their pipelines are used.
+ *
+ * For example, the Cortex-A73 can dispatch 3 micro-ops per cycle, but only 2 of those
+ * can be NEON. If you are only using NEON instructions, you are only using 2/3 of the CPU
+ * bandwidth.
+ *
+ * This is even more noticeable on the more advanced cores like the Cortex-A76 which
+ * can dispatch 8 micro-ops per cycle, but still only 2 NEON micro-ops at once.
+ *
+ * Therefore, to make the most out of the pipeline, it is beneficial to run 6 NEON lanes
+ * and 2 scalar lanes, which is chosen by default.
+ *
+ * This does not apply to Apple processors or 32-bit processors, which run better with
+ * full NEON. These will default to 8. Additionally, size-optimized builds run 8 lanes.
+ *
+ * This change benefits CPUs with large micro-op buffers without negatively affecting
+ * most other CPUs:
+ *
+ *  | Chipset               | Dispatch type       | NEON only | 6:2 hybrid | Diff. |
+ *  |:----------------------|:--------------------|----------:|-----------:|------:|
+ *  | Snapdragon 730 (A76)  | 2 NEON/8 micro-ops  |  8.8 GB/s |  10.1 GB/s |  ~16% |
+ *  | Snapdragon 835 (A73)  | 2 NEON/3 micro-ops  |  5.1 GB/s |   5.3 GB/s |   ~5% |
+ *  | Marvell PXA1928 (A53) | In-order dual-issue |  1.9 GB/s |   1.9 GB/s |    0% |
+ *  | Apple M1              | 4 NEON/8 micro-ops  | 37.3 GB/s |  36.1 GB/s |  ~-3% |
+ *
+ * It also seems to fix some bad codegen on GCC, making it almost as fast as clang.
+ *
+ * When using WASM SIMD128, if this is 2 or 6, SIMDe will scalarize 2 of the lanes meaning
+ * it effectively becomes worse 4.
+ *
+ * @see XXH3_accumulate_512_neon()
+ */
+# ifndef XXH3_NEON_LANES
+#  if (defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64) || defined(_M_ARM64EC)) \
+   && !defined(__APPLE__) && XXH_SIZE_OPT <= 0
+#   define XXH3_NEON_LANES 6
+#  else
+#   define XXH3_NEON_LANES XXH_ACC_NB
+#  endif
+# endif
+#endif  /* XXH_VECTOR == XXH_NEON */
+
+/*
+ * VSX and Z Vector helpers.
+ *
+ * This is very messy, and any pull requests to clean this up are welcome.
+ *
+ * There are a lot of problems with supporting VSX and s390x, due to
+ * inconsistent intrinsics, spotty coverage, and multiple endiannesses.
+ */
+#if XXH_VECTOR == XXH_VSX
+/* Annoyingly, these headers _may_ define three macros: `bool`, `vector`,
+ * and `pixel`. This is a problem for obvious reasons.
+ *
+ * These keywords are unnecessary; the spec literally says they are
+ * equivalent to `__bool`, `__vector`, and `__pixel` and may be undef'd
+ * after including the header.
+ *
+ * We use pragma push_macro/pop_macro to keep the namespace clean. */
+#  pragma push_macro("bool")
+#  pragma push_macro("vector")
+#  pragma push_macro("pixel")
+/* silence potential macro redefined warnings */
+#  undef bool
+#  undef vector
+#  undef pixel
+
+#  if defined(__s390x__)
+#    include <s390intrin.h>
+#  else
+#    include <altivec.h>
+#  endif
+
+/* Restore the original macro values, if applicable. */
+#  pragma pop_macro("pixel")
+#  pragma pop_macro("vector")
+#  pragma pop_macro("bool")
+
+typedef __vector unsigned long long xxh_u64x2;
+typedef __vector unsigned char xxh_u8x16;
+typedef __vector unsigned xxh_u32x4;
+
+/*
+ * UGLY HACK: Similar to aarch64 macOS GCC, s390x GCC has the same aliasing issue.
+ */
+typedef xxh_u64x2 xxh_aliasing_u64x2 XXH_ALIASING;
+
+# ifndef XXH_VSX_BE
+#  if defined(__BIG_ENDIAN__) \
+  || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+#    define XXH_VSX_BE 1
+#  elif defined(__VEC_ELEMENT_REG_ORDER__) && __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__
+#    warning "-maltivec=be is not recommended. Please use native endianness."
+#    define XXH_VSX_BE 1
+#  else
+#    define XXH_VSX_BE 0
+#  endif
+# endif /* !defined(XXH_VSX_BE) */
+
+# if XXH_VSX_BE
+#  if defined(__POWER9_VECTOR__) || (defined(__clang__) && defined(__s390x__))
+#    define XXH_vec_revb vec_revb
+#  else
+/*!
+ * A polyfill for POWER9's vec_revb().
+ */
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_revb(xxh_u64x2 val)
+{
+    xxh_u8x16 const vByteSwap = { 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
+                                  0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08 };
+    return vec_perm(val, val, vByteSwap);
+}
+#  endif
+# endif /* XXH_VSX_BE */
+
+/*!
+ * Performs an unaligned vector load and byte swaps it on big endian.
+ */
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_loadu(const void *ptr)
+{
+    xxh_u64x2 ret;
+    XXH_memcpy(&ret, ptr, sizeof(xxh_u64x2));
+# if XXH_VSX_BE
+    ret = XXH_vec_revb(ret);
+# endif
+    return ret;
+}
+
+/*
+ * vec_mulo and vec_mule are very problematic intrinsics on PowerPC
+ *
+ * These intrinsics weren't added until GCC 8, despite existing for a while,
+ * and they are endian dependent. Also, their meaning swap depending on version.
+ * */
+# if defined(__s390x__)
+ /* s390x is always big endian, no issue on this platform */
+#  define XXH_vec_mulo vec_mulo
+#  define XXH_vec_mule vec_mule
+# elif defined(__clang__) && XXH_HAS_BUILTIN(__builtin_altivec_vmuleuw) && !defined(__ibmxl__)
+/* Clang has a better way to control this, we can just use the builtin which doesn't swap. */
+ /* The IBM XL Compiler (which defined __clang__) only implements the vec_* operations */
+#  define XXH_vec_mulo __builtin_altivec_vmulouw
+#  define XXH_vec_mule __builtin_altivec_vmuleuw
+# else
+/* gcc needs inline assembly */
+/* Adapted from https://github.com/google/highwayhash/blob/master/highwayhash/hh_vsx.h. */
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mulo(xxh_u32x4 a, xxh_u32x4 b)
+{
+    xxh_u64x2 result;
+    __asm__("vmulouw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
+    return result;
+}
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mule(xxh_u32x4 a, xxh_u32x4 b)
+{
+    xxh_u64x2 result;
+    __asm__("vmuleuw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
+    return result;
+}
+# endif /* XXH_vec_mulo, XXH_vec_mule */
+#endif /* XXH_VECTOR == XXH_VSX */
+
+#if XXH_VECTOR == XXH_SVE
+#define ACCRND(acc, offset) \
+do { \
+    svuint64_t input_vec = svld1_u64(mask, xinput + offset);         \
+    svuint64_t secret_vec = svld1_u64(mask, xsecret + offset);       \
+    svuint64_t mixed = sveor_u64_x(mask, secret_vec, input_vec);     \
+    svuint64_t swapped = svtbl_u64(input_vec, kSwap);                \
+    svuint64_t mixed_lo = svextw_u64_x(mask, mixed);                 \
+    svuint64_t mixed_hi = svlsr_n_u64_x(mask, mixed, 32);            \
+    svuint64_t mul = svmad_u64_x(mask, mixed_lo, mixed_hi, swapped); \
+    acc = svadd_u64_x(mask, acc, mul);                               \
+} while (0)
+#endif /* XXH_VECTOR == XXH_SVE */
+
+/* prefetch
+ * can be disabled, by declaring XXH_NO_PREFETCH build macro */
+#if defined(XXH_NO_PREFETCH)
+#  define XXH_PREFETCH(ptr)  (void)(ptr)  /* disabled */
+#else
+#  if XXH_SIZE_OPT >= 1
+#    define XXH_PREFETCH(ptr) (void)(ptr)
+#  elif defined(_MSC_VER) && (defined(_M_X64) || defined(_M_IX86))  /* _mm_prefetch() not defined outside of x86/x64 */
+#    include <mmintrin.h>   /* https://msdn.microsoft.com/fr-fr/library/84szxsww(v=vs.90).aspx */
+#    define XXH_PREFETCH(ptr)  _mm_prefetch((const char*)(ptr), _MM_HINT_T0)
+#  elif defined(__GNUC__) && ( (__GNUC__ >= 4) || ( (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1) ) )
+#    define XXH_PREFETCH(ptr)  __builtin_prefetch((ptr), 0 /* rw==read */, 3 /* locality */)
+#  else
+#    define XXH_PREFETCH(ptr) (void)(ptr)  /* disabled */
+#  endif
+#endif  /* XXH_NO_PREFETCH */
+
+
+/* ==========================================
+ * XXH3 default settings
+ * ========================================== */
+
+#define XXH_SECRET_DEFAULT_SIZE 192   /* minimum XXH3_SECRET_SIZE_MIN */
+
+#if (XXH_SECRET_DEFAULT_SIZE < XXH3_SECRET_SIZE_MIN)
+#  error "default keyset is not large enough"
+#endif
+
+/*! Pseudorandom secret taken directly from FARSH. */
+XXH_ALIGN(64) static const xxh_u8 XXH3_kSecret[XXH_SECRET_DEFAULT_SIZE] = {
+    0xb8, 0xfe, 0x6c, 0x39, 0x23, 0xa4, 0x4b, 0xbe, 0x7c, 0x01, 0x81, 0x2c, 0xf7, 0x21, 0xad, 0x1c,
+    0xde, 0xd4, 0x6d, 0xe9, 0x83, 0x90, 0x97, 0xdb, 0x72, 0x40, 0xa4, 0xa4, 0xb7, 0xb3, 0x67, 0x1f,
+    0xcb, 0x79, 0xe6, 0x4e, 0xcc, 0xc0, 0xe5, 0x78, 0x82, 0x5a, 0xd0, 0x7d, 0xcc, 0xff, 0x72, 0x21,
+    0xb8, 0x08, 0x46, 0x74, 0xf7, 0x43, 0x24, 0x8e, 0xe0, 0x35, 0x90, 0xe6, 0x81, 0x3a, 0x26, 0x4c,
+    0x3c, 0x28, 0x52, 0xbb, 0x91, 0xc3, 0x00, 0xcb, 0x88, 0xd0, 0x65, 0x8b, 0x1b, 0x53, 0x2e, 0xa3,
+    0x71, 0x64, 0x48, 0x97, 0xa2, 0x0d, 0xf9, 0x4e, 0x38, 0x19, 0xef, 0x46, 0xa9, 0xde, 0xac, 0xd8,
+    0xa8, 0xfa, 0x76, 0x3f, 0xe3, 0x9c, 0x34, 0x3f, 0xf9, 0xdc, 0xbb, 0xc7, 0xc7, 0x0b, 0x4f, 0x1d,
+    0x8a, 0x51, 0xe0, 0x4b, 0xcd, 0xb4, 0x59, 0x31, 0xc8, 0x9f, 0x7e, 0xc9, 0xd9, 0x78, 0x73, 0x64,
+    0xea, 0xc5, 0xac, 0x83, 0x34, 0xd3, 0xeb, 0xc3, 0xc5, 0x81, 0xa0, 0xff, 0xfa, 0x13, 0x63, 0xeb,
+    0x17, 0x0d, 0xdd, 0x51, 0xb7, 0xf0, 0xda, 0x49, 0xd3, 0x16, 0x55, 0x26, 0x29, 0xd4, 0x68, 0x9e,
+    0x2b, 0x16, 0xbe, 0x58, 0x7d, 0x47, 0xa1, 0xfc, 0x8f, 0xf8, 0xb8, 0xd1, 0x7a, 0xd0, 0x31, 0xce,
+    0x45, 0xcb, 0x3a, 0x8f, 0x95, 0x16, 0x04, 0x28, 0xaf, 0xd7, 0xfb, 0xca, 0xbb, 0x4b, 0x40, 0x7e,
+};
+
+static const xxh_u64 PRIME_MX1 = 0x165667919E3779F9ULL;  /*!< 0b0001011001010110011001111001000110011110001101110111100111111001 */
+static const xxh_u64 PRIME_MX2 = 0x9FB21C651E98DF25ULL;  /*!< 0b1001111110110010000111000110010100011110100110001101111100100101 */
+
+#ifdef XXH_OLD_NAMES
+#  define kSecret XXH3_kSecret
+#endif
+
+#ifdef XXH_DOXYGEN
+/*!
+ * @brief Calculates a 32-bit to 64-bit long multiply.
+ *
+ * Implemented as a macro.
+ *
+ * Wraps `__emulu` on MSVC x86 because it tends to call `__allmul` when it doesn't
+ * need to (but it shouldn't need to anyways, it is about 7 instructions to do
+ * a 64x64 multiply...). Since we know that this will _always_ emit `MULL`, we
+ * use that instead of the normal method.
+ *
+ * If you are compiling for platforms like Thumb-1 and don't have a better option,
+ * you may also want to write your own long multiply routine here.
+ *
+ * @param x, y Numbers to be multiplied
+ * @return 64-bit product of the low 32 bits of @p x and @p y.
+ */
+XXH_FORCE_INLINE xxh_u64
+XXH_mult32to64(xxh_u64 x, xxh_u64 y)
+{
+   return (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF);
+}
+#elif defined(_MSC_VER) && defined(_M_IX86)
+#    define XXH_mult32to64(x, y) __emulu((unsigned)(x), (unsigned)(y))
+#else
+/*
+ * Downcast + upcast is usually better than masking on older compilers like
+ * GCC 4.2 (especially 32-bit ones), all without affecting newer compilers.
+ *
+ * The other method, (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF), will AND both operands
+ * and perform a full 64x64 multiply -- entirely redundant on 32-bit.
+ */
+#    define XXH_mult32to64(x, y) ((xxh_u64)(xxh_u32)(x) * (xxh_u64)(xxh_u32)(y))
+#endif
+
+/*!
+ * @brief Calculates a 64->128-bit long multiply.
+ *
+ * Uses `__uint128_t` and `_umul128` if available, otherwise uses a scalar
+ * version.
+ *
+ * @param lhs , rhs The 64-bit integers to be multiplied
+ * @return The 128-bit result represented in an @ref XXH128_hash_t.
+ */
+static XXH128_hash_t
+XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
+{
+    /*
+     * GCC/Clang __uint128_t method.
+     *
+     * On most 64-bit targets, GCC and Clang define a __uint128_t type.
+     * This is usually the best way as it usually uses a native long 64-bit
+     * multiply, such as MULQ on x86_64 or MUL + UMULH on aarch64.
+     *
+     * Usually.
+     *
+     * Despite being a 32-bit platform, Clang (and emscripten) define this type
+     * despite not having the arithmetic for it. This results in a laggy
+     * compiler builtin call which calculates a full 128-bit multiply.
+     * In that case it is best to use the portable one.
+     * https://github.com/Cyan4973/xxHash/issues/211#issuecomment-515575677
+     */
+#if (defined(__GNUC__) || defined(__clang__)) && !defined(__wasm__) \
+    && defined(__SIZEOF_INT128__) \
+    || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 128)
+
+    __uint128_t const product = (__uint128_t)lhs * (__uint128_t)rhs;
+    XXH128_hash_t r128;
+    r128.low64  = (xxh_u64)(product);
+    r128.high64 = (xxh_u64)(product >> 64);
+    return r128;
+
+    /*
+     * MSVC for x64's _umul128 method.
+     *
+     * xxh_u64 _umul128(xxh_u64 Multiplier, xxh_u64 Multiplicand, xxh_u64 *HighProduct);
+     *
+     * This compiles to single operand MUL on x64.
+     */
+#elif (defined(_M_X64) || defined(_M_IA64)) && !defined(_M_ARM64EC)
+
+#ifndef _MSC_VER
+#   pragma intrinsic(_umul128)
+#endif
+    xxh_u64 product_high;
+    xxh_u64 const product_low = _umul128(lhs, rhs, &product_high);
+    XXH128_hash_t r128;
+    r128.low64  = product_low;
+    r128.high64 = product_high;
+    return r128;
+
+    /*
+     * MSVC for ARM64's __umulh method.
+     *
+     * This compiles to the same MUL + UMULH as GCC/Clang's __uint128_t method.
+     */
+#elif defined(_M_ARM64) || defined(_M_ARM64EC)
+
+#ifndef _MSC_VER
+#   pragma intrinsic(__umulh)
+#endif
+    XXH128_hash_t r128;
+    r128.low64  = lhs * rhs;
+    r128.high64 = __umulh(lhs, rhs);
+    return r128;
+
+#else
+    /*
+     * Portable scalar method. Optimized for 32-bit and 64-bit ALUs.
+     *
+     * This is a fast and simple grade school multiply, which is shown below
+     * with base 10 arithmetic instead of base 0x100000000.
+     *
+     *           9 3 // D2 lhs = 93
+     *         x 7 5 // D2 rhs = 75
+     *     ----------
+     *           1 5 // D2 lo_lo = (93 % 10) * (75 % 10) = 15
+     *         4 5 | // D2 hi_lo = (93 / 10) * (75 % 10) = 45
+     *         2 1 | // D2 lo_hi = (93 % 10) * (75 / 10) = 21
+     *     + 6 3 | | // D2 hi_hi = (93 / 10) * (75 / 10) = 63
+     *     ---------
+     *         2 7 | // D2 cross = (15 / 10) + (45 % 10) + 21 = 27
+     *     + 6 7 | | // D2 upper = (27 / 10) + (45 / 10) + 63 = 67
+     *     ---------
+     *       6 9 7 5 // D4 res = (27 * 10) + (15 % 10) + (67 * 100) = 6975
+     *
+     * The reasons for adding the products like this are:
+     *  1. It avoids manual carry tracking. Just like how
+     *     (9 * 9) + 9 + 9 = 99, the same applies with this for UINT64_MAX.
+     *     This avoids a lot of complexity.
+     *
+     *  2. It hints for, and on Clang, compiles to, the powerful UMAAL
+     *     instruction available in ARM's Digital Signal Processing extension
+     *     in 32-bit ARMv6 and later, which is shown below:
+     *
+     *         void UMAAL(xxh_u32 *RdLo, xxh_u32 *RdHi, xxh_u32 Rn, xxh_u32 Rm)
+     *         {
+     *             xxh_u64 product = (xxh_u64)*RdLo * (xxh_u64)*RdHi + Rn + Rm;
+     *             *RdLo = (xxh_u32)(product & 0xFFFFFFFF);
+     *             *RdHi = (xxh_u32)(product >> 32);
+     *         }
+     *
+     *     This instruction was designed for efficient long multiplication, and
+     *     allows this to be calculated in only 4 instructions at speeds
+     *     comparable to some 64-bit ALUs.
+     *
+     *  3. It isn't terrible on other platforms. Usually this will be a couple
+     *     of 32-bit ADD/ADCs.
+     */
+
+    /* First calculate all of the cross products. */
+    xxh_u64 const lo_lo = XXH_mult32to64(lhs & 0xFFFFFFFF, rhs & 0xFFFFFFFF);
+    xxh_u64 const hi_lo = XXH_mult32to64(lhs >> 32,        rhs & 0xFFFFFFFF);
+    xxh_u64 const lo_hi = XXH_mult32to64(lhs & 0xFFFFFFFF, rhs >> 32);
+    xxh_u64 const hi_hi = XXH_mult32to64(lhs >> 32,        rhs >> 32);
+
+    /* Now add the products together. These will never overflow. */
+    xxh_u64 const cross = (lo_lo >> 32) + (hi_lo & 0xFFFFFFFF) + lo_hi;
+    xxh_u64 const upper = (hi_lo >> 32) + (cross >> 32)        + hi_hi;
+    xxh_u64 const lower = (cross << 32) | (lo_lo & 0xFFFFFFFF);
+
+    XXH128_hash_t r128;
+    r128.low64  = lower;
+    r128.high64 = upper;
+    return r128;
+#endif
+}
+
+/*!
+ * @brief Calculates a 64-bit to 128-bit multiply, then XOR folds it.
+ *
+ * The reason for the separate function is to prevent passing too many structs
+ * around by value. This will hopefully inline the multiply, but we don't force it.
+ *
+ * @param lhs , rhs The 64-bit integers to multiply
+ * @return The low 64 bits of the product XOR'd by the high 64 bits.
+ * @see XXH_mult64to128()
+ */
+static xxh_u64
+XXH3_mul128_fold64(xxh_u64 lhs, xxh_u64 rhs)
+{
+    XXH128_hash_t product = XXH_mult64to128(lhs, rhs);
+    return product.low64 ^ product.high64;
+}
+
+/*! Seems to produce slightly better code on GCC for some reason. */
+XXH_FORCE_INLINE XXH_CONSTF xxh_u64 XXH_xorshift64(xxh_u64 v64, int shift)
+{
+    XXH_ASSERT(0 <= shift && shift < 64);
+    return v64 ^ (v64 >> shift);
+}
+
+/*
+ * This is a fast avalanche stage,
+ * suitable when input bits are already partially mixed
+ */
+static XXH64_hash_t XXH3_avalanche(xxh_u64 h64)
+{
+    h64 = XXH_xorshift64(h64, 37);
+    h64 *= PRIME_MX1;
+    h64 = XXH_xorshift64(h64, 32);
+    return h64;
+}
+
+/*
+ * This is a stronger avalanche,
+ * inspired by Pelle Evensen's rrmxmx
+ * preferable when input has not been previously mixed
+ */
+static XXH64_hash_t XXH3_rrmxmx(xxh_u64 h64, xxh_u64 len)
+{
+    /* this mix is inspired by Pelle Evensen's rrmxmx */
+    h64 ^= XXH_rotl64(h64, 49) ^ XXH_rotl64(h64, 24);
+    h64 *= PRIME_MX2;
+    h64 ^= (h64 >> 35) + len ;
+    h64 *= PRIME_MX2;
+    return XXH_xorshift64(h64, 28);
+}
+
+
+/* ==========================================
+ * Short keys
+ * ==========================================
+ * One of the shortcomings of XXH32 and XXH64 was that their performance was
+ * sub-optimal on short lengths. It used an iterative algorithm which strongly
+ * favored lengths that were a multiple of 4 or 8.
+ *
+ * Instead of iterating over individual inputs, we use a set of single shot
+ * functions which piece together a range of lengths and operate in constant time.
+ *
+ * Additionally, the number of multiplies has been significantly reduced. This
+ * reduces latency, especially when emulating 64-bit multiplies on 32-bit.
+ *
+ * Depending on the platform, this may or may not be faster than XXH32, but it
+ * is almost guaranteed to be faster than XXH64.
+ */
+
+/*
+ * At very short lengths, there isn't enough input to fully hide secrets, or use
+ * the entire secret.
+ *
+ * There is also only a limited amount of mixing we can do before significantly
+ * impacting performance.
+ *
+ * Therefore, we use different sections of the secret and always mix two secret
+ * samples with an XOR. This should have no effect on performance on the
+ * seedless or withSeed variants because everything _should_ be constant folded
+ * by modern compilers.
+ *
+ * The XOR mixing hides individual parts of the secret and increases entropy.
+ *
+ * This adds an extra layer of strength for custom secrets.
+ */
+XXH_FORCE_INLINE XXH_PUREF XXH64_hash_t
+XXH3_len_1to3_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(1 <= len && len <= 3);
+    XXH_ASSERT(secret != NULL);
+    /*
+     * len = 1: combined = { input[0], 0x01, input[0], input[0] }
+     * len = 2: combined = { input[1], 0x02, input[0], input[1] }
+     * len = 3: combined = { input[2], 0x03, input[0], input[1] }
+     */
+    {   xxh_u8  const c1 = input[0];
+        xxh_u8  const c2 = input[len >> 1];
+        xxh_u8  const c3 = input[len - 1];
+        xxh_u32 const combined = ((xxh_u32)c1 << 16) | ((xxh_u32)c2  << 24)
+                               | ((xxh_u32)c3 <<  0) | ((xxh_u32)len << 8);
+        xxh_u64 const bitflip = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
+        xxh_u64 const keyed = (xxh_u64)combined ^ bitflip;
+        return XXH64_avalanche(keyed);
+    }
+}
+
+XXH_FORCE_INLINE XXH_PUREF XXH64_hash_t
+XXH3_len_4to8_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(secret != NULL);
+    XXH_ASSERT(4 <= len && len <= 8);
+    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
+    {   xxh_u32 const input1 = XXH_readLE32(input);
+        xxh_u32 const input2 = XXH_readLE32(input + len - 4);
+        xxh_u64 const bitflip = (XXH_readLE64(secret+8) ^ XXH_readLE64(secret+16)) - seed;
+        xxh_u64 const input64 = input2 + (((xxh_u64)input1) << 32);
+        xxh_u64 const keyed = input64 ^ bitflip;
+        return XXH3_rrmxmx(keyed, len);
+    }
+}
+
+XXH_FORCE_INLINE XXH_PUREF XXH64_hash_t
+XXH3_len_9to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(secret != NULL);
+    XXH_ASSERT(9 <= len && len <= 16);
+    {   xxh_u64 const bitflip1 = (XXH_readLE64(secret+24) ^ XXH_readLE64(secret+32)) + seed;
+        xxh_u64 const bitflip2 = (XXH_readLE64(secret+40) ^ XXH_readLE64(secret+48)) - seed;
+        xxh_u64 const input_lo = XXH_readLE64(input)           ^ bitflip1;
+        xxh_u64 const input_hi = XXH_readLE64(input + len - 8) ^ bitflip2;
+        xxh_u64 const acc = len
+                          + XXH_swap64(input_lo) + input_hi
+                          + XXH3_mul128_fold64(input_lo, input_hi);
+        return XXH3_avalanche(acc);
+    }
+}
+
+XXH_FORCE_INLINE XXH_PUREF XXH64_hash_t
+XXH3_len_0to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(len <= 16);
+    {   if (XXH_likely(len >  8)) return XXH3_len_9to16_64b(input, len, secret, seed);
+        if (XXH_likely(len >= 4)) return XXH3_len_4to8_64b(input, len, secret, seed);
+        if (len) return XXH3_len_1to3_64b(input, len, secret, seed);
+        return XXH64_avalanche(seed ^ (XXH_readLE64(secret+56) ^ XXH_readLE64(secret+64)));
+    }
+}
+
+/*
+ * DISCLAIMER: There are known *seed-dependent* multicollisions here due to
+ * multiplication by zero, affecting hashes of lengths 17 to 240.
+ *
+ * However, they are very unlikely.
+ *
+ * Keep this in mind when using the unseeded XXH3_64bits() variant: As with all
+ * unseeded non-cryptographic hashes, it does not attempt to defend itself
+ * against specially crafted inputs, only random inputs.
+ *
+ * Compared to classic UMAC where a 1 in 2^31 chance of 4 consecutive bytes
+ * cancelling out the secret is taken an arbitrary number of times (addressed
+ * in XXH3_accumulate_512), this collision is very unlikely with random inputs
+ * and/or proper seeding:
+ *
+ * This only has a 1 in 2^63 chance of 8 consecutive bytes cancelling out, in a
+ * function that is only called up to 16 times per hash with up to 240 bytes of
+ * input.
+ *
+ * This is not too bad for a non-cryptographic hash function, especially with
+ * only 64 bit outputs.
+ *
+ * The 128-bit variant (which trades some speed for strength) is NOT affected
+ * by this, although it is always a good idea to use a proper seed if you care
+ * about strength.
+ */
+XXH_FORCE_INLINE xxh_u64 XXH3_mix16B(const xxh_u8* XXH_RESTRICT input,
+                                     const xxh_u8* XXH_RESTRICT secret, xxh_u64 seed64)
+{
+#if defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__i386__) && defined(__SSE2__)  /* x86 + SSE2 */ \
+  && !defined(XXH_ENABLE_AUTOVECTORIZE)      /* Define to disable like XXH32 hack */
+    /*
+     * UGLY HACK:
+     * GCC for x86 tends to autovectorize the 128-bit multiply, resulting in
+     * slower code.
+     *
+     * By forcing seed64 into a register, we disrupt the cost model and
+     * cause it to scalarize. See `XXH32_round()`
+     *
+     * FIXME: Clang's output is still _much_ faster -- On an AMD Ryzen 3600,
+     * XXH3_64bits @ len=240 runs at 4.6 GB/s with Clang 9, but 3.3 GB/s on
+     * GCC 9.2, despite both emitting scalar code.
+     *
+     * GCC generates much better scalar code than Clang for the rest of XXH3,
+     * which is why finding a more optimal codepath is an interest.
+     */
+    XXH_COMPILER_GUARD(seed64);
+#endif
+    {   xxh_u64 const input_lo = XXH_readLE64(input);
+        xxh_u64 const input_hi = XXH_readLE64(input+8);
+        return XXH3_mul128_fold64(
+            input_lo ^ (XXH_readLE64(secret)   + seed64),
+            input_hi ^ (XXH_readLE64(secret+8) - seed64)
+        );
+    }
+}
+
+/* For mid range keys, XXH3 uses a Mum-hash variant. */
+XXH_FORCE_INLINE XXH_PUREF XXH64_hash_t
+XXH3_len_17to128_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                     const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                     XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(16 < len && len <= 128);
+
+    {   xxh_u64 acc = len * XXH_PRIME64_1;
+#if XXH_SIZE_OPT >= 1
+        /* Smaller and cleaner, but slightly slower. */
+        unsigned int i = (unsigned int)(len - 1) / 32;
+        do {
+            acc += XXH3_mix16B(input+16 * i, secret+32*i, seed);
+            acc += XXH3_mix16B(input+len-16*(i+1), secret+32*i+16, seed);
+        } while (i-- != 0);
+#else
+        if (len > 32) {
+            if (len > 64) {
+                if (len > 96) {
+                    acc += XXH3_mix16B(input+48, secret+96, seed);
+                    acc += XXH3_mix16B(input+len-64, secret+112, seed);
+                }
+                acc += XXH3_mix16B(input+32, secret+64, seed);
+                acc += XXH3_mix16B(input+len-48, secret+80, seed);
+            }
+            acc += XXH3_mix16B(input+16, secret+32, seed);
+            acc += XXH3_mix16B(input+len-32, secret+48, seed);
+        }
+        acc += XXH3_mix16B(input+0, secret+0, seed);
+        acc += XXH3_mix16B(input+len-16, secret+16, seed);
+#endif
+        return XXH3_avalanche(acc);
+    }
+}
+
+XXH_NO_INLINE XXH_PUREF XXH64_hash_t
+XXH3_len_129to240_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                      XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);
+
+    #define XXH3_MIDSIZE_STARTOFFSET 3
+    #define XXH3_MIDSIZE_LASTOFFSET  17
+
+    {   xxh_u64 acc = len * XXH_PRIME64_1;
+        xxh_u64 acc_end;
+        unsigned int const nbRounds = (unsigned int)len / 16;
+        unsigned int i;
+        XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);
+        for (i=0; i<8; i++) {
+            acc += XXH3_mix16B(input+(16*i), secret+(16*i), seed);
+        }
+        /* last bytes */
+        acc_end = XXH3_mix16B(input + len - 16, secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET, seed);
+        XXH_ASSERT(nbRounds >= 8);
+        acc = XXH3_avalanche(acc);
+#if defined(__clang__)                                /* Clang */ \
+    && (defined(__ARM_NEON) || defined(__ARM_NEON__)) /* NEON */ \
+    && !defined(XXH_ENABLE_AUTOVECTORIZE)             /* Define to disable */
+        /*
+         * UGLY HACK:
+         * Clang for ARMv7-A tries to vectorize this loop, similar to GCC x86.
+         * In everywhere else, it uses scalar code.
+         *
+         * For 64->128-bit multiplies, even if the NEON was 100% optimal, it
+         * would still be slower than UMAAL (see XXH_mult64to128).
+         *
+         * Unfortunately, Clang doesn't handle the long multiplies properly and
+         * converts them to the nonexistent "vmulq_u64" intrinsic, which is then
+         * scalarized into an ugly mess of VMOV.32 instructions.
+         *
+         * This mess is difficult to avoid without turning autovectorization
+         * off completely, but they are usually relatively minor and/or not
+         * worth it to fix.
+         *
+         * This loop is the easiest to fix, as unlike XXH32, this pragma
+         * _actually works_ because it is a loop vectorization instead of an
+         * SLP vectorization.
+         */
+        #pragma clang loop vectorize(disable)
+#endif
+        for (i=8 ; i < nbRounds; i++) {
+            /*
+             * Prevents clang for unrolling the acc loop and interleaving with this one.
+             */
+            XXH_COMPILER_GUARD(acc);
+            acc_end += XXH3_mix16B(input+(16*i), secret+(16*(i-8)) + XXH3_MIDSIZE_STARTOFFSET, seed);
+        }
+        return XXH3_avalanche(acc + acc_end);
+    }
+}
+
+
+/* =======     Long Keys     ======= */
+
+#define XXH_STRIPE_LEN 64
+#define XXH_SECRET_CONSUME_RATE 8   /* nb of secret bytes consumed at each accumulation */
+#define XXH_ACC_NB (XXH_STRIPE_LEN / sizeof(xxh_u64))
+
+#ifdef XXH_OLD_NAMES
+#  define STRIPE_LEN XXH_STRIPE_LEN
+#  define ACC_NB XXH_ACC_NB
+#endif
+
+#ifndef XXH_PREFETCH_DIST
+#  ifdef __clang__
+#    define XXH_PREFETCH_DIST 320
+#  else
+#    if (XXH_VECTOR == XXH_AVX512)
+#      define XXH_PREFETCH_DIST 512
+#    else
+#      define XXH_PREFETCH_DIST 384
+#    endif
+#  endif  /* __clang__ */
+#endif  /* XXH_PREFETCH_DIST */
+
+/*
+ * These macros are to generate an XXH3_accumulate() function.
+ * The two arguments select the name suffix and target attribute.
+ *
+ * The name of this symbol is XXH3_accumulate_<name>() and it calls
+ * XXH3_accumulate_512_<name>().
+ *
+ * It may be useful to hand implement this function if the compiler fails to
+ * optimize the inline function.
+ */
+#define XXH3_ACCUMULATE_TEMPLATE(name)                      \
+void                                                        \
+XXH3_accumulate_##name(xxh_u64* XXH_RESTRICT acc,           \
+                       const xxh_u8* XXH_RESTRICT input,    \
+                       const xxh_u8* XXH_RESTRICT secret,   \
+                       size_t nbStripes)                    \
+{                                                           \
+    size_t n;                                               \
+    for (n = 0; n < nbStripes; n++ ) {                      \
+        const xxh_u8* const in = input + n*XXH_STRIPE_LEN;  \
+        XXH_PREFETCH(in + XXH_PREFETCH_DIST);               \
+        XXH3_accumulate_512_##name(                         \
+                 acc,                                       \
+                 in,                                        \
+                 secret + n*XXH_SECRET_CONSUME_RATE);       \
+    }                                                       \
+}
+
+
+XXH_FORCE_INLINE void XXH_writeLE64(void* dst, xxh_u64 v64)
+{
+    if (!XXH_CPU_LITTLE_ENDIAN) v64 = XXH_swap64(v64);
+    XXH_memcpy(dst, &v64, sizeof(v64));
+}
+
+/* Several intrinsic functions below are supposed to accept __int64 as argument,
+ * as documented in https://software.intel.com/sites/landingpage/IntrinsicsGuide/ .
+ * However, several environments do not define __int64 type,
+ * requiring a workaround.
+ */
+#if !defined (__VMS) \
+  && (defined (__cplusplus) \
+  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+    typedef int64_t xxh_i64;
+#else
+    /* the following type must have a width of 64-bit */
+    typedef long long xxh_i64;
+#endif
+
+
+/*
+ * XXH3_accumulate_512 is the tightest loop for long inputs, and it is the most optimized.
+ *
+ * It is a hardened version of UMAC, based off of FARSH's implementation.
+ *
+ * This was chosen because it adapts quite well to 32-bit, 64-bit, and SIMD
+ * implementations, and it is ridiculously fast.
+ *
+ * We harden it by mixing the original input to the accumulators as well as the product.
+ *
+ * This means that in the (relatively likely) case of a multiply by zero, the
+ * original input is preserved.
+ *
+ * On 128-bit inputs, we swap 64-bit pairs when we add the input to improve
+ * cross-pollination, as otherwise the upper and lower halves would be
+ * essentially independent.
+ *
+ * This doesn't matter on 64-bit hashes since they all get merged together in
+ * the end, so we skip the extra step.
+ *
+ * Both XXH3_64bits and XXH3_128bits use this subroutine.
+ */
+
+#if (XXH_VECTOR == XXH_AVX512) \
+     || (defined(XXH_DISPATCH_AVX512) && XXH_DISPATCH_AVX512 != 0)
+
+#ifndef XXH_TARGET_AVX512
+# define XXH_TARGET_AVX512  /* disable attribute target */
+#endif
+
+XXH_FORCE_INLINE XXH_TARGET_AVX512 void
+XXH3_accumulate_512_avx512(void* XXH_RESTRICT acc,
+                     const void* XXH_RESTRICT input,
+                     const void* XXH_RESTRICT secret)
+{
+    __m512i* const xacc = (__m512i *) acc;
+    XXH_ASSERT((((size_t)acc) & 63) == 0);
+    XXH_STATIC_ASSERT(XXH_STRIPE_LEN == sizeof(__m512i));
+
+    {
+        /* data_vec    = input[0]; */
+        __m512i const data_vec    = _mm512_loadu_si512   (input);
+        /* key_vec     = secret[0]; */
+        __m512i const key_vec     = _mm512_loadu_si512   (secret);
+        /* data_key    = data_vec ^ key_vec; */
+        __m512i const data_key    = _mm512_xor_si512     (data_vec, key_vec);
+        /* data_key_lo = data_key >> 32; */
+        __m512i const data_key_lo = _mm512_srli_epi64 (data_key, 32);
+        /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
+        __m512i const product     = _mm512_mul_epu32     (data_key, data_key_lo);
+        /* xacc[0] += swap(data_vec); */
+        __m512i const data_swap = _mm512_shuffle_epi32(data_vec, (_MM_PERM_ENUM)_MM_SHUFFLE(1, 0, 3, 2));
+        __m512i const sum       = _mm512_add_epi64(*xacc, data_swap);
+        /* xacc[0] += product; */
+        *xacc = _mm512_add_epi64(product, sum);
+    }
+}
+XXH_FORCE_INLINE XXH_TARGET_AVX512 XXH3_ACCUMULATE_TEMPLATE(avx512)
+
+/*
+ * XXH3_scrambleAcc: Scrambles the accumulators to improve mixing.
+ *
+ * Multiplication isn't perfect, as explained by Google in HighwayHash:
+ *
+ *  // Multiplication mixes/scrambles bytes 0-7 of the 64-bit result to
+ *  // varying degrees. In descending order of goodness, bytes
+ *  // 3 4 2 5 1 6 0 7 have quality 228 224 164 160 100 96 36 32.
+ *  // As expected, the upper and lower bytes are much worse.
+ *
+ * Source: https://github.com/google/highwayhash/blob/0aaf66b/highwayhash/hh_avx2.h#L291
+ *
+ * Since our algorithm uses a pseudorandom secret to add some variance into the
+ * mix, we don't need to (or want to) mix as often or as much as HighwayHash does.
+ *
+ * This isn't as tight as XXH3_accumulate, but still written in SIMD to avoid
+ * extraction.
+ *
+ * Both XXH3_64bits and XXH3_128bits use this subroutine.
+ */
+
+XXH_FORCE_INLINE XXH_TARGET_AVX512 void
+XXH3_scrambleAcc_avx512(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 63) == 0);
+    XXH_STATIC_ASSERT(XXH_STRIPE_LEN == sizeof(__m512i));
+    {   __m512i* const xacc = (__m512i*) acc;
+        const __m512i prime32 = _mm512_set1_epi32((int)XXH_PRIME32_1);
+
+        /* xacc[0] ^= (xacc[0] >> 47) */
+        __m512i const acc_vec     = *xacc;
+        __m512i const shifted     = _mm512_srli_epi64    (acc_vec, 47);
+        /* xacc[0] ^= secret; */
+        __m512i const key_vec     = _mm512_loadu_si512   (secret);
+        __m512i const data_key    = _mm512_ternarylogic_epi32(key_vec, acc_vec, shifted, 0x96 /* key_vec ^ acc_vec ^ shifted */);
+
+        /* xacc[0] *= XXH_PRIME32_1; */
+        __m512i const data_key_hi = _mm512_srli_epi64 (data_key, 32);
+        __m512i const prod_lo     = _mm512_mul_epu32     (data_key, prime32);
+        __m512i const prod_hi     = _mm512_mul_epu32     (data_key_hi, prime32);
+        *xacc = _mm512_add_epi64(prod_lo, _mm512_slli_epi64(prod_hi, 32));
+    }
+}
+
+XXH_FORCE_INLINE XXH_TARGET_AVX512 void
+XXH3_initCustomSecret_avx512(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
+{
+    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 63) == 0);
+    XXH_STATIC_ASSERT(XXH_SEC_ALIGN == 64);
+    XXH_ASSERT(((size_t)customSecret & 63) == 0);
+    (void)(&XXH_writeLE64);
+    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / sizeof(__m512i);
+        __m512i const seed_pos = _mm512_set1_epi64((xxh_i64)seed64);
+        __m512i const seed     = _mm512_mask_sub_epi64(seed_pos, 0xAA, _mm512_set1_epi8(0), seed_pos);
+
+        const __m512i* const src  = (const __m512i*) ((const void*) XXH3_kSecret);
+              __m512i* const dest = (      __m512i*) customSecret;
+        int i;
+        XXH_ASSERT(((size_t)src & 63) == 0); /* control alignment */
+        XXH_ASSERT(((size_t)dest & 63) == 0);
+        for (i=0; i < nbRounds; ++i) {
+            dest[i] = _mm512_add_epi64(_mm512_load_si512(src + i), seed);
+    }   }
+}
+
+#endif
+
+#if (XXH_VECTOR == XXH_AVX2) \
+    || (defined(XXH_DISPATCH_AVX2) && XXH_DISPATCH_AVX2 != 0)
+
+#ifndef XXH_TARGET_AVX2
+# define XXH_TARGET_AVX2  /* disable attribute target */
+#endif
+
+XXH_FORCE_INLINE XXH_TARGET_AVX2 void
+XXH3_accumulate_512_avx2( void* XXH_RESTRICT acc,
+                    const void* XXH_RESTRICT input,
+                    const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 31) == 0);
+    {   __m256i* const xacc    =       (__m256i *) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires  a const __m256i * pointer for some reason. */
+        const         __m256i* const xinput  = (const __m256i *) input;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
+        const         __m256i* const xsecret = (const __m256i *) secret;
+
+        size_t i;
+        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m256i); i++) {
+            /* data_vec    = xinput[i]; */
+            __m256i const data_vec    = _mm256_loadu_si256    (xinput+i);
+            /* key_vec     = xsecret[i]; */
+            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
+            /* data_key    = data_vec ^ key_vec; */
+            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
+            /* data_key_lo = data_key >> 32; */
+            __m256i const data_key_lo = _mm256_srli_epi64 (data_key, 32);
+            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
+            __m256i const product     = _mm256_mul_epu32     (data_key, data_key_lo);
+            /* xacc[i] += swap(data_vec); */
+            __m256i const data_swap = _mm256_shuffle_epi32(data_vec, _MM_SHUFFLE(1, 0, 3, 2));
+            __m256i const sum       = _mm256_add_epi64(xacc[i], data_swap);
+            /* xacc[i] += product; */
+            xacc[i] = _mm256_add_epi64(product, sum);
+    }   }
+}
+XXH_FORCE_INLINE XXH_TARGET_AVX2 XXH3_ACCUMULATE_TEMPLATE(avx2)
+
+XXH_FORCE_INLINE XXH_TARGET_AVX2 void
+XXH3_scrambleAcc_avx2(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 31) == 0);
+    {   __m256i* const xacc = (__m256i*) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
+        const         __m256i* const xsecret = (const __m256i *) secret;
+        const __m256i prime32 = _mm256_set1_epi32((int)XXH_PRIME32_1);
+
+        size_t i;
+        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m256i); i++) {
+            /* xacc[i] ^= (xacc[i] >> 47) */
+            __m256i const acc_vec     = xacc[i];
+            __m256i const shifted     = _mm256_srli_epi64    (acc_vec, 47);
+            __m256i const data_vec    = _mm256_xor_si256     (acc_vec, shifted);
+            /* xacc[i] ^= xsecret; */
+            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
+            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
+
+            /* xacc[i] *= XXH_PRIME32_1; */
+            __m256i const data_key_hi = _mm256_srli_epi64 (data_key, 32);
+            __m256i const prod_lo     = _mm256_mul_epu32     (data_key, prime32);
+            __m256i const prod_hi     = _mm256_mul_epu32     (data_key_hi, prime32);
+            xacc[i] = _mm256_add_epi64(prod_lo, _mm256_slli_epi64(prod_hi, 32));
+        }
+    }
+}
+
+XXH_FORCE_INLINE XXH_TARGET_AVX2 void XXH3_initCustomSecret_avx2(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
+{
+    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 31) == 0);
+    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE / sizeof(__m256i)) == 6);
+    XXH_STATIC_ASSERT(XXH_SEC_ALIGN <= 64);
+    (void)(&XXH_writeLE64);
+    XXH_PREFETCH(customSecret);
+    {   __m256i const seed = _mm256_set_epi64x((xxh_i64)(0U - seed64), (xxh_i64)seed64, (xxh_i64)(0U - seed64), (xxh_i64)seed64);
+
+        const __m256i* const src  = (const __m256i*) ((const void*) XXH3_kSecret);
+              __m256i*       dest = (      __m256i*) customSecret;
+
+#       if defined(__GNUC__) || defined(__clang__)
+        /*
+         * On GCC & Clang, marking 'dest' as modified will cause the compiler:
+         *   - do not extract the secret from sse registers in the internal loop
+         *   - use less common registers, and avoid pushing these reg into stack
+         */
+        XXH_COMPILER_GUARD(dest);
+#       endif
+        XXH_ASSERT(((size_t)src & 31) == 0); /* control alignment */
+        XXH_ASSERT(((size_t)dest & 31) == 0);
+
+        /* GCC -O2 need unroll loop manually */
+        dest[0] = _mm256_add_epi64(_mm256_load_si256(src+0), seed);
+        dest[1] = _mm256_add_epi64(_mm256_load_si256(src+1), seed);
+        dest[2] = _mm256_add_epi64(_mm256_load_si256(src+2), seed);
+        dest[3] = _mm256_add_epi64(_mm256_load_si256(src+3), seed);
+        dest[4] = _mm256_add_epi64(_mm256_load_si256(src+4), seed);
+        dest[5] = _mm256_add_epi64(_mm256_load_si256(src+5), seed);
+    }
+}
+
+#endif
+
+/* x86dispatch always generates SSE2 */
+#if (XXH_VECTOR == XXH_SSE2) || defined(XXH_X86DISPATCH)
+
+#ifndef XXH_TARGET_SSE2
+# define XXH_TARGET_SSE2  /* disable attribute target */
+#endif
+
+XXH_FORCE_INLINE XXH_TARGET_SSE2 void
+XXH3_accumulate_512_sse2( void* XXH_RESTRICT acc,
+                    const void* XXH_RESTRICT input,
+                    const void* XXH_RESTRICT secret)
+{
+    /* SSE2 is just a half-scale version of the AVX2 version. */
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+    {   __m128i* const xacc    =       (__m128i *) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xinput  = (const __m128i *) input;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xsecret = (const __m128i *) secret;
+
+        size_t i;
+        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m128i); i++) {
+            /* data_vec    = xinput[i]; */
+            __m128i const data_vec    = _mm_loadu_si128   (xinput+i);
+            /* key_vec     = xsecret[i]; */
+            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
+            /* data_key    = data_vec ^ key_vec; */
+            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
+            /* data_key_lo = data_key >> 32; */
+            __m128i const data_key_lo = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
+            __m128i const product     = _mm_mul_epu32     (data_key, data_key_lo);
+            /* xacc[i] += swap(data_vec); */
+            __m128i const data_swap = _mm_shuffle_epi32(data_vec, _MM_SHUFFLE(1,0,3,2));
+            __m128i const sum       = _mm_add_epi64(xacc[i], data_swap);
+            /* xacc[i] += product; */
+            xacc[i] = _mm_add_epi64(product, sum);
+    }   }
+}
+XXH_FORCE_INLINE XXH_TARGET_SSE2 XXH3_ACCUMULATE_TEMPLATE(sse2)
+
+XXH_FORCE_INLINE XXH_TARGET_SSE2 void
+XXH3_scrambleAcc_sse2(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+    {   __m128i* const xacc = (__m128i*) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xsecret = (const __m128i *) secret;
+        const __m128i prime32 = _mm_set1_epi32((int)XXH_PRIME32_1);
+
+        size_t i;
+        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m128i); i++) {
+            /* xacc[i] ^= (xacc[i] >> 47) */
+            __m128i const acc_vec     = xacc[i];
+            __m128i const shifted     = _mm_srli_epi64    (acc_vec, 47);
+            __m128i const data_vec    = _mm_xor_si128     (acc_vec, shifted);
+            /* xacc[i] ^= xsecret[i]; */
+            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
+            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
+
+            /* xacc[i] *= XXH_PRIME32_1; */
+            __m128i const data_key_hi = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            __m128i const prod_lo     = _mm_mul_epu32     (data_key, prime32);
+            __m128i const prod_hi     = _mm_mul_epu32     (data_key_hi, prime32);
+            xacc[i] = _mm_add_epi64(prod_lo, _mm_slli_epi64(prod_hi, 32));
+        }
+    }
+}
+
+XXH_FORCE_INLINE XXH_TARGET_SSE2 void XXH3_initCustomSecret_sse2(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
+{
+    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 15) == 0);
+    (void)(&XXH_writeLE64);
+    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / sizeof(__m128i);
+
+#       if defined(_MSC_VER) && defined(_M_IX86) && _MSC_VER < 1900
+        /* MSVC 32bit mode does not support _mm_set_epi64x before 2015 */
+        XXH_ALIGN(16) const xxh_i64 seed64x2[2] = { (xxh_i64)seed64, (xxh_i64)(0U - seed64) };
+        __m128i const seed = _mm_load_si128((__m128i const*)seed64x2);
+#       else
+        __m128i const seed = _mm_set_epi64x((xxh_i64)(0U - seed64), (xxh_i64)seed64);
+#       endif
+        int i;
+
+        const void* const src16 = XXH3_kSecret;
+        __m128i* dst16 = (__m128i*) customSecret;
+#       if defined(__GNUC__) || defined(__clang__)
+        /*
+         * On GCC & Clang, marking 'dest' as modified will cause the compiler:
+         *   - do not extract the secret from sse registers in the internal loop
+         *   - use less common registers, and avoid pushing these reg into stack
+         */
+        XXH_COMPILER_GUARD(dst16);
+#       endif
+        XXH_ASSERT(((size_t)src16 & 15) == 0); /* control alignment */
+        XXH_ASSERT(((size_t)dst16 & 15) == 0);
+
+        for (i=0; i < nbRounds; ++i) {
+            dst16[i] = _mm_add_epi64(_mm_load_si128((const __m128i *)src16+i), seed);
+    }   }
+}
+
+#endif
+
+#if (XXH_VECTOR == XXH_NEON)
+
+/* forward declarations for the scalar routines */
+XXH_FORCE_INLINE void
+XXH3_scalarRound(void* XXH_RESTRICT acc, void const* XXH_RESTRICT input,
+                 void const* XXH_RESTRICT secret, size_t lane);
+
+XXH_FORCE_INLINE void
+XXH3_scalarScrambleRound(void* XXH_RESTRICT acc,
+                         void const* XXH_RESTRICT secret, size_t lane);
+
+/*!
+ * @internal
+ * @brief The bulk processing loop for NEON and WASM SIMD128.
+ *
+ * The NEON code path is actually partially scalar when running on AArch64. This
+ * is to optimize the pipelining and can have up to 15% speedup depending on the
+ * CPU, and it also mitigates some GCC codegen issues.
+ *
+ * @see XXH3_NEON_LANES for configuring this and details about this optimization.
+ *
+ * NEON's 32-bit to 64-bit long multiply takes a half vector of 32-bit
+ * integers instead of the other platforms which mask full 64-bit vectors,
+ * so the setup is more complicated than just shifting right.
+ *
+ * Additionally, there is an optimization for 4 lanes at once noted below.
+ *
+ * Since, as stated, the most optimal amount of lanes for Cortexes is 6,
+ * there needs to be *three* versions of the accumulate operation used
+ * for the remaining 2 lanes.
+ *
+ * WASM's SIMD128 uses SIMDe's arm_neon.h polyfill because the intrinsics overlap
+ * nearly perfectly.
+ */
+
+XXH_FORCE_INLINE void
+XXH3_accumulate_512_neon( void* XXH_RESTRICT acc,
+                    const void* XXH_RESTRICT input,
+                    const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+    XXH_STATIC_ASSERT(XXH3_NEON_LANES > 0 && XXH3_NEON_LANES <= XXH_ACC_NB && XXH3_NEON_LANES % 2 == 0);
+    {   /* GCC for darwin arm64 does not like aliasing here */
+        xxh_aliasing_uint64x2_t* const xacc = (xxh_aliasing_uint64x2_t*) acc;
+        /* We don't use a uint32x4_t pointer because it causes bus errors on ARMv7. */
+        uint8_t const* xinput = (const uint8_t *) input;
+        uint8_t const* xsecret  = (const uint8_t *) secret;
+
+        size_t i;
+#ifdef __wasm_simd128__
+        /*
+         * On WASM SIMD128, Clang emits direct address loads when XXH3_kSecret
+         * is constant propagated, which results in it converting it to this
+         * inside the loop:
+         *
+         *    a = v128.load(XXH3_kSecret +  0 + $secret_offset, offset = 0)
+         *    b = v128.load(XXH3_kSecret + 16 + $secret_offset, offset = 0)
+         *    ...
+         *
+         * This requires a full 32-bit address immediate (and therefore a 6 byte
+         * instruction) as well as an add for each offset.
+         *
+         * Putting an asm guard prevents it from folding (at the cost of losing
+         * the alignment hint), and uses the free offset in `v128.load` instead
+         * of adding secret_offset each time which overall reduces code size by
+         * about a kilobyte and improves performance.
+         */
+        XXH_COMPILER_GUARD(xsecret);
+#endif
+        /* Scalar lanes use the normal scalarRound routine */
+        for (i = XXH3_NEON_LANES; i < XXH_ACC_NB; i++) {
+            XXH3_scalarRound(acc, input, secret, i);
+        }
+        i = 0;
+        /* 4 NEON lanes at a time. */
+        for (; i+1 < XXH3_NEON_LANES / 2; i+=2) {
+            /* data_vec = xinput[i]; */
+            uint64x2_t data_vec_1 = XXH_vld1q_u64(xinput  + (i * 16));
+            uint64x2_t data_vec_2 = XXH_vld1q_u64(xinput  + ((i+1) * 16));
+            /* key_vec  = xsecret[i];  */
+            uint64x2_t key_vec_1  = XXH_vld1q_u64(xsecret + (i * 16));
+            uint64x2_t key_vec_2  = XXH_vld1q_u64(xsecret + ((i+1) * 16));
+            /* data_swap = swap(data_vec) */
+            uint64x2_t data_swap_1 = vextq_u64(data_vec_1, data_vec_1, 1);
+            uint64x2_t data_swap_2 = vextq_u64(data_vec_2, data_vec_2, 1);
+            /* data_key = data_vec ^ key_vec; */
+            uint64x2_t data_key_1 = veorq_u64(data_vec_1, key_vec_1);
+            uint64x2_t data_key_2 = veorq_u64(data_vec_2, key_vec_2);
+
+            /*
+             * If we reinterpret the 64x2 vectors as 32x4 vectors, we can use a
+             * de-interleave operation for 4 lanes in 1 step with `vuzpq_u32` to
+             * get one vector with the low 32 bits of each lane, and one vector
+             * with the high 32 bits of each lane.
+             *
+             * The intrinsic returns a double vector because the original ARMv7-a
+             * instruction modified both arguments in place. AArch64 and SIMD128 emit
+             * two instructions from this intrinsic.
+             *
+             *  [ dk11L | dk11H | dk12L | dk12H ] -> [ dk11L | dk12L | dk21L | dk22L ]
+             *  [ dk21L | dk21H | dk22L | dk22H ] -> [ dk11H | dk12H | dk21H | dk22H ]
+             */
+            uint32x4x2_t unzipped = vuzpq_u32(
+                vreinterpretq_u32_u64(data_key_1),
+                vreinterpretq_u32_u64(data_key_2)
+            );
+            /* data_key_lo = data_key & 0xFFFFFFFF */
+            uint32x4_t data_key_lo = unzipped.val[0];
+            /* data_key_hi = data_key >> 32 */
+            uint32x4_t data_key_hi = unzipped.val[1];
+            /*
+             * Then, we can split the vectors horizontally and multiply which, as for most
+             * widening intrinsics, have a variant that works on both high half vectors
+             * for free on AArch64. A similar instruction is available on SIMD128.
+             *
+             * sum = data_swap + (u64x2) data_key_lo * (u64x2) data_key_hi
+             */
+            uint64x2_t sum_1 = XXH_vmlal_low_u32(data_swap_1, data_key_lo, data_key_hi);
+            uint64x2_t sum_2 = XXH_vmlal_high_u32(data_swap_2, data_key_lo, data_key_hi);
+            /*
+             * Clang reorders
+             *    a += b * c;     // umlal   swap.2d, dkl.2s, dkh.2s
+             *    c += a;         // add     acc.2d, acc.2d, swap.2d
+             * to
+             *    c += a;         // add     acc.2d, acc.2d, swap.2d
+             *    c += b * c;     // umlal   acc.2d, dkl.2s, dkh.2s
+             *
+             * While it would make sense in theory since the addition is faster,
+             * for reasons likely related to umlal being limited to certain NEON
+             * pipelines, this is worse. A compiler guard fixes this.
+             */
+            XXH_COMPILER_GUARD_CLANG_NEON(sum_1);
+            XXH_COMPILER_GUARD_CLANG_NEON(sum_2);
+            /* xacc[i] = acc_vec + sum; */
+            xacc[i]   = vaddq_u64(xacc[i], sum_1);
+            xacc[i+1] = vaddq_u64(xacc[i+1], sum_2);
+        }
+        /* Operate on the remaining NEON lanes 2 at a time. */
+        for (; i < XXH3_NEON_LANES / 2; i++) {
+            /* data_vec = xinput[i]; */
+            uint64x2_t data_vec = XXH_vld1q_u64(xinput  + (i * 16));
+            /* key_vec  = xsecret[i];  */
+            uint64x2_t key_vec  = XXH_vld1q_u64(xsecret + (i * 16));
+            /* acc_vec_2 = swap(data_vec) */
+            uint64x2_t data_swap = vextq_u64(data_vec, data_vec, 1);
+            /* data_key = data_vec ^ key_vec; */
+            uint64x2_t data_key = veorq_u64(data_vec, key_vec);
+            /* For two lanes, just use VMOVN and VSHRN. */
+            /* data_key_lo = data_key & 0xFFFFFFFF; */
+            uint32x2_t data_key_lo = vmovn_u64(data_key);
+            /* data_key_hi = data_key >> 32; */
+            uint32x2_t data_key_hi = vshrn_n_u64(data_key, 32);
+            /* sum = data_swap + (u64x2) data_key_lo * (u64x2) data_key_hi; */
+            uint64x2_t sum = vmlal_u32(data_swap, data_key_lo, data_key_hi);
+            /* Same Clang workaround as before */
+            XXH_COMPILER_GUARD_CLANG_NEON(sum);
+            /* xacc[i] = acc_vec + sum; */
+            xacc[i] = vaddq_u64 (xacc[i], sum);
+        }
+    }
+}
+XXH_FORCE_INLINE XXH3_ACCUMULATE_TEMPLATE(neon)
+
+XXH_FORCE_INLINE void
+XXH3_scrambleAcc_neon(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+
+    {   xxh_aliasing_uint64x2_t* xacc       = (xxh_aliasing_uint64x2_t*) acc;
+        uint8_t const* xsecret = (uint8_t const*) secret;
+
+        size_t i;
+        /* WASM uses operator overloads and doesn't need these. */
+#ifndef __wasm_simd128__
+        /* { prime32_1, prime32_1 } */
+        uint32x2_t const kPrimeLo = vdup_n_u32(XXH_PRIME32_1);
+        /* { 0, prime32_1, 0, prime32_1 } */
+        uint32x4_t const kPrimeHi = vreinterpretq_u32_u64(vdupq_n_u64((xxh_u64)XXH_PRIME32_1 << 32));
+#endif
+
+        /* AArch64 uses both scalar and neon at the same time */
+        for (i = XXH3_NEON_LANES; i < XXH_ACC_NB; i++) {
+            XXH3_scalarScrambleRound(acc, secret, i);
+        }
+        for (i=0; i < XXH3_NEON_LANES / 2; i++) {
+            /* xacc[i] ^= (xacc[i] >> 47); */
+            uint64x2_t acc_vec  = xacc[i];
+            uint64x2_t shifted  = vshrq_n_u64(acc_vec, 47);
+            uint64x2_t data_vec = veorq_u64(acc_vec, shifted);
+
+            /* xacc[i] ^= xsecret[i]; */
+            uint64x2_t key_vec  = XXH_vld1q_u64(xsecret + (i * 16));
+            uint64x2_t data_key = veorq_u64(data_vec, key_vec);
+            /* xacc[i] *= XXH_PRIME32_1 */
+#ifdef __wasm_simd128__
+            /* SIMD128 has multiply by u64x2, use it instead of expanding and scalarizing */
+            xacc[i] = data_key * XXH_PRIME32_1;
+#else
+            /*
+             * Expanded version with portable NEON intrinsics
+             *
+             *    lo(x) * lo(y) + (hi(x) * lo(y) << 32)
+             *
+             * prod_hi = hi(data_key) * lo(prime) << 32
+             *
+             * Since we only need 32 bits of this multiply a trick can be used, reinterpreting the vector
+             * as a uint32x4_t and multiplying by { 0, prime, 0, prime } to cancel out the unwanted bits
+             * and avoid the shift.
+             */
+            uint32x4_t prod_hi = vmulq_u32 (vreinterpretq_u32_u64(data_key), kPrimeHi);
+            /* Extract low bits for vmlal_u32  */
+            uint32x2_t data_key_lo = vmovn_u64(data_key);
+            /* xacc[i] = prod_hi + lo(data_key) * XXH_PRIME32_1; */
+            xacc[i] = vmlal_u32(vreinterpretq_u64_u32(prod_hi), data_key_lo, kPrimeLo);
+#endif
+        }
+    }
+}
+#endif
+
+#if (XXH_VECTOR == XXH_VSX)
+
+XXH_FORCE_INLINE void
+XXH3_accumulate_512_vsx(  void* XXH_RESTRICT acc,
+                    const void* XXH_RESTRICT input,
+                    const void* XXH_RESTRICT secret)
+{
+    /* presumed aligned */
+    xxh_aliasing_u64x2* const xacc = (xxh_aliasing_u64x2*) acc;
+    xxh_u8 const* const xinput   = (xxh_u8 const*) input;   /* no alignment restriction */
+    xxh_u8 const* const xsecret  = (xxh_u8 const*) secret;    /* no alignment restriction */
+    xxh_u64x2 const v32 = { 32, 32 };
+    size_t i;
+    for (i = 0; i < XXH_STRIPE_LEN / sizeof(xxh_u64x2); i++) {
+        /* data_vec = xinput[i]; */
+        xxh_u64x2 const data_vec = XXH_vec_loadu(xinput + 16*i);
+        /* key_vec = xsecret[i]; */
+        xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + 16*i);
+        xxh_u64x2 const data_key = data_vec ^ key_vec;
+        /* shuffled = (data_key << 32) | (data_key >> 32); */
+        xxh_u32x4 const shuffled = (xxh_u32x4)vec_rl(data_key, v32);
+        /* product = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)shuffled & 0xFFFFFFFF); */
+        xxh_u64x2 const product  = XXH_vec_mulo((xxh_u32x4)data_key, shuffled);
+        /* acc_vec = xacc[i]; */
+        xxh_u64x2 acc_vec        = xacc[i];
+        acc_vec += product;
+
+        /* swap high and low halves */
+#ifdef __s390x__
+        acc_vec += vec_permi(data_vec, data_vec, 2);
+#else
+        acc_vec += vec_xxpermdi(data_vec, data_vec, 2);
+#endif
+        xacc[i] = acc_vec;
+    }
+}
+XXH_FORCE_INLINE XXH3_ACCUMULATE_TEMPLATE(vsx)
+
+XXH_FORCE_INLINE void
+XXH3_scrambleAcc_vsx(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+
+    {   xxh_aliasing_u64x2* const xacc = (xxh_aliasing_u64x2*) acc;
+        const xxh_u8* const xsecret = (const xxh_u8*) secret;
+        /* constants */
+        xxh_u64x2 const v32  = { 32, 32 };
+        xxh_u64x2 const v47 = { 47, 47 };
+        xxh_u32x4 const prime = { XXH_PRIME32_1, XXH_PRIME32_1, XXH_PRIME32_1, XXH_PRIME32_1 };
+        size_t i;
+        for (i = 0; i < XXH_STRIPE_LEN / sizeof(xxh_u64x2); i++) {
+            /* xacc[i] ^= (xacc[i] >> 47); */
+            xxh_u64x2 const acc_vec  = xacc[i];
+            xxh_u64x2 const data_vec = acc_vec ^ (acc_vec >> v47);
+
+            /* xacc[i] ^= xsecret[i]; */
+            xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + 16*i);
+            xxh_u64x2 const data_key = data_vec ^ key_vec;
+
+            /* xacc[i] *= XXH_PRIME32_1 */
+            /* prod_lo = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)prime & 0xFFFFFFFF);  */
+            xxh_u64x2 const prod_even  = XXH_vec_mule((xxh_u32x4)data_key, prime);
+            /* prod_hi = ((xxh_u64x2)data_key >> 32) * ((xxh_u64x2)prime >> 32);  */
+            xxh_u64x2 const prod_odd  = XXH_vec_mulo((xxh_u32x4)data_key, prime);
+            xacc[i] = prod_odd + (prod_even << v32);
+    }   }
+}
+
+#endif
+
+#if (XXH_VECTOR == XXH_SVE)
+
+XXH_FORCE_INLINE void
+XXH3_accumulate_512_sve( void* XXH_RESTRICT acc,
+                   const void* XXH_RESTRICT input,
+                   const void* XXH_RESTRICT secret)
+{
+    uint64_t *xacc = (uint64_t *)acc;
+    const uint64_t *xinput = (const uint64_t *)(const void *)input;
+    const uint64_t *xsecret = (const uint64_t *)(const void *)secret;
+    svuint64_t kSwap = sveor_n_u64_z(svptrue_b64(), svindex_u64(0, 1), 1);
+    uint64_t element_count = svcntd();
+    if (element_count >= 8) {
+        svbool_t mask = svptrue_pat_b64(SV_VL8);
+        svuint64_t vacc = svld1_u64(mask, xacc);
+        ACCRND(vacc, 0);
+        svst1_u64(mask, xacc, vacc);
+    } else if (element_count == 2) {   /* sve128 */
+        svbool_t mask = svptrue_pat_b64(SV_VL2);
+        svuint64_t acc0 = svld1_u64(mask, xacc + 0);
+        svuint64_t acc1 = svld1_u64(mask, xacc + 2);
+        svuint64_t acc2 = svld1_u64(mask, xacc + 4);
+        svuint64_t acc3 = svld1_u64(mask, xacc + 6);
+        ACCRND(acc0, 0);
+        ACCRND(acc1, 2);
+        ACCRND(acc2, 4);
+        ACCRND(acc3, 6);
+        svst1_u64(mask, xacc + 0, acc0);
+        svst1_u64(mask, xacc + 2, acc1);
+        svst1_u64(mask, xacc + 4, acc2);
+        svst1_u64(mask, xacc + 6, acc3);
+    } else {
+        svbool_t mask = svptrue_pat_b64(SV_VL4);
+        svuint64_t acc0 = svld1_u64(mask, xacc + 0);
+        svuint64_t acc1 = svld1_u64(mask, xacc + 4);
+        ACCRND(acc0, 0);
+        ACCRND(acc1, 4);
+        svst1_u64(mask, xacc + 0, acc0);
+        svst1_u64(mask, xacc + 4, acc1);
+    }
+}
+
+XXH_FORCE_INLINE void
+XXH3_accumulate_sve(xxh_u64* XXH_RESTRICT acc,
+               const xxh_u8* XXH_RESTRICT input,
+               const xxh_u8* XXH_RESTRICT secret,
+               size_t nbStripes)
+{
+    if (nbStripes != 0) {
+        uint64_t *xacc = (uint64_t *)acc;
+        const uint64_t *xinput = (const uint64_t *)(const void *)input;
+        const uint64_t *xsecret = (const uint64_t *)(const void *)secret;
+        svuint64_t kSwap = sveor_n_u64_z(svptrue_b64(), svindex_u64(0, 1), 1);
+        uint64_t element_count = svcntd();
+        if (element_count >= 8) {
+            svbool_t mask = svptrue_pat_b64(SV_VL8);
+            svuint64_t vacc = svld1_u64(mask, xacc + 0);
+            do {
+                /* svprfd(svbool_t, void *, enum svfprop); */
+                svprfd(mask, xinput + 128, SV_PLDL1STRM);
+                ACCRND(vacc, 0);
+                xinput += 8;
+                xsecret += 1;
+                nbStripes--;
+           } while (nbStripes != 0);
+
+           svst1_u64(mask, xacc + 0, vacc);
+        } else if (element_count == 2) { /* sve128 */
+            svbool_t mask = svptrue_pat_b64(SV_VL2);
+            svuint64_t acc0 = svld1_u64(mask, xacc + 0);
+            svuint64_t acc1 = svld1_u64(mask, xacc + 2);
+            svuint64_t acc2 = svld1_u64(mask, xacc + 4);
+            svuint64_t acc3 = svld1_u64(mask, xacc + 6);
+            do {
+                svprfd(mask, xinput + 128, SV_PLDL1STRM);
+                ACCRND(acc0, 0);
+                ACCRND(acc1, 2);
+                ACCRND(acc2, 4);
+                ACCRND(acc3, 6);
+                xinput += 8;
+                xsecret += 1;
+                nbStripes--;
+           } while (nbStripes != 0);
+
+           svst1_u64(mask, xacc + 0, acc0);
+           svst1_u64(mask, xacc + 2, acc1);
+           svst1_u64(mask, xacc + 4, acc2);
+           svst1_u64(mask, xacc + 6, acc3);
+        } else {
+            svbool_t mask = svptrue_pat_b64(SV_VL4);
+            svuint64_t acc0 = svld1_u64(mask, xacc + 0);
+            svuint64_t acc1 = svld1_u64(mask, xacc + 4);
+            do {
+                svprfd(mask, xinput + 128, SV_PLDL1STRM);
+                ACCRND(acc0, 0);
+                ACCRND(acc1, 4);
+                xinput += 8;
+                xsecret += 1;
+                nbStripes--;
+           } while (nbStripes != 0);
+
+           svst1_u64(mask, xacc + 0, acc0);
+           svst1_u64(mask, xacc + 4, acc1);
+       }
+    }
+}
+
+#endif
+
+#if (XXH_VECTOR == XXH_LSX)
+#define _LSX_SHUFFLE(z, y, x, w) (((z) << 6) | ((y) << 4) | ((x) << 2) | (w))
+
+XXH_FORCE_INLINE void
+XXH3_accumulate_512_lsx( void* XXH_RESTRICT acc,
+                    const void* XXH_RESTRICT input,
+                    const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+    {
+        __m128i* const xacc    =       (__m128i *) acc;
+        const __m128i* const xinput  = (const __m128i *) input;
+        const __m128i* const xsecret = (const __m128i *) secret;
+
+        for (size_t i = 0; i < XXH_STRIPE_LEN / sizeof(__m128i); i++) {
+            /* data_vec = xinput[i]; */
+            __m128i const data_vec = __lsx_vld(xinput + i, 0);
+            /* key_vec = xsecret[i]; */
+            __m128i const key_vec = __lsx_vld(xsecret + i, 0);
+            /* data_key = data_vec ^ key_vec; */
+            __m128i const data_key = __lsx_vxor_v(data_vec, key_vec);
+            /* data_key_lo = data_key >> 32; */
+            __m128i const data_key_lo = __lsx_vsrli_d(data_key, 32);
+            // __m128i const data_key_lo = __lsx_vsrli_d(data_key, 32);
+            /* product = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
+            __m128i const product = __lsx_vmulwev_d_wu(data_key, data_key_lo);
+            /* xacc[i] += swap(data_vec); */
+            __m128i const data_swap = __lsx_vshuf4i_w(data_vec, _LSX_SHUFFLE(1, 0, 3, 2));
+            __m128i const sum = __lsx_vadd_d(xacc[i], data_swap);
+            /* xacc[i] += product; */
+            xacc[i] = __lsx_vadd_d(product, sum);
+        }
+    }
+}
+XXH_FORCE_INLINE XXH3_ACCUMULATE_TEMPLATE(lsx)
+
+XXH_FORCE_INLINE void
+XXH3_scrambleAcc_lsx(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+    {
+        __m128i* const xacc = (__m128i*) acc;
+        const __m128i* const xsecret = (const __m128i *) secret;
+        const __m128i prime32 = __lsx_vreplgr2vr_w((int)XXH_PRIME32_1);
+
+        for (size_t i = 0; i < XXH_STRIPE_LEN / sizeof(__m128i); i++) {
+            /* xacc[i] ^= (xacc[i] >> 47) */
+            __m128i const acc_vec = xacc[i];
+            __m128i const shifted = __lsx_vsrli_d(acc_vec, 47);
+            __m128i const data_vec = __lsx_vxor_v(acc_vec, shifted);
+            /* xacc[i] ^= xsecret[i]; */
+            __m128i const key_vec = __lsx_vld(xsecret + i, 0);
+            __m128i const data_key = __lsx_vxor_v(data_vec, key_vec);
+
+            /* xacc[i] *= XXH_PRIME32_1; */
+            __m128i const data_key_hi = __lsx_vsrli_d(data_key, 32);
+            __m128i const prod_lo = __lsx_vmulwev_d_wu(data_key, prime32);
+            __m128i const prod_hi = __lsx_vmulwev_d_wu(data_key_hi, prime32);
+            xacc[i] = __lsx_vadd_d(prod_lo, __lsx_vslli_d(prod_hi, 32));
+        }
+    }
+}
+
+#endif
+
+/* scalar variants - universal */
+
+#if defined(__aarch64__) && (defined(__GNUC__) || defined(__clang__))
+/*
+ * In XXH3_scalarRound(), GCC and Clang have a similar codegen issue, where they
+ * emit an excess mask and a full 64-bit multiply-add (MADD X-form).
+ *
+ * While this might not seem like much, as AArch64 is a 64-bit architecture, only
+ * big Cortex designs have a full 64-bit multiplier.
+ *
+ * On the little cores, the smaller 32-bit multiplier is used, and full 64-bit
+ * multiplies expand to 2-3 multiplies in microcode. This has a major penalty
+ * of up to 4 latency cycles and 2 stall cycles in the multiply pipeline.
+ *
+ * Thankfully, AArch64 still provides the 32-bit long multiply-add (UMADDL) which does
+ * not have this penalty and does the mask automatically.
+ */
+XXH_FORCE_INLINE xxh_u64
+XXH_mult32to64_add64(xxh_u64 lhs, xxh_u64 rhs, xxh_u64 acc)
+{
+    xxh_u64 ret;
+    /* note: %x = 64-bit register, %w = 32-bit register */
+    __asm__("umaddl %x0, %w1, %w2, %x3" : "=r" (ret) : "r" (lhs), "r" (rhs), "r" (acc));
+    return ret;
+}
+#else
+XXH_FORCE_INLINE xxh_u64
+XXH_mult32to64_add64(xxh_u64 lhs, xxh_u64 rhs, xxh_u64 acc)
+{
+    return XXH_mult32to64((xxh_u32)lhs, (xxh_u32)rhs) + acc;
+}
+#endif
+
+/*!
+ * @internal
+ * @brief Scalar round for @ref XXH3_accumulate_512_scalar().
+ *
+ * This is extracted to its own function because the NEON path uses a combination
+ * of NEON and scalar.
+ */
+XXH_FORCE_INLINE void
+XXH3_scalarRound(void* XXH_RESTRICT acc,
+                 void const* XXH_RESTRICT input,
+                 void const* XXH_RESTRICT secret,
+                 size_t lane)
+{
+    xxh_u64* xacc = (xxh_u64*) acc;
+    xxh_u8 const* xinput  = (xxh_u8 const*) input;
+    xxh_u8 const* xsecret = (xxh_u8 const*) secret;
+    XXH_ASSERT(lane < XXH_ACC_NB);
+    XXH_ASSERT(((size_t)acc & (XXH_ACC_ALIGN-1)) == 0);
+    {
+        xxh_u64 const data_val = XXH_readLE64(xinput + lane * 8);
+        xxh_u64 const data_key = data_val ^ XXH_readLE64(xsecret + lane * 8);
+        xacc[lane ^ 1] += data_val; /* swap adjacent lanes */
+        xacc[lane] = XXH_mult32to64_add64(data_key /* & 0xFFFFFFFF */, data_key >> 32, xacc[lane]);
+    }
+}
+
+/*!
+ * @internal
+ * @brief Processes a 64 byte block of data using the scalar path.
+ */
+XXH_FORCE_INLINE void
+XXH3_accumulate_512_scalar(void* XXH_RESTRICT acc,
+                     const void* XXH_RESTRICT input,
+                     const void* XXH_RESTRICT secret)
+{
+    size_t i;
+    /* ARM GCC refuses to unroll this loop, resulting in a 24% slowdown on ARMv6. */
+#if defined(__GNUC__) && !defined(__clang__) \
+  && (defined(__arm__) || defined(__thumb2__)) \
+  && defined(__ARM_FEATURE_UNALIGNED) /* no unaligned access just wastes bytes */ \
+  && XXH_SIZE_OPT <= 0
+#  pragma GCC unroll 8
+#endif
+    for (i=0; i < XXH_ACC_NB; i++) {
+        XXH3_scalarRound(acc, input, secret, i);
+    }
+}
+XXH_FORCE_INLINE XXH3_ACCUMULATE_TEMPLATE(scalar)
+
+/*!
+ * @internal
+ * @brief Scalar scramble step for @ref XXH3_scrambleAcc_scalar().
+ *
+ * This is extracted to its own function because the NEON path uses a combination
+ * of NEON and scalar.
+ */
+XXH_FORCE_INLINE void
+XXH3_scalarScrambleRound(void* XXH_RESTRICT acc,
+                         void const* XXH_RESTRICT secret,
+                         size_t lane)
+{
+    xxh_u64* const xacc = (xxh_u64*) acc;   /* presumed aligned */
+    const xxh_u8* const xsecret = (const xxh_u8*) secret;   /* no alignment restriction */
+    XXH_ASSERT((((size_t)acc) & (XXH_ACC_ALIGN-1)) == 0);
+    XXH_ASSERT(lane < XXH_ACC_NB);
+    {
+        xxh_u64 const key64 = XXH_readLE64(xsecret + lane * 8);
+        xxh_u64 acc64 = xacc[lane];
+        acc64 = XXH_xorshift64(acc64, 47);
+        acc64 ^= key64;
+        acc64 *= XXH_PRIME32_1;
+        xacc[lane] = acc64;
+    }
+}
+
+/*!
+ * @internal
+ * @brief Scrambles the accumulators after a large chunk has been read
+ */
+XXH_FORCE_INLINE void
+XXH3_scrambleAcc_scalar(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+    size_t i;
+    for (i=0; i < XXH_ACC_NB; i++) {
+        XXH3_scalarScrambleRound(acc, secret, i);
+    }
+}
+
+XXH_FORCE_INLINE void
+XXH3_initCustomSecret_scalar(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
+{
+    /*
+     * We need a separate pointer for the hack below,
+     * which requires a non-const pointer.
+     * Any decent compiler will optimize this out otherwise.
+     */
+    const xxh_u8* kSecretPtr = XXH3_kSecret;
+    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 15) == 0);
+
+#if defined(__GNUC__) && defined(__aarch64__)
+    /*
+     * UGLY HACK:
+     * GCC and Clang generate a bunch of MOV/MOVK pairs for aarch64, and they are
+     * placed sequentially, in order, at the top of the unrolled loop.
+     *
+     * While MOVK is great for generating constants (2 cycles for a 64-bit
+     * constant compared to 4 cycles for LDR), it fights for bandwidth with
+     * the arithmetic instructions.
+     *
+     *   I   L   S
+     * MOVK
+     * MOVK
+     * MOVK
+     * MOVK
+     * ADD
+     * SUB      STR
+     *          STR
+     * By forcing loads from memory (as the asm line causes the compiler to assume
+     * that XXH3_kSecretPtr has been changed), the pipelines are used more
+     * efficiently:
+     *   I   L   S
+     *      LDR
+     *  ADD LDR
+     *  SUB     STR
+     *          STR
+     *
+     * See XXH3_NEON_LANES for details on the pipsline.
+     *
+     * XXH3_64bits_withSeed, len == 256, Snapdragon 835
+     *   without hack: 2654.4 MB/s
+     *   with hack:    3202.9 MB/s
+     */
+    XXH_COMPILER_GUARD(kSecretPtr);
+#endif
+    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / 16;
+        int i;
+        for (i=0; i < nbRounds; i++) {
+            /*
+             * The asm hack causes the compiler to assume that kSecretPtr aliases with
+             * customSecret, and on aarch64, this prevented LDP from merging two
+             * loads together for free. Putting the loads together before the stores
+             * properly generates LDP.
+             */
+            xxh_u64 lo = XXH_readLE64(kSecretPtr + 16*i)     + seed64;
+            xxh_u64 hi = XXH_readLE64(kSecretPtr + 16*i + 8) - seed64;
+            XXH_writeLE64((xxh_u8*)customSecret + 16*i,     lo);
+            XXH_writeLE64((xxh_u8*)customSecret + 16*i + 8, hi);
+    }   }
+}
+
+
+typedef void (*XXH3_f_accumulate)(xxh_u64* XXH_RESTRICT, const xxh_u8* XXH_RESTRICT, const xxh_u8* XXH_RESTRICT, size_t);
+typedef void (*XXH3_f_accumulate_512)(void *XXH_RESTRICT acc, const void *XXH_RESTRICT input, const void *XXH_RESTRICT secret);
+typedef void (*XXH3_f_scrambleAcc)(void* XXH_RESTRICT, const void*);
+typedef void (*XXH3_f_initCustomSecret)(void* XXH_RESTRICT, xxh_u64);
+
+
+#if (XXH_VECTOR == XXH_AVX512)
+
+#define XXH3_accumulate_512 XXH3_accumulate_512_avx512
+#define XXH3_accumulate     XXH3_accumulate_avx512
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_avx512
+#define XXH3_initCustomSecret XXH3_initCustomSecret_avx512
+
+#elif (XXH_VECTOR == XXH_AVX2)
+
+#define XXH3_accumulate_512 XXH3_accumulate_512_avx2
+#define XXH3_accumulate     XXH3_accumulate_avx2
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_avx2
+#define XXH3_initCustomSecret XXH3_initCustomSecret_avx2
+
+#elif (XXH_VECTOR == XXH_SSE2)
+
+#define XXH3_accumulate_512 XXH3_accumulate_512_sse2
+#define XXH3_accumulate     XXH3_accumulate_sse2
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_sse2
+#define XXH3_initCustomSecret XXH3_initCustomSecret_sse2
+
+#elif (XXH_VECTOR == XXH_NEON)
+
+#define XXH3_accumulate_512 XXH3_accumulate_512_neon
+#define XXH3_accumulate     XXH3_accumulate_neon
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_neon
+#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar
+
+#elif (XXH_VECTOR == XXH_VSX)
+
+#define XXH3_accumulate_512 XXH3_accumulate_512_vsx
+#define XXH3_accumulate     XXH3_accumulate_vsx
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_vsx
+#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar
+
+#elif (XXH_VECTOR == XXH_SVE)
+#define XXH3_accumulate_512 XXH3_accumulate_512_sve
+#define XXH3_accumulate     XXH3_accumulate_sve
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_scalar
+#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar
+
+#elif (XXH_VECTOR == XXH_LSX)
+#define XXH3_accumulate_512 XXH3_accumulate_512_lsx
+#define XXH3_accumulate     XXH3_accumulate_lsx
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_lsx
+#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar
+
+#else /* scalar */
+
+#define XXH3_accumulate_512 XXH3_accumulate_512_scalar
+#define XXH3_accumulate     XXH3_accumulate_scalar
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_scalar
+#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar
+
+#endif
+
+#if XXH_SIZE_OPT >= 1 /* don't do SIMD for initialization */
+#  undef XXH3_initCustomSecret
+#  define XXH3_initCustomSecret XXH3_initCustomSecret_scalar
+#endif
+
+XXH_FORCE_INLINE void
+XXH3_hashLong_internal_loop(xxh_u64* XXH_RESTRICT acc,
+                      const xxh_u8* XXH_RESTRICT input, size_t len,
+                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                            XXH3_f_accumulate f_acc,
+                            XXH3_f_accumulate_512 f_acc512,
+                            XXH3_f_scrambleAcc f_scramble)
+{
+    size_t const nbStripesPerBlock = (secretSize - XXH_STRIPE_LEN) / XXH_SECRET_CONSUME_RATE;
+    size_t const block_len = XXH_STRIPE_LEN * nbStripesPerBlock;
+    size_t const nb_blocks = (len - 1) / block_len;
+
+    size_t n;
+
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
+
+    for (n = 0; n < nb_blocks; n++) {
+        f_acc(acc, input + n*block_len, secret, nbStripesPerBlock);
+        f_scramble(acc, secret + secretSize - XXH_STRIPE_LEN);
+    }
+
+    /* last partial block */
+    XXH_ASSERT(len > XXH_STRIPE_LEN);
+    {   size_t const nbStripes = ((len - 1) - (block_len * nb_blocks)) / XXH_STRIPE_LEN;
+        XXH_ASSERT(nbStripes <= (secretSize / XXH_SECRET_CONSUME_RATE));
+        f_acc(acc, input + nb_blocks*block_len, secret, nbStripes);
+
+        /* last stripe */
+        {   const xxh_u8* const p = input + len - XXH_STRIPE_LEN;
+#define XXH_SECRET_LASTACC_START 7  /* not aligned on 8, last secret is different from acc & scrambler */
+            f_acc512(acc, p, secret + secretSize - XXH_STRIPE_LEN - XXH_SECRET_LASTACC_START);
+    }   }
+}
+
+XXH_FORCE_INLINE xxh_u64
+XXH3_mix2Accs(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret)
+{
+    return XXH3_mul128_fold64(
+               acc[0] ^ XXH_readLE64(secret),
+               acc[1] ^ XXH_readLE64(secret+8) );
+}
+
+static XXH_PUREF XXH64_hash_t
+XXH3_mergeAccs(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret, xxh_u64 start)
+{
+    xxh_u64 result64 = start;
+    size_t i = 0;
+
+    for (i = 0; i < 4; i++) {
+        result64 += XXH3_mix2Accs(acc+2*i, secret + 16*i);
+#if defined(__clang__)                                /* Clang */ \
+    && (defined(__arm__) || defined(__thumb__))       /* ARMv7 */ \
+    && (defined(__ARM_NEON) || defined(__ARM_NEON__)) /* NEON */  \
+    && !defined(XXH_ENABLE_AUTOVECTORIZE)             /* Define to disable */
+        /*
+         * UGLY HACK:
+         * Prevent autovectorization on Clang ARMv7-a. Exact same problem as
+         * the one in XXH3_len_129to240_64b. Speeds up shorter keys > 240b.
+         * XXH3_64bits, len == 256, Snapdragon 835:
+         *   without hack: 2063.7 MB/s
+         *   with hack:    2560.7 MB/s
+         */
+        XXH_COMPILER_GUARD(result64);
+#endif
+    }
+
+    return XXH3_avalanche(result64);
+}
+
+/* do not align on 8, so that the secret is different from the accumulator */
+#define XXH_SECRET_MERGEACCS_START 11
+
+static XXH_PUREF XXH64_hash_t
+XXH3_finalizeLong_64b(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret, xxh_u64 len)
+{
+    return XXH3_mergeAccs(acc, secret + XXH_SECRET_MERGEACCS_START, len * XXH_PRIME64_1);
+}
+
+#define XXH3_INIT_ACC { XXH_PRIME32_3, XXH_PRIME64_1, XXH_PRIME64_2, XXH_PRIME64_3, \
+                        XXH_PRIME64_4, XXH_PRIME32_2, XXH_PRIME64_5, XXH_PRIME32_1 }
+
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_hashLong_64b_internal(const void* XXH_RESTRICT input, size_t len,
+                           const void* XXH_RESTRICT secret, size_t secretSize,
+                           XXH3_f_accumulate f_acc,
+                           XXH3_f_accumulate_512 f_acc512,
+                           XXH3_f_scrambleAcc f_scramble)
+{
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[XXH_ACC_NB] = XXH3_INIT_ACC;
+
+    XXH3_hashLong_internal_loop(acc, (const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, f_acc, f_acc512, f_scramble);
+
+    /* converge into final hash */
+    XXH_STATIC_ASSERT(sizeof(acc) == 64);
+    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
+    return XXH3_finalizeLong_64b(acc, (const xxh_u8*)secret, (xxh_u64)len);
+}
+
+/*
+ * It's important for performance to transmit secret's size (when it's static)
+ * so that the compiler can properly optimize the vectorized loop.
+ * This makes a big performance difference for "medium" keys (<1 KB) when using AVX instruction set.
+ * When the secret size is unknown, or on GCC 12 where the mix of NO_INLINE and FORCE_INLINE
+ * breaks -Og, this is XXH_NO_INLINE.
+ */
+XXH3_WITH_SECRET_INLINE XXH64_hash_t
+XXH3_hashLong_64b_withSecret(const void* XXH_RESTRICT input, size_t len,
+                             XXH64_hash_t seed64, const xxh_u8* XXH_RESTRICT secret, size_t secretLen)
+{
+    (void)seed64;
+    return XXH3_hashLong_64b_internal(input, len, secret, secretLen, XXH3_accumulate, XXH3_accumulate_512, XXH3_scrambleAcc);
+}
+
+/*
+ * It's preferable for performance that XXH3_hashLong is not inlined,
+ * as it results in a smaller function for small data, easier to the instruction cache.
+ * Note that inside this no_inline function, we do inline the internal loop,
+ * and provide a statically defined secret size to allow optimization of vector loop.
+ */
+XXH_NO_INLINE XXH_PUREF XXH64_hash_t
+XXH3_hashLong_64b_default(const void* XXH_RESTRICT input, size_t len,
+                          XXH64_hash_t seed64, const xxh_u8* XXH_RESTRICT secret, size_t secretLen)
+{
+    (void)seed64; (void)secret; (void)secretLen;
+    return XXH3_hashLong_64b_internal(input, len, XXH3_kSecret, sizeof(XXH3_kSecret), XXH3_accumulate, XXH3_accumulate_512, XXH3_scrambleAcc);
+}
+
+/*
+ * XXH3_hashLong_64b_withSeed():
+ * Generate a custom key based on alteration of default XXH3_kSecret with the seed,
+ * and then use this key for long mode hashing.
+ *
+ * This operation is decently fast but nonetheless costs a little bit of time.
+ * Try to avoid it whenever possible (typically when seed==0).
+ *
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_hashLong_64b_withSeed_internal(const void* input, size_t len,
+                                    XXH64_hash_t seed,
+                                    XXH3_f_accumulate f_acc,
+                                    XXH3_f_accumulate_512 f_acc512,
+                                    XXH3_f_scrambleAcc f_scramble,
+                                    XXH3_f_initCustomSecret f_initSec)
+{
+#if XXH_SIZE_OPT <= 0
+    if (seed == 0)
+        return XXH3_hashLong_64b_internal(input, len,
+                                          XXH3_kSecret, sizeof(XXH3_kSecret),
+                                          f_acc, f_acc512, f_scramble);
+#endif
+    {   XXH_ALIGN(XXH_SEC_ALIGN) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
+        f_initSec(secret, seed);
+        return XXH3_hashLong_64b_internal(input, len, secret, sizeof(secret),
+                                          f_acc, f_acc512, f_scramble);
+    }
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined.
+ */
+XXH_NO_INLINE XXH64_hash_t
+XXH3_hashLong_64b_withSeed(const void* XXH_RESTRICT input, size_t len,
+                           XXH64_hash_t seed, const xxh_u8* XXH_RESTRICT secret, size_t secretLen)
+{
+    (void)secret; (void)secretLen;
+    return XXH3_hashLong_64b_withSeed_internal(input, len, seed,
+                XXH3_accumulate, XXH3_accumulate_512, XXH3_scrambleAcc, XXH3_initCustomSecret);
+}
+
+
+typedef XXH64_hash_t (*XXH3_hashLong64_f)(const void* XXH_RESTRICT, size_t,
+                                          XXH64_hash_t, const xxh_u8* XXH_RESTRICT, size_t);
+
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_64bits_internal(const void* XXH_RESTRICT input, size_t len,
+                     XXH64_hash_t seed64, const void* XXH_RESTRICT secret, size_t secretLen,
+                     XXH3_hashLong64_f f_hashLong)
+{
+    XXH_ASSERT(secretLen >= XXH3_SECRET_SIZE_MIN);
+    /*
+     * If an action is to be taken if `secretLen` condition is not respected,
+     * it should be done here.
+     * For now, it's a contract pre-condition.
+     * Adding a check and a branch here would cost performance at every hash.
+     * Also, note that function signature doesn't offer room to return an error.
+     */
+    if (len <= 16)
+        return XXH3_len_0to16_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, seed64);
+    if (len <= 128)
+        return XXH3_len_17to128_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
+    if (len <= XXH3_MIDSIZE_MAX)
+        return XXH3_len_129to240_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
+    return f_hashLong(input, len, seed64, (const xxh_u8*)secret, secretLen);
+}
+
+
+/* ===   Public entry point   === */
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(XXH_NOESCAPE const void* input, size_t length)
+{
+    return XXH3_64bits_internal(input, length, 0, XXH3_kSecret, sizeof(XXH3_kSecret), XXH3_hashLong_64b_default);
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH64_hash_t
+XXH3_64bits_withSecret(XXH_NOESCAPE const void* input, size_t length, XXH_NOESCAPE const void* secret, size_t secretSize)
+{
+    return XXH3_64bits_internal(input, length, 0, secret, secretSize, XXH3_hashLong_64b_withSecret);
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH64_hash_t
+XXH3_64bits_withSeed(XXH_NOESCAPE const void* input, size_t length, XXH64_hash_t seed)
+{
+    return XXH3_64bits_internal(input, length, seed, XXH3_kSecret, sizeof(XXH3_kSecret), XXH3_hashLong_64b_withSeed);
+}
+
+XXH_PUBLIC_API XXH64_hash_t
+XXH3_64bits_withSecretandSeed(XXH_NOESCAPE const void* input, size_t length, XXH_NOESCAPE const void* secret, size_t secretSize, XXH64_hash_t seed)
+{
+    if (length <= XXH3_MIDSIZE_MAX)
+        return XXH3_64bits_internal(input, length, seed, XXH3_kSecret, sizeof(XXH3_kSecret), NULL);
+    return XXH3_hashLong_64b_withSecret(input, length, seed, (const xxh_u8*)secret, secretSize);
+}
+
+
+/* ===   XXH3 streaming   === */
+#ifndef XXH_NO_STREAM
+/*
+ * Malloc's a pointer that is always aligned to @align.
+ *
+ * This must be freed with `XXH_alignedFree()`.
+ *
+ * malloc typically guarantees 16 byte alignment on 64-bit systems and 8 byte
+ * alignment on 32-bit. This isn't enough for the 32 byte aligned loads in AVX2
+ * or on 32-bit, the 16 byte aligned loads in SSE2 and NEON.
+ *
+ * This underalignment previously caused a rather obvious crash which went
+ * completely unnoticed due to XXH3_createState() not actually being tested.
+ * Credit to RedSpah for noticing this bug.
+ *
+ * The alignment is done manually: Functions like posix_memalign or _mm_malloc
+ * are avoided: To maintain portability, we would have to write a fallback
+ * like this anyways, and besides, testing for the existence of library
+ * functions without relying on external build tools is impossible.
+ *
+ * The method is simple: Overallocate, manually align, and store the offset
+ * to the original behind the returned pointer.
+ *
+ * Align must be a power of 2 and 8 <= align <= 128.
+ */
+static XXH_MALLOCF void* XXH_alignedMalloc(size_t s, size_t align)
+{
+    XXH_ASSERT(align <= 128 && align >= 8); /* range check */
+    XXH_ASSERT((align & (align-1)) == 0);   /* power of 2 */
+    XXH_ASSERT(s != 0 && s < (s + align));  /* empty/overflow */
+    {   /* Overallocate to make room for manual realignment and an offset byte */
+        xxh_u8* base = (xxh_u8*)XXH_malloc(s + align);
+        if (base != NULL) {
+            /*
+             * Get the offset needed to align this pointer.
+             *
+             * Even if the returned pointer is aligned, there will always be
+             * at least one byte to store the offset to the original pointer.
+             */
+            size_t offset = align - ((size_t)base & (align - 1)); /* base % align */
+            /* Add the offset for the now-aligned pointer */
+            xxh_u8* ptr = base + offset;
+
+            XXH_ASSERT((size_t)ptr % align == 0);
+
+            /* Store the offset immediately before the returned pointer. */
+            ptr[-1] = (xxh_u8)offset;
+            return ptr;
+        }
+        return NULL;
+    }
+}
+/*
+ * Frees an aligned pointer allocated by XXH_alignedMalloc(). Don't pass
+ * normal malloc'd pointers, XXH_alignedMalloc has a specific data layout.
+ */
+static void XXH_alignedFree(void* p)
+{
+    if (p != NULL) {
+        xxh_u8* ptr = (xxh_u8*)p;
+        /* Get the offset byte we added in XXH_malloc. */
+        xxh_u8 offset = ptr[-1];
+        /* Free the original malloc'd pointer */
+        xxh_u8* base = ptr - offset;
+        XXH_free(base);
+    }
+}
+/*! @ingroup XXH3_family */
+/*!
+ * @brief Allocate an @ref XXH3_state_t.
+ *
+ * @return An allocated pointer of @ref XXH3_state_t on success.
+ * @return `NULL` on failure.
+ *
+ * @note Must be freed with XXH3_freeState().
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH3_state_t* XXH3_createState(void)
+{
+    XXH3_state_t* const state = (XXH3_state_t*)XXH_alignedMalloc(sizeof(XXH3_state_t), 64);
+    if (state==NULL) return NULL;
+    XXH3_INITSTATE(state);
+    return state;
+}
+
+/*! @ingroup XXH3_family */
+/*!
+ * @brief Frees an @ref XXH3_state_t.
+ *
+ * @param statePtr A pointer to an @ref XXH3_state_t allocated with @ref XXH3_createState().
+ *
+ * @return @ref XXH_OK.
+ *
+ * @note Must be allocated with XXH3_createState().
+ *
+ * @see @ref streaming_example "Streaming Example"
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr)
+{
+    XXH_alignedFree(statePtr);
+    return XXH_OK;
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API void
+XXH3_copyState(XXH_NOESCAPE XXH3_state_t* dst_state, XXH_NOESCAPE const XXH3_state_t* src_state)
+{
+    XXH_memcpy(dst_state, src_state, sizeof(*dst_state));
+}
+
+static void
+XXH3_reset_internal(XXH3_state_t* statePtr,
+                    XXH64_hash_t seed,
+                    const void* secret, size_t secretSize)
+{
+    size_t const initStart = offsetof(XXH3_state_t, bufferedSize);
+    size_t const initLength = offsetof(XXH3_state_t, nbStripesPerBlock) - initStart;
+    XXH_ASSERT(offsetof(XXH3_state_t, nbStripesPerBlock) > initStart);
+    XXH_ASSERT(statePtr != NULL);
+    /* set members from bufferedSize to nbStripesPerBlock (excluded) to 0 */
+    memset((char*)statePtr + initStart, 0, initLength);
+    statePtr->acc[0] = XXH_PRIME32_3;
+    statePtr->acc[1] = XXH_PRIME64_1;
+    statePtr->acc[2] = XXH_PRIME64_2;
+    statePtr->acc[3] = XXH_PRIME64_3;
+    statePtr->acc[4] = XXH_PRIME64_4;
+    statePtr->acc[5] = XXH_PRIME32_2;
+    statePtr->acc[6] = XXH_PRIME64_5;
+    statePtr->acc[7] = XXH_PRIME32_1;
+    statePtr->seed = seed;
+    statePtr->useSeed = (seed != 0);
+    statePtr->extSecret = (const unsigned char*)secret;
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
+    statePtr->secretLimit = secretSize - XXH_STRIPE_LEN;
+    statePtr->nbStripesPerBlock = statePtr->secretLimit / XXH_SECRET_CONSUME_RATE;
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_reset(XXH_NOESCAPE XXH3_state_t* statePtr)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    XXH3_reset_internal(statePtr, 0, XXH3_kSecret, XXH_SECRET_DEFAULT_SIZE);
+    return XXH_OK;
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_reset_withSecret(XXH_NOESCAPE XXH3_state_t* statePtr, XXH_NOESCAPE const void* secret, size_t secretSize)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    XXH3_reset_internal(statePtr, 0, secret, secretSize);
+    if (secret == NULL) return XXH_ERROR;
+    if (secretSize < XXH3_SECRET_SIZE_MIN) return XXH_ERROR;
+    return XXH_OK;
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_reset_withSeed(XXH_NOESCAPE XXH3_state_t* statePtr, XXH64_hash_t seed)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    if (seed==0) return XXH3_64bits_reset(statePtr);
+    if ((seed != statePtr->seed) || (statePtr->extSecret != NULL))
+        XXH3_initCustomSecret(statePtr->customSecret, seed);
+    XXH3_reset_internal(statePtr, seed, NULL, XXH_SECRET_DEFAULT_SIZE);
+    return XXH_OK;
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_reset_withSecretandSeed(XXH_NOESCAPE XXH3_state_t* statePtr, XXH_NOESCAPE const void* secret, size_t secretSize, XXH64_hash_t seed64)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    if (secret == NULL) return XXH_ERROR;
+    if (secretSize < XXH3_SECRET_SIZE_MIN) return XXH_ERROR;
+    XXH3_reset_internal(statePtr, seed64, secret, secretSize);
+    statePtr->useSeed = 1; /* always, even if seed64==0 */
+    return XXH_OK;
+}
+
+/*!
+ * @internal
+ * @brief Processes a large input for XXH3_update() and XXH3_digest_long().
+ *
+ * Unlike XXH3_hashLong_internal_loop(), this can process data that overlaps a block.
+ *
+ * @param acc                Pointer to the 8 accumulator lanes
+ * @param nbStripesSoFarPtr  In/out pointer to the number of leftover stripes in the block*
+ * @param nbStripesPerBlock  Number of stripes in a block
+ * @param input              Input pointer
+ * @param nbStripes          Number of stripes to process
+ * @param secret             Secret pointer
+ * @param secretLimit        Offset of the last block in @p secret
+ * @param f_acc              Pointer to an XXH3_accumulate implementation
+ * @param f_scramble         Pointer to an XXH3_scrambleAcc implementation
+ * @return                   Pointer past the end of @p input after processing
+ */
+XXH_FORCE_INLINE const xxh_u8 *
+XXH3_consumeStripes(xxh_u64* XXH_RESTRICT acc,
+                    size_t* XXH_RESTRICT nbStripesSoFarPtr, size_t nbStripesPerBlock,
+                    const xxh_u8* XXH_RESTRICT input, size_t nbStripes,
+                    const xxh_u8* XXH_RESTRICT secret, size_t secretLimit,
+                    XXH3_f_accumulate f_acc,
+                    XXH3_f_scrambleAcc f_scramble)
+{
+    const xxh_u8* initialSecret = secret + *nbStripesSoFarPtr * XXH_SECRET_CONSUME_RATE;
+    /* Process full blocks */
+    if (nbStripes >= (nbStripesPerBlock - *nbStripesSoFarPtr)) {
+        /* Process the initial partial block... */
+        size_t nbStripesThisIter = nbStripesPerBlock - *nbStripesSoFarPtr;
+
+        do {
+            /* Accumulate and scramble */
+            f_acc(acc, input, initialSecret, nbStripesThisIter);
+            f_scramble(acc, secret + secretLimit);
+            input += nbStripesThisIter * XXH_STRIPE_LEN;
+            nbStripes -= nbStripesThisIter;
+            /* Then continue the loop with the full block size */
+            nbStripesThisIter = nbStripesPerBlock;
+            initialSecret = secret;
+        } while (nbStripes >= nbStripesPerBlock);
+        *nbStripesSoFarPtr = 0;
+    }
+    /* Process a partial block */
+    if (nbStripes > 0) {
+        f_acc(acc, input, initialSecret, nbStripes);
+        input += nbStripes * XXH_STRIPE_LEN;
+        *nbStripesSoFarPtr += nbStripes;
+    }
+    /* Return end pointer */
+    return input;
+}
+
+#ifndef XXH3_STREAM_USE_STACK
+# if XXH_SIZE_OPT <= 0 && !defined(__clang__) /* clang doesn't need additional stack space */
+#   define XXH3_STREAM_USE_STACK 1
+# endif
+#endif
+/*
+ * Both XXH3_64bits_update and XXH3_128bits_update use this routine.
+ */
+XXH_FORCE_INLINE XXH_errorcode
+XXH3_update(XXH3_state_t* XXH_RESTRICT const state,
+            const xxh_u8* XXH_RESTRICT input, size_t len,
+            XXH3_f_accumulate f_acc,
+            XXH3_f_scrambleAcc f_scramble)
+{
+    if (input==NULL) {
+        XXH_ASSERT(len == 0);
+        return XXH_OK;
+    }
+
+    XXH_ASSERT(state != NULL);
+    {   const xxh_u8* const bEnd = input + len;
+        const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;
+#if defined(XXH3_STREAM_USE_STACK) && XXH3_STREAM_USE_STACK >= 1
+        /* For some reason, gcc and MSVC seem to suffer greatly
+         * when operating accumulators directly into state.
+         * Operating into stack space seems to enable proper optimization.
+         * clang, on the other hand, doesn't seem to need this trick */
+        XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[8];
+        XXH_memcpy(acc, state->acc, sizeof(acc));
+#else
+        xxh_u64* XXH_RESTRICT const acc = state->acc;
+#endif
+        state->totalLen += len;
+        XXH_ASSERT(state->bufferedSize <= XXH3_INTERNALBUFFER_SIZE);
+
+        /* small input : just fill in tmp buffer */
+        if (len <= XXH3_INTERNALBUFFER_SIZE - state->bufferedSize) {
+            XXH_memcpy(state->buffer + state->bufferedSize, input, len);
+            state->bufferedSize += (XXH32_hash_t)len;
+            return XXH_OK;
+        }
+
+        /* total input is now > XXH3_INTERNALBUFFER_SIZE */
+        #define XXH3_INTERNALBUFFER_STRIPES (XXH3_INTERNALBUFFER_SIZE / XXH_STRIPE_LEN)
+        XXH_STATIC_ASSERT(XXH3_INTERNALBUFFER_SIZE % XXH_STRIPE_LEN == 0);   /* clean multiple */
+
+        /*
+         * Internal buffer is partially filled (always, except at beginning)
+         * Complete it, then consume it.
+         */
+        if (state->bufferedSize) {
+            size_t const loadSize = XXH3_INTERNALBUFFER_SIZE - state->bufferedSize;
+            XXH_memcpy(state->buffer + state->bufferedSize, input, loadSize);
+            input += loadSize;
+            XXH3_consumeStripes(acc,
+                               &state->nbStripesSoFar, state->nbStripesPerBlock,
+                                state->buffer, XXH3_INTERNALBUFFER_STRIPES,
+                                secret, state->secretLimit,
+                                f_acc, f_scramble);
+            state->bufferedSize = 0;
+        }
+        XXH_ASSERT(input < bEnd);
+        if (bEnd - input > XXH3_INTERNALBUFFER_SIZE) {
+            size_t nbStripes = (size_t)(bEnd - 1 - input) / XXH_STRIPE_LEN;
+            input = XXH3_consumeStripes(acc,
+                                       &state->nbStripesSoFar, state->nbStripesPerBlock,
+                                       input, nbStripes,
+                                       secret, state->secretLimit,
+                                       f_acc, f_scramble);
+            XXH_memcpy(state->buffer + sizeof(state->buffer) - XXH_STRIPE_LEN, input - XXH_STRIPE_LEN, XXH_STRIPE_LEN);
+
+        }
+        /* Some remaining input (always) : buffer it */
+        XXH_ASSERT(input < bEnd);
+        XXH_ASSERT(bEnd - input <= XXH3_INTERNALBUFFER_SIZE);
+        XXH_ASSERT(state->bufferedSize == 0);
+        XXH_memcpy(state->buffer, input, (size_t)(bEnd-input));
+        state->bufferedSize = (XXH32_hash_t)(bEnd-input);
+#if defined(XXH3_STREAM_USE_STACK) && XXH3_STREAM_USE_STACK >= 1
+        /* save stack accumulators into state */
+        XXH_memcpy(state->acc, acc, sizeof(acc));
+#endif
+    }
+
+    return XXH_OK;
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_update(XXH_NOESCAPE XXH3_state_t* state, XXH_NOESCAPE const void* input, size_t len)
+{
+    return XXH3_update(state, (const xxh_u8*)input, len,
+                       XXH3_accumulate, XXH3_scrambleAcc);
+}
+
+
+XXH_FORCE_INLINE void
+XXH3_digest_long (XXH64_hash_t* acc,
+                  const XXH3_state_t* state,
+                  const unsigned char* secret)
+{
+    xxh_u8 lastStripe[XXH_STRIPE_LEN];
+    const xxh_u8* lastStripePtr;
+
+    /*
+     * Digest on a local copy. This way, the state remains unaltered, and it can
+     * continue ingesting more input afterwards.
+     */
+    XXH_memcpy(acc, state->acc, sizeof(state->acc));
+    if (state->bufferedSize >= XXH_STRIPE_LEN) {
+        /* Consume remaining stripes then point to remaining data in buffer */
+        size_t const nbStripes = (state->bufferedSize - 1) / XXH_STRIPE_LEN;
+        size_t nbStripesSoFar = state->nbStripesSoFar;
+        XXH3_consumeStripes(acc,
+                           &nbStripesSoFar, state->nbStripesPerBlock,
+                            state->buffer, nbStripes,
+                            secret, state->secretLimit,
+                            XXH3_accumulate, XXH3_scrambleAcc);
+        lastStripePtr = state->buffer + state->bufferedSize - XXH_STRIPE_LEN;
+    } else {  /* bufferedSize < XXH_STRIPE_LEN */
+        /* Copy to temp buffer */
+        size_t const catchupSize = XXH_STRIPE_LEN - state->bufferedSize;
+        XXH_ASSERT(state->bufferedSize > 0);  /* there is always some input buffered */
+        XXH_memcpy(lastStripe, state->buffer + sizeof(state->buffer) - catchupSize, catchupSize);
+        XXH_memcpy(lastStripe + catchupSize, state->buffer, state->bufferedSize);
+        lastStripePtr = lastStripe;
+    }
+    /* Last stripe */
+    XXH3_accumulate_512(acc,
+                        lastStripePtr,
+                        secret + state->secretLimit - XXH_SECRET_LASTACC_START);
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_digest (XXH_NOESCAPE const XXH3_state_t* state)
+{
+    const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;
+    if (state->totalLen > XXH3_MIDSIZE_MAX) {
+        XXH_ALIGN(XXH_ACC_ALIGN) XXH64_hash_t acc[XXH_ACC_NB];
+        XXH3_digest_long(acc, state, secret);
+        return XXH3_finalizeLong_64b(acc, secret, (xxh_u64)state->totalLen);
+    }
+    /* totalLen <= XXH3_MIDSIZE_MAX: digesting a short input */
+    if (state->useSeed)
+        return XXH3_64bits_withSeed(state->buffer, (size_t)state->totalLen, state->seed);
+    return XXH3_64bits_withSecret(state->buffer, (size_t)(state->totalLen),
+                                  secret, state->secretLimit + XXH_STRIPE_LEN);
+}
+#endif /* !XXH_NO_STREAM */
+
+
+/* ==========================================
+ * XXH3 128 bits (a.k.a XXH128)
+ * ==========================================
+ * XXH3's 128-bit variant has better mixing and strength than the 64-bit variant,
+ * even without counting the significantly larger output size.
+ *
+ * For example, extra steps are taken to avoid the seed-dependent collisions
+ * in 17-240 byte inputs (See XXH3_mix16B and XXH128_mix32B).
+ *
+ * This strength naturally comes at the cost of some speed, especially on short
+ * lengths. Note that longer hashes are about as fast as the 64-bit version
+ * due to it using only a slight modification of the 64-bit loop.
+ *
+ * XXH128 is also more oriented towards 64-bit machines. It is still extremely
+ * fast for a _128-bit_ hash on 32-bit (it usually clears XXH64).
+ */
+
+XXH_FORCE_INLINE XXH_PUREF XXH128_hash_t
+XXH3_len_1to3_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    /* A doubled version of 1to3_64b with different constants. */
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(1 <= len && len <= 3);
+    XXH_ASSERT(secret != NULL);
+    /*
+     * len = 1: combinedl = { input[0], 0x01, input[0], input[0] }
+     * len = 2: combinedl = { input[1], 0x02, input[0], input[1] }
+     * len = 3: combinedl = { input[2], 0x03, input[0], input[1] }
+     */
+    {   xxh_u8 const c1 = input[0];
+        xxh_u8 const c2 = input[len >> 1];
+        xxh_u8 const c3 = input[len - 1];
+        xxh_u32 const combinedl = ((xxh_u32)c1 <<16) | ((xxh_u32)c2 << 24)
+                                | ((xxh_u32)c3 << 0) | ((xxh_u32)len << 8);
+        xxh_u32 const combinedh = XXH_rotl32(XXH_swap32(combinedl), 13);
+        xxh_u64 const bitflipl = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
+        xxh_u64 const bitfliph = (XXH_readLE32(secret+8) ^ XXH_readLE32(secret+12)) - seed;
+        xxh_u64 const keyed_lo = (xxh_u64)combinedl ^ bitflipl;
+        xxh_u64 const keyed_hi = (xxh_u64)combinedh ^ bitfliph;
+        XXH128_hash_t h128;
+        h128.low64  = XXH64_avalanche(keyed_lo);
+        h128.high64 = XXH64_avalanche(keyed_hi);
+        return h128;
+    }
+}
+
+XXH_FORCE_INLINE XXH_PUREF XXH128_hash_t
+XXH3_len_4to8_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(secret != NULL);
+    XXH_ASSERT(4 <= len && len <= 8);
+    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
+    {   xxh_u32 const input_lo = XXH_readLE32(input);
+        xxh_u32 const input_hi = XXH_readLE32(input + len - 4);
+        xxh_u64 const input_64 = input_lo + ((xxh_u64)input_hi << 32);
+        xxh_u64 const bitflip = (XXH_readLE64(secret+16) ^ XXH_readLE64(secret+24)) + seed;
+        xxh_u64 const keyed = input_64 ^ bitflip;
+
+        /* Shift len to the left to ensure it is even, this avoids even multiplies. */
+        XXH128_hash_t m128 = XXH_mult64to128(keyed, XXH_PRIME64_1 + (len << 2));
+
+        m128.high64 += (m128.low64 << 1);
+        m128.low64  ^= (m128.high64 >> 3);
+
+        m128.low64   = XXH_xorshift64(m128.low64, 35);
+        m128.low64  *= PRIME_MX2;
+        m128.low64   = XXH_xorshift64(m128.low64, 28);
+        m128.high64  = XXH3_avalanche(m128.high64);
+        return m128;
+    }
+}
+
+XXH_FORCE_INLINE XXH_PUREF XXH128_hash_t
+XXH3_len_9to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(secret != NULL);
+    XXH_ASSERT(9 <= len && len <= 16);
+    {   xxh_u64 const bitflipl = (XXH_readLE64(secret+32) ^ XXH_readLE64(secret+40)) - seed;
+        xxh_u64 const bitfliph = (XXH_readLE64(secret+48) ^ XXH_readLE64(secret+56)) + seed;
+        xxh_u64 const input_lo = XXH_readLE64(input);
+        xxh_u64       input_hi = XXH_readLE64(input + len - 8);
+        XXH128_hash_t m128 = XXH_mult64to128(input_lo ^ input_hi ^ bitflipl, XXH_PRIME64_1);
+        /*
+         * Put len in the middle of m128 to ensure that the length gets mixed to
+         * both the low and high bits in the 128x64 multiply below.
+         */
+        m128.low64 += (xxh_u64)(len - 1) << 54;
+        input_hi   ^= bitfliph;
+        /*
+         * Add the high 32 bits of input_hi to the high 32 bits of m128, then
+         * add the long product of the low 32 bits of input_hi and XXH_PRIME32_2 to
+         * the high 64 bits of m128.
+         *
+         * The best approach to this operation is different on 32-bit and 64-bit.
+         */
+        if (sizeof(void *) < sizeof(xxh_u64)) { /* 32-bit */
+            /*
+             * 32-bit optimized version, which is more readable.
+             *
+             * On 32-bit, it removes an ADC and delays a dependency between the two
+             * halves of m128.high64, but it generates an extra mask on 64-bit.
+             */
+            m128.high64 += (input_hi & 0xFFFFFFFF00000000ULL) + XXH_mult32to64((xxh_u32)input_hi, XXH_PRIME32_2);
+        } else {
+            /*
+             * 64-bit optimized (albeit more confusing) version.
+             *
+             * Uses some properties of addition and multiplication to remove the mask:
+             *
+             * Let:
+             *    a = input_hi.lo = (input_hi & 0x00000000FFFFFFFF)
+             *    b = input_hi.hi = (input_hi & 0xFFFFFFFF00000000)
+             *    c = XXH_PRIME32_2
+             *
+             *    a + (b * c)
+             * Inverse Property: x + y - x == y
+             *    a + (b * (1 + c - 1))
+             * Distributive Property: x * (y + z) == (x * y) + (x * z)
+             *    a + (b * 1) + (b * (c - 1))
+             * Identity Property: x * 1 == x
+             *    a + b + (b * (c - 1))
+             *
+             * Substitute a, b, and c:
+             *    input_hi.hi + input_hi.lo + ((xxh_u64)input_hi.lo * (XXH_PRIME32_2 - 1))
+             *
+             * Since input_hi.hi + input_hi.lo == input_hi, we get this:
+             *    input_hi + ((xxh_u64)input_hi.lo * (XXH_PRIME32_2 - 1))
+             */
+            m128.high64 += input_hi + XXH_mult32to64((xxh_u32)input_hi, XXH_PRIME32_2 - 1);
+        }
+        /* m128 ^= XXH_swap64(m128 >> 64); */
+        m128.low64  ^= XXH_swap64(m128.high64);
+
+        {   /* 128x64 multiply: h128 = m128 * XXH_PRIME64_2; */
+            XXH128_hash_t h128 = XXH_mult64to128(m128.low64, XXH_PRIME64_2);
+            h128.high64 += m128.high64 * XXH_PRIME64_2;
+
+            h128.low64   = XXH3_avalanche(h128.low64);
+            h128.high64  = XXH3_avalanche(h128.high64);
+            return h128;
+    }   }
+}
+
+/*
+ * Assumption: `secret` size is >= XXH3_SECRET_SIZE_MIN
+ */
+XXH_FORCE_INLINE XXH_PUREF XXH128_hash_t
+XXH3_len_0to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(len <= 16);
+    {   if (len > 8) return XXH3_len_9to16_128b(input, len, secret, seed);
+        if (len >= 4) return XXH3_len_4to8_128b(input, len, secret, seed);
+        if (len) return XXH3_len_1to3_128b(input, len, secret, seed);
+        {   XXH128_hash_t h128;
+            xxh_u64 const bitflipl = XXH_readLE64(secret+64) ^ XXH_readLE64(secret+72);
+            xxh_u64 const bitfliph = XXH_readLE64(secret+80) ^ XXH_readLE64(secret+88);
+            h128.low64 = XXH64_avalanche(seed ^ bitflipl);
+            h128.high64 = XXH64_avalanche( seed ^ bitfliph);
+            return h128;
+    }   }
+}
+
+/*
+ * A bit slower than XXH3_mix16B, but handles multiply by zero better.
+ */
+XXH_FORCE_INLINE XXH128_hash_t
+XXH128_mix32B(XXH128_hash_t acc, const xxh_u8* input_1, const xxh_u8* input_2,
+              const xxh_u8* secret, XXH64_hash_t seed)
+{
+    acc.low64  += XXH3_mix16B (input_1, secret+0, seed);
+    acc.low64  ^= XXH_readLE64(input_2) + XXH_readLE64(input_2 + 8);
+    acc.high64 += XXH3_mix16B (input_2, secret+16, seed);
+    acc.high64 ^= XXH_readLE64(input_1) + XXH_readLE64(input_1 + 8);
+    return acc;
+}
+
+
+XXH_FORCE_INLINE XXH_PUREF XXH128_hash_t
+XXH3_len_17to128_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                      XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(16 < len && len <= 128);
+
+    {   XXH128_hash_t acc;
+        acc.low64 = len * XXH_PRIME64_1;
+        acc.high64 = 0;
+
+#if XXH_SIZE_OPT >= 1
+        {
+            /* Smaller, but slightly slower. */
+            unsigned int i = (unsigned int)(len - 1) / 32;
+            do {
+                acc = XXH128_mix32B(acc, input+16*i, input+len-16*(i+1), secret+32*i, seed);
+            } while (i-- != 0);
+        }
+#else
+        if (len > 32) {
+            if (len > 64) {
+                if (len > 96) {
+                    acc = XXH128_mix32B(acc, input+48, input+len-64, secret+96, seed);
+                }
+                acc = XXH128_mix32B(acc, input+32, input+len-48, secret+64, seed);
+            }
+            acc = XXH128_mix32B(acc, input+16, input+len-32, secret+32, seed);
+        }
+        acc = XXH128_mix32B(acc, input, input+len-16, secret, seed);
+#endif
+        {   XXH128_hash_t h128;
+            h128.low64  = acc.low64 + acc.high64;
+            h128.high64 = (acc.low64    * XXH_PRIME64_1)
+                        + (acc.high64   * XXH_PRIME64_4)
+                        + ((len - seed) * XXH_PRIME64_2);
+            h128.low64  = XXH3_avalanche(h128.low64);
+            h128.high64 = (XXH64_hash_t)0 - XXH3_avalanche(h128.high64);
+            return h128;
+        }
+    }
+}
+
+XXH_NO_INLINE XXH_PUREF XXH128_hash_t
+XXH3_len_129to240_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                       const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                       XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);
+
+    {   XXH128_hash_t acc;
+        unsigned i;
+        acc.low64 = len * XXH_PRIME64_1;
+        acc.high64 = 0;
+        /*
+         *  We set as `i` as offset + 32. We do this so that unchanged
+         * `len` can be used as upper bound. This reaches a sweet spot
+         * where both x86 and aarch64 get simple agen and good codegen
+         * for the loop.
+         */
+        for (i = 32; i < 160; i += 32) {
+            acc = XXH128_mix32B(acc,
+                                input  + i - 32,
+                                input  + i - 16,
+                                secret + i - 32,
+                                seed);
+        }
+        acc.low64 = XXH3_avalanche(acc.low64);
+        acc.high64 = XXH3_avalanche(acc.high64);
+        /*
+         * NB: `i <= len` will duplicate the last 32-bytes if
+         * len % 32 was zero. This is an unfortunate necessity to keep
+         * the hash result stable.
+         */
+        for (i=160; i <= len; i += 32) {
+            acc = XXH128_mix32B(acc,
+                                input + i - 32,
+                                input + i - 16,
+                                secret + XXH3_MIDSIZE_STARTOFFSET + i - 160,
+                                seed);
+        }
+        /* last bytes */
+        acc = XXH128_mix32B(acc,
+                            input + len - 16,
+                            input + len - 32,
+                            secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET - 16,
+                            (XXH64_hash_t)0 - seed);
+
+        {   XXH128_hash_t h128;
+            h128.low64  = acc.low64 + acc.high64;
+            h128.high64 = (acc.low64    * XXH_PRIME64_1)
+                        + (acc.high64   * XXH_PRIME64_4)
+                        + ((len - seed) * XXH_PRIME64_2);
+            h128.low64  = XXH3_avalanche(h128.low64);
+            h128.high64 = (XXH64_hash_t)0 - XXH3_avalanche(h128.high64);
+            return h128;
+        }
+    }
+}
+
+static XXH_PUREF XXH128_hash_t
+XXH3_finalizeLong_128b(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret, size_t secretSize, xxh_u64 len)
+{
+    XXH128_hash_t h128;
+    h128.low64 = XXH3_finalizeLong_64b(acc, secret, len);
+    h128.high64 = XXH3_mergeAccs(acc, secret + secretSize
+                                             - XXH_STRIPE_LEN - XXH_SECRET_MERGEACCS_START,
+                                             ~(len * XXH_PRIME64_2));
+    return h128;
+}
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_hashLong_128b_internal(const void* XXH_RESTRICT input, size_t len,
+                            const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                            XXH3_f_accumulate f_acc,
+                            XXH3_f_accumulate_512 f_acc512,
+                            XXH3_f_scrambleAcc f_scramble)
+{
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[XXH_ACC_NB] = XXH3_INIT_ACC;
+
+    XXH3_hashLong_internal_loop(acc, (const xxh_u8*)input, len, secret, secretSize, f_acc, f_acc512, f_scramble);
+
+    /* converge into final hash */
+    XXH_STATIC_ASSERT(sizeof(acc) == 64);
+    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
+    return XXH3_finalizeLong_128b(acc, secret, secretSize, (xxh_u64)len);
+}
+
+/*
+ * It's important for performance that XXH3_hashLong() is not inlined.
+ */
+XXH_NO_INLINE XXH_PUREF XXH128_hash_t
+XXH3_hashLong_128b_default(const void* XXH_RESTRICT input, size_t len,
+                           XXH64_hash_t seed64,
+                           const void* XXH_RESTRICT secret, size_t secretLen)
+{
+    (void)seed64; (void)secret; (void)secretLen;
+    return XXH3_hashLong_128b_internal(input, len, XXH3_kSecret, sizeof(XXH3_kSecret),
+                                       XXH3_accumulate, XXH3_accumulate_512, XXH3_scrambleAcc);
+}
+
+/*
+ * It's important for performance to pass @p secretLen (when it's static)
+ * to the compiler, so that it can properly optimize the vectorized loop.
+ *
+ * When the secret size is unknown, or on GCC 12 where the mix of NO_INLINE and FORCE_INLINE
+ * breaks -Og, this is XXH_NO_INLINE.
+ */
+XXH3_WITH_SECRET_INLINE XXH128_hash_t
+XXH3_hashLong_128b_withSecret(const void* XXH_RESTRICT input, size_t len,
+                              XXH64_hash_t seed64,
+                              const void* XXH_RESTRICT secret, size_t secretLen)
+{
+    (void)seed64;
+    return XXH3_hashLong_128b_internal(input, len, (const xxh_u8*)secret, secretLen,
+                                       XXH3_accumulate, XXH3_accumulate_512, XXH3_scrambleAcc);
+}
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_hashLong_128b_withSeed_internal(const void* XXH_RESTRICT input, size_t len,
+                                XXH64_hash_t seed64,
+                                XXH3_f_accumulate f_acc,
+                                XXH3_f_accumulate_512 f_acc512,
+                                XXH3_f_scrambleAcc f_scramble,
+                                XXH3_f_initCustomSecret f_initSec)
+{
+    if (seed64 == 0)
+        return XXH3_hashLong_128b_internal(input, len,
+                                           XXH3_kSecret, sizeof(XXH3_kSecret),
+                                           f_acc, f_acc512, f_scramble);
+    {   XXH_ALIGN(XXH_SEC_ALIGN) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
+        f_initSec(secret, seed64);
+        return XXH3_hashLong_128b_internal(input, len, (const xxh_u8*)secret, sizeof(secret),
+                                           f_acc, f_acc512, f_scramble);
+    }
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined.
+ */
+XXH_NO_INLINE XXH128_hash_t
+XXH3_hashLong_128b_withSeed(const void* input, size_t len,
+                            XXH64_hash_t seed64, const void* XXH_RESTRICT secret, size_t secretLen)
+{
+    (void)secret; (void)secretLen;
+    return XXH3_hashLong_128b_withSeed_internal(input, len, seed64,
+                XXH3_accumulate, XXH3_accumulate_512, XXH3_scrambleAcc, XXH3_initCustomSecret);
+}
+
+typedef XXH128_hash_t (*XXH3_hashLong128_f)(const void* XXH_RESTRICT, size_t,
+                                            XXH64_hash_t, const void* XXH_RESTRICT, size_t);
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_128bits_internal(const void* input, size_t len,
+                      XXH64_hash_t seed64, const void* XXH_RESTRICT secret, size_t secretLen,
+                      XXH3_hashLong128_f f_hl128)
+{
+    XXH_ASSERT(secretLen >= XXH3_SECRET_SIZE_MIN);
+    /*
+     * If an action is to be taken if `secret` conditions are not respected,
+     * it should be done here.
+     * For now, it's a contract pre-condition.
+     * Adding a check and a branch here would cost performance at every hash.
+     */
+    if (len <= 16)
+        return XXH3_len_0to16_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, seed64);
+    if (len <= 128)
+        return XXH3_len_17to128_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
+    if (len <= XXH3_MIDSIZE_MAX)
+        return XXH3_len_129to240_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
+    return f_hl128(input, len, seed64, secret, secretLen);
+}
+
+
+/* ===   Public XXH128 API   === */
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits(XXH_NOESCAPE const void* input, size_t len)
+{
+    return XXH3_128bits_internal(input, len, 0,
+                                 XXH3_kSecret, sizeof(XXH3_kSecret),
+                                 XXH3_hashLong_128b_default);
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH128_hash_t
+XXH3_128bits_withSecret(XXH_NOESCAPE const void* input, size_t len, XXH_NOESCAPE const void* secret, size_t secretSize)
+{
+    return XXH3_128bits_internal(input, len, 0,
+                                 (const xxh_u8*)secret, secretSize,
+                                 XXH3_hashLong_128b_withSecret);
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH128_hash_t
+XXH3_128bits_withSeed(XXH_NOESCAPE const void* input, size_t len, XXH64_hash_t seed)
+{
+    return XXH3_128bits_internal(input, len, seed,
+                                 XXH3_kSecret, sizeof(XXH3_kSecret),
+                                 XXH3_hashLong_128b_withSeed);
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH128_hash_t
+XXH3_128bits_withSecretandSeed(XXH_NOESCAPE const void* input, size_t len, XXH_NOESCAPE const void* secret, size_t secretSize, XXH64_hash_t seed)
+{
+    if (len <= XXH3_MIDSIZE_MAX)
+        return XXH3_128bits_internal(input, len, seed, XXH3_kSecret, sizeof(XXH3_kSecret), NULL);
+    return XXH3_hashLong_128b_withSecret(input, len, seed, secret, secretSize);
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH128_hash_t
+XXH128(XXH_NOESCAPE const void* input, size_t len, XXH64_hash_t seed)
+{
+    return XXH3_128bits_withSeed(input, len, seed);
+}
+
+
+/* ===   XXH3 128-bit streaming   === */
+#ifndef XXH_NO_STREAM
+/*
+ * All initialization and update functions are identical to 64-bit streaming variant.
+ * The only difference is the finalization routine.
+ */
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_reset(XXH_NOESCAPE XXH3_state_t* statePtr)
+{
+    return XXH3_64bits_reset(statePtr);
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_reset_withSecret(XXH_NOESCAPE XXH3_state_t* statePtr, XXH_NOESCAPE const void* secret, size_t secretSize)
+{
+    return XXH3_64bits_reset_withSecret(statePtr, secret, secretSize);
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_reset_withSeed(XXH_NOESCAPE XXH3_state_t* statePtr, XXH64_hash_t seed)
+{
+    return XXH3_64bits_reset_withSeed(statePtr, seed);
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_reset_withSecretandSeed(XXH_NOESCAPE XXH3_state_t* statePtr, XXH_NOESCAPE const void* secret, size_t secretSize, XXH64_hash_t seed)
+{
+    return XXH3_64bits_reset_withSecretandSeed(statePtr, secret, secretSize, seed);
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_update(XXH_NOESCAPE XXH3_state_t* state, XXH_NOESCAPE const void* input, size_t len)
+{
+    return XXH3_64bits_update(state, input, len);
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (XXH_NOESCAPE const XXH3_state_t* state)
+{
+    const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;
+    if (state->totalLen > XXH3_MIDSIZE_MAX) {
+        XXH_ALIGN(XXH_ACC_ALIGN) XXH64_hash_t acc[XXH_ACC_NB];
+        XXH3_digest_long(acc, state, secret);
+        XXH_ASSERT(state->secretLimit + XXH_STRIPE_LEN >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
+        return XXH3_finalizeLong_128b(acc, secret, state->secretLimit + XXH_STRIPE_LEN,  (xxh_u64)state->totalLen);
+    }
+    /* len <= XXH3_MIDSIZE_MAX : short code */
+    if (state->useSeed)
+        return XXH3_128bits_withSeed(state->buffer, (size_t)state->totalLen, state->seed);
+    return XXH3_128bits_withSecret(state->buffer, (size_t)(state->totalLen),
+                                   secret, state->secretLimit + XXH_STRIPE_LEN);
+}
+#endif /* !XXH_NO_STREAM */
+/* 128-bit utility functions */
+
+#include <string.h>   /* memcmp, memcpy */
+
+/* return : 1 is equal, 0 if different */
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2)
+{
+    /* note : XXH128_hash_t is compact, it has no padding byte */
+    return !(memcmp(&h1, &h2, sizeof(h1)));
+}
+
+/* This prototype is compatible with stdlib's qsort().
+ * @return : >0 if *h128_1  > *h128_2
+ *           <0 if *h128_1  < *h128_2
+ *           =0 if *h128_1 == *h128_2  */
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API int XXH128_cmp(XXH_NOESCAPE const void* h128_1, XXH_NOESCAPE const void* h128_2)
+{
+    XXH128_hash_t const h1 = *(const XXH128_hash_t*)h128_1;
+    XXH128_hash_t const h2 = *(const XXH128_hash_t*)h128_2;
+    int const hcmp = (h1.high64 > h2.high64) - (h2.high64 > h1.high64);
+    /* note : bets that, in most cases, hash values are different */
+    if (hcmp) return hcmp;
+    return (h1.low64 > h2.low64) - (h2.low64 > h1.low64);
+}
+
+
+/*======   Canonical representation   ======*/
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API void
+XXH128_canonicalFromHash(XXH_NOESCAPE XXH128_canonical_t* dst, XXH128_hash_t hash)
+{
+    XXH_STATIC_ASSERT(sizeof(XXH128_canonical_t) == sizeof(XXH128_hash_t));
+    if (XXH_CPU_LITTLE_ENDIAN) {
+        hash.high64 = XXH_swap64(hash.high64);
+        hash.low64  = XXH_swap64(hash.low64);
+    }
+    XXH_memcpy(dst, &hash.high64, sizeof(hash.high64));
+    XXH_memcpy((char*)dst + sizeof(hash.high64), &hash.low64, sizeof(hash.low64));
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH128_hash_t
+XXH128_hashFromCanonical(XXH_NOESCAPE const XXH128_canonical_t* src)
+{
+    XXH128_hash_t h;
+    h.high64 = XXH_readBE64(src);
+    h.low64  = XXH_readBE64(src->digest + 8);
+    return h;
+}
+
+
+
+/* ==========================================
+ * Secret generators
+ * ==========================================
+ */
+#define XXH_MIN(x, y) (((x) > (y)) ? (y) : (x))
+
+XXH_FORCE_INLINE void XXH3_combine16(void* dst, XXH128_hash_t h128)
+{
+    XXH_writeLE64( dst, XXH_readLE64(dst) ^ h128.low64 );
+    XXH_writeLE64( (char*)dst+8, XXH_readLE64((char*)dst+8) ^ h128.high64 );
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_generateSecret(XXH_NOESCAPE void* secretBuffer, size_t secretSize, XXH_NOESCAPE const void* customSeed, size_t customSeedSize)
+{
+#if (XXH_DEBUGLEVEL >= 1)
+    XXH_ASSERT(secretBuffer != NULL);
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
+#else
+    /* production mode, assert() are disabled */
+    if (secretBuffer == NULL) return XXH_ERROR;
+    if (secretSize < XXH3_SECRET_SIZE_MIN) return XXH_ERROR;
+#endif
+
+    if (customSeedSize == 0) {
+        customSeed = XXH3_kSecret;
+        customSeedSize = XXH_SECRET_DEFAULT_SIZE;
+    }
+#if (XXH_DEBUGLEVEL >= 1)
+    XXH_ASSERT(customSeed != NULL);
+#else
+    if (customSeed == NULL) return XXH_ERROR;
+#endif
+
+    /* Fill secretBuffer with a copy of customSeed - repeat as needed */
+    {   size_t pos = 0;
+        while (pos < secretSize) {
+            size_t const toCopy = XXH_MIN((secretSize - pos), customSeedSize);
+            memcpy((char*)secretBuffer + pos, customSeed, toCopy);
+            pos += toCopy;
+    }   }
+
+    {   size_t const nbSeg16 = secretSize / 16;
+        size_t n;
+        XXH128_canonical_t scrambler;
+        XXH128_canonicalFromHash(&scrambler, XXH128(customSeed, customSeedSize, 0));
+        for (n=0; n<nbSeg16; n++) {
+            XXH128_hash_t const h128 = XXH128(&scrambler, sizeof(scrambler), n);
+            XXH3_combine16((char*)secretBuffer + n*16, h128);
+        }
+        /* last segment */
+        XXH3_combine16((char*)secretBuffer + secretSize - 16, XXH128_hashFromCanonical(&scrambler));
+    }
+    return XXH_OK;
+}
+
+/*! @ingroup XXH3_family */
+XXH_PUBLIC_API void
+XXH3_generateSecret_fromSeed(XXH_NOESCAPE void* secretBuffer, XXH64_hash_t seed)
+{
+    XXH_ALIGN(XXH_SEC_ALIGN) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
+    XXH3_initCustomSecret(secret, seed);
+    XXH_ASSERT(secretBuffer != NULL);
+    memcpy(secretBuffer, secret, XXH_SECRET_DEFAULT_SIZE);
+}
+
+
+
+/* Pop our optimization override from above */
+#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
+  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__OPTIMIZE__) && XXH_SIZE_OPT <= 0 /* respect -O0 and -Os */
+#  pragma GCC pop_options
+#endif
+
+#endif  /* XXH_NO_LONG_LONG */
+
+#endif  /* XXH_NO_XXH3 */
+
+/*!
+ * @}
+ */
+#endif  /* XXH_IMPLEMENTATION */
+
+
+#if defined (__cplusplus)
+} /* extern "C" */
+#endif
diff --git a/scripts/loader_extension_generator.py b/scripts/loader_extension_generator.py
index 5913c0d4c..433e35c3b 100644
--- a/scripts/loader_extension_generator.py
+++ b/scripts/loader_extension_generator.py
@@ -27,6 +27,7 @@ import sys
 from collections import namedtuple
 from generator import *
 from common_codegen import *
+from xxhash import xxh3_64_hexdigest
 
 
 WSI_EXT_NAMES = ['VK_KHR_surface',
@@ -249,6 +250,8 @@ class LoaderExtensionOutputGenerator(OutputGenerator):
             preamble += '#include "wsi.h"\n'
             preamble += '#include "debug_utils.h"\n'
             preamble += '#include "extension_manual.h"\n'
+            preamble += '#define XXH_INLINE_ALL\n'
+            preamble += '#include <xxhash.h>\n'
 
         elif self.genOpts.filename == 'vk_layer_dispatch_table.h':
             preamble += '#pragma once\n'
@@ -505,7 +508,7 @@ class LoaderExtensionOutputGenerator(OutputGenerator):
         protos += '\n'
         protos += '// Extension interception for vkGetInstanceProcAddr function, so we can return\n'
         protos += '// the appropriate information for any instance extensions we know about.\n'
-        protos += 'bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *name, void **addr);\n'
+        protos += 'bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *name, uint64_t nameHash, void **addr);\n'
         protos += '\n'
         protos += '// Extension interception for vkCreateInstance function, so we can properly\n'
         protos += '// detect and enable any instance extension information for extensions we know\n'
@@ -546,11 +549,12 @@ class LoaderExtensionOutputGenerator(OutputGenerator):
         protos += '                                                                         VkInstance inst);\n'
         protos += '\n'
         protos += '// Device command lookup function\n'
-        protos += 'VKAPI_ATTR void* VKAPI_CALL loader_lookup_device_dispatch_table(const VkLayerDispatchTable *table, const char *name, bool* name_found);\n'
+        protos += 'VKAPI_ATTR void* VKAPI_CALL loader_lookup_device_dispatch_table(const VkLayerDispatchTable *table, const char *name, uint64_t nameHash,\n'
+        protos += '                                                                bool* name_found);\n'
         protos += '\n'
         protos += '// Instance command lookup function\n'
         protos += 'VKAPI_ATTR void* VKAPI_CALL loader_lookup_instance_dispatch_table(const VkLayerInstanceDispatchTable *table, const char *name,\n'
-        protos += '                                                                  bool *found_name);\n'
+        protos += '                                                                  uint64_t nameHash, bool *found_name);\n'
         protos += '\n'
         return protos
 
@@ -950,13 +954,12 @@ class LoaderExtensionOutputGenerator(OutputGenerator):
                 cur_type = 'device'
 
                 tables += '// Device command lookup function\n'
-                tables += 'VKAPI_ATTR void* VKAPI_CALL loader_lookup_device_dispatch_table(const VkLayerDispatchTable *table, const char *name, bool* found_name) {\n'
+                tables += 'VKAPI_ATTR void* VKAPI_CALL loader_lookup_device_dispatch_table(const VkLayerDispatchTable *table, const char *name, uint64_t nameHash, bool* found_name) {\n'
                 tables += '    if (!name || name[0] != \'v\' || name[1] != \'k\') {\n'
                 tables += '        *found_name = false;\n'
                 tables += '        return NULL;\n'
                 tables += '    }\n'
                 tables += '\n'
-                tables += '    name += 2;\n'
                 tables += '    *found_name = true;\n'
                 tables += '    struct loader_device* dev = (struct loader_device *)table;\n'
                 tables += '    const struct loader_instance* inst = dev->phys_dev_term->this_icd_term->this_instance;\n'
@@ -967,14 +970,14 @@ class LoaderExtensionOutputGenerator(OutputGenerator):
 
                 tables += '// Instance command lookup function\n'
                 tables += 'VKAPI_ATTR void* VKAPI_CALL loader_lookup_instance_dispatch_table(const VkLayerInstanceDispatchTable *table, const char *name,\n'
-                tables += '                                                                 bool *found_name) {\n'
+                tables += '                                                                  uint64_t nameHash, bool *found_name) {\n'
                 tables += '    if (!name || name[0] != \'v\' || name[1] != \'k\') {\n'
                 tables += '        *found_name = false;\n'
                 tables += '        return NULL;\n'
                 tables += '    }\n'
                 tables += '\n'
                 tables += '    *found_name = true;\n'
-                tables += '    name += 2;\n'
+                tables += '\n'
 
 
             for y in range(0, 2):
@@ -1010,7 +1013,7 @@ class LoaderExtensionOutputGenerator(OutputGenerator):
                         if cur_cmd.protect is not None:
                             tables += f'#if defined({cur_cmd.protect})\n'
 
-                        tables += f'    if (!strcmp(name, "{base_name}")) '
+                        tables += f'    if (nameHash == 0x{xxh3_64_hexdigest(cur_cmd.name)} /* {cur_cmd.name} */) '
                         if cur_cmd.name in DEVICE_CMDS_MUST_USE_TRAMP:
                             if version_check != '':
                                 tables += f'{{\n{version_check}        return dev->layer_extensions.{cur_cmd.ext_name[3:].lower()}_enabled ? (void *){base_name} : NULL;\n    }}\n'
@@ -1457,8 +1460,8 @@ class LoaderExtensionOutputGenerator(OutputGenerator):
         cur_extension_name = ''
 
         gpa_func += '// GPA helpers for extensions\n'
-        gpa_func += 'bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *name, void **addr) {\n'
-        gpa_func += '    *addr = NULL;\n\n'
+        gpa_func += 'bool extension_instance_gpa(struct loader_instance *ptr_instance, const char *name, uint64_t nameHash, void **addr) {\n'
+        gpa_func += '    *addr = NULL;\n'
 
         for cur_cmd in self.ext_commands:
             if (self.getAPIVersion(cur_cmd.ext_name) or
@@ -1478,7 +1481,7 @@ class LoaderExtensionOutputGenerator(OutputGenerator):
             base_name = SHARED_ALIASES[cur_cmd.name] if cur_cmd.name in SHARED_ALIASES else cur_cmd.name[2:]
 
             if cur_cmd.ext_type == 'instance':
-                gpa_func += f'    if (!strcmp("{cur_cmd.name}", name)) {{\n'
+                gpa_func += f'    if (nameHash == 0x{xxh3_64_hexdigest(cur_cmd.name)} /* {cur_cmd.name} */) {{\n'
                 gpa_func += '        *addr = (ptr_instance->enabled_known_extensions.'
                 gpa_func += cur_cmd.ext_name[3:].lower()
                 gpa_func += ' == 1)\n'
@@ -1487,7 +1490,7 @@ class LoaderExtensionOutputGenerator(OutputGenerator):
                 gpa_func += '        return true;\n'
                 gpa_func += '    }\n'
             else:
-                gpa_func += f'    if (!strcmp("{cur_cmd.name}", name)) {{\n'
+                gpa_func += f'    if (nameHash == 0x{xxh3_64_hexdigest(cur_cmd.name)} /* {cur_cmd.name} */) {{\n'
                 gpa_func += f'        *addr = (void *){base_name};\n'
                 gpa_func += '        return true;\n'
                 gpa_func += '    }\n'
-- 
2.45.1

